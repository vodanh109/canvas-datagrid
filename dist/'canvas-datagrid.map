{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 3b60e274f13db23bc864","webpack:///canvas-datagrid.js","webpack:///./lib/defaults.js","webpack:///./lib/main.js","webpack:///./lib/component.js","webpack:///./lib/draw.js","webpack:///./lib/events.js","webpack:///./lib/touch.js","webpack:///./lib/intf.js","webpack:///./lib/contextMenu.js","webpack:///./lib/dom.js","webpack:///./lib/publicMethods.js"],"names":["root","factory","exports","module","define","amd","self","this","__webpack_require__","moduleId","installedModules","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","defaults","attributes","styles","context","component","Grid","args","isComponent","undefined","isChildGrid","parentNode","test","nodeType","intf","eval","document","createElement","applyComponentStyle","hyphenateProperty","dehyphenateProperty","createGrid","forEach","shadowRoot","attachShadow","mode","init","Array","slice","arguments","window","HTMLElement","create","customElements","observedAttributes","getObservableAttributes","disconnectedCallback","attributeChangedCallback","connectedCallback","adoptedCallback","canvasDatagrid","require","tKeys","keys","argKey","indexOf","tKey","sKey","data","appendChild","getDefaultItem","base","item","filter","toLowerCase","typeMap","prop","replace","nextLetterCap","char","toUpperCase","cust","supressChangeAndDrawEvents","cStyle","getComputedStyle","tagName","canvas","defs","computedStyle","def","val","getPropertyValue","setStyleProperty","dispatchEvent","requestAnimationFrame","resize","style","strData","JSON","parse","e","Error","schema","strSchema","number","strNum","parseInt","isNaN","boolean","strBool","string","str","attrs","attr","push","connected","parentDOMNode","innerHTML","observe","attrName","oldVal","newVal","tfn","dataType","addEventListener","observer","MutationObserver","mutations","checkInnerHTML","checkStyle","mutation","attributeName","target","nodeName","addedNodes","length","type","characterData","childList","subtree","querySelectorAll","el","fillArray","low","high","step","x","drawPerfLine","w","h","y","perfArr","arrIndex","max","color","useAbs","r","canvasOffsetLeft","canvasOffsetTop","ctx","beginPath","moveTo","cx","cy","Math","abs","lineTo","strokeStyle","stroke","drawOnAllImagesLoaded","loaded","htmlImageCache","html","img","complete","cachedImagesDrawn","draw","drawHtml","cell","v","formattedValue","cacheKey","toString","rowIndex","columnIndex","height","width","drawImage","Image","onload","src","btoa","drawOrderByArrow","mt","columnHeaderOrderByArrowMarginTop","scale","ml","columnHeaderOrderByArrowMarginLeft","mr","columnHeaderOrderByArrowMarginRight","aw","columnHeaderOrderByArrowWidth","ah","columnHeaderOrderByArrowHeight","fillStyle","columnHeaderOrderByArrowColor","columnHeaderOrderByArrowBorderColor","orderDirection","fill","drawTreeArrow","treeArrowMarginTop","treeArrowMarginRight","treeArrowMarginLeft","treeArrowWidth","treeArrowHeight","treeArrowColor","treeArrowBorderColor","openChildren","radiusRect","radius","b","quadraticCurveTo","fillRect","strokeRect","fillText","text","fillCircle","arc","PI","strokeCircle","clipFrozenArea","lastFrozenColumnPixel","lastFrozenRowPixel","clip","fillHandle","selectionHandleType","strokeHandle","addselectionHandle","pos","hw","selectionHandleSize","tr","br","tl","bl","addBorderLine","t","wrapText","splitChar","lines","value","calculatedLineHeight","word","elWidth","plWidth","clippedVal","previousLine","words","split","textHeight","wrap","cellWhiteSpace","et","ellipsisText","line","cHeight","paddedHeight","measureText","measure","paddedWidth","splice","originText","stepLength","direction","substr","drawText","fontHeight","lineHeight","vPos","hPos","paddingLeft","orderByArrowWidth","horizontalAlignment","paddingRight","verticalAlignment","paddingBottom","lineSpacing","offsetLeft","offsetTop","debug","active","font","debugFont","debugColor","stringify","pw","idx","idx_ord","sortColumnIndex","map","getFrozenColumnsWidth","column","getSchema","min","frozenColumn","hiddenFrozenColumnCount","hidden","getColummnWidth","perfCounters","drawCount","perfWindowSize","entityCount","scrollDebugCounters","touchPPSCounters","internal","createHandlesOverlayArray","allowMovingSelection","mobile","selectionBorderTop","selectionBorderRight","selectionHandles","selectionHandle","selectionBorderLeft","selectionBorderBottom","selectionHandleBehavior","createBorderOverlayArray","drawArray","propPrefix","offsetPoint","selectionBorder","isRowHeader","selections","isHeader","drawCell","rowOrderIndex","header","headerIndex","columnOrderIndex","cellGridAttributes","cellStyle","isCorner","isColumnHeader","selected","hovered","hovers","activeCell","isColumnHeaderCellCap","rawValue","isGrid","activeHeader","orders","rows","columns","f","formatters","orderByArrowSize","treeArrowSize","cellWidth","sizes","ev","row","cellBorderWidth","visibleRows","paddingTop","whiteSpace","cellLineHeight","cellLineSpacing","scrollTop","scrollBox","scrollLeft","cellHeight","offsetWidth","offsetHeight","offsetParent","rowOpen","sortRowIndex","isNormal","gridId","parentGrid","title","userHeight","rowHeight","userWidth","cornerCell","visibleCells","unshift","lineWidth","cellHeightWithChildGrid","checkScrollHeight","cellWidthWithChildGrid","save","tree","showRowNumbers","childGrids","saveAppearance","cellGridHeight","grid","visible","orderBy","console","warn","columnFilters","filterTextPrefix","aCell","selectionBorders","movingSelection","moveBorders","moveOffset","restore","bc","drawRowHeader","rowData","index","a","showRowHeaders","rowHeaderCell","rowHeaderCellWidth","drawRow","treeHeight","rowSansTreeHeight","g","rd","trees","scrollIndexRight","scrollPixelRight","scrollPixelLeft","treeGrid","scrollBarWidth","rowHeaders","visibleRowHeights","gridBorderCollapse","u","currentCell","columnHeaderCellHeight","getColumnHeaderCellHeight","getRowHeaderCellWidth","performance","now","createRowOrders","gridBackgroundColor","ln","frozenRow","allowFreezingRows","frozenMarkerBorderWidth","frozenMarkerWidth","snapToRow","scrollPixelTop","scrollIndexTop","scrollIndexBottom","scrollPixelBottom","showNewRow","scrollIndexLeft","newRow","cl","selectionMode","activeCellOverlayBorderWidth","activeCellOverlayBorderColor","getHeaderWidth","drawHeaderColumnRange","start","end","order","columnHeaderCell","nonFrozenHeaderWidth","rArgs","rhIndex","showColumnHeaders","columnHeaderCellBorderWidth","isColumnHeaderCell","endCap","my","mx","xHover","yHover","allowFreezingColumns","frozenMarkerHoverColor","frozenMarkerColor","frozenMarkerHoverBorderColor","frozenMarkerBorderColor","freezeMarkerPosition","frozenMarkerActiveColor","frozenMarkerActiveBorderColor","dragMode","selectionHandleBorderWidth","selectionHandleBorderColor","selectionHandleColor","az","touchSelectHandleZone","ax","ay","reorderObject","dragOffset","reorderMarkerBackgroundColor","reorderMarkerBorderWidth","reorderMarkerBorderColor","reorderMarkerIndexBorderWidth","reorderMarkerIndexBorderColor","reorderTarget","moveOverlayBorderWidth","moveOverlayBorderColor","setLineDash","moveOverlayBorderSegments","gridBorderWidth","gridBorderColor","dsb","selectionOverlayBorderWidth","selectionOverlayBorderColor","drawCorner","en","entities","scrollBarBoxMargin","scrollBarBorderColor","scrollBarBorderWidth","horizontalBox","horizontalBar","scrollBoxWidth","scrollWidth","verticalBox","verticalBar","scrollBoxHeight","scrollHeight","horizontalBarVisible","scrollBarBackgroundColor","scrollBarBoxColor","horizontalBoxVisible","scrollBarActiveColor","scrollBarBoxBorderRadius","verticalBarVisible","verticalBoxVisible","scrollBarCornerBorderColor","scrollBarCornerBackgroundColor","corner","showPerformance","pop","perf","reduce","toFixed","perfDelta","frozenColumnsWidth","htmlImages","startScale","scaleDelta","zoomDeltaStart","touchLength","touches","touchPosition","touchPosition1","scrollIndex","scrollPixel","canvasOffset","touchDelta","touchAnimateTo","scrollAnimation","touchPPS","xPPS","yPPS","touchPPST","xPPST","yPPST","touchDuration","pointerLockPosition","size","mouse","touch","touchStart","hasFocus","dragContext","textAlign","debugBackgroundColor","key","dpl","ph","px","py","debugPerfChartTextColor","debugPerfChartBackground","debugScrollHeightColor","debugScrollWidthColor","debugPerformanceColor","debugEntitiesColor","debugTouchPPSXColor","debugTouchPPSYColor","apply","wheeling","stopPropagation","fn","events","removeEventListener","sfn","preventDefault","defaultPrevented","getRatio","maxPixelRatio","devicePixelRatio","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","drawAfterResize","checkScrollBoxVisibility","dataWidth","overflowX","dataHeight","overflowY","setScrollBoxSize","setCanvasSize","dims","cellBorder","dim","appliedInlineStyles","parentNodeStyle","isComponet","vb","nb","co","isScrollBoxCorner","sbw","ratio","bm","columnHeaderCellBorder","ch","scrollCache","accumulator","va","top","left","widthBoxRatio","heightBoxRatio","scrollBarBoxMinSize","scrollBarBoxWidth","bar","box","page","pageUpDownOverlap","resizeEditInput","scroll","dontDraw","floor","ellipsisCache","mousemove","overridePos","contextMenu","input","getLayerPos","dragBounds","sBounds","delta","ctrl","ctrlKey","metaKey","persistantSelectionMode","singleSelectionMode","getCellAt","NativeEvent","previousCell","clearTimeout","scrollTimer","isInGrid","rowBoundaryCrossed","columnBoundaryCrossed","cellBoundaryCrossed","prefix","draggingItem","scrollModes","dragItem","cursor","selecting","dragStart","dragStartObject","shiftKey","bottom","right","getSelectionBounds","ignoreNextClick","dragAddToSelection","selectRow","selectionBounds","selectArea","autoScrollZone","click","checkSelectionChange","sb","startingBounds","getSelectedData","endEdit","setActiveCell","selectAll","columnHeaderClickBehavior","selectColumn","treeArrowClickRadius","toggleTree","dragResizeColumn","resizingStartingWidth","resizingStartingHeight","minColumnWidth","minRowHeight","resizeScrollZone","resizeChildGrids","globalRowResize","stopDragResize","body","setStorageData","scrollGrid","scrollPointerLock","scrollStartMode","movementX","movementY","scrollMode","scrollStart","setTimeout","scrollRepeatRate","selectionScrollIncrement","stopScrollGrid","exitPointerLock","dragReorder","columReorder","rowReorder","allowColumnReordering","allowRowReordering","source","reorderDeadZone","stopDragReorder","oIndex","tIndex","cr","dragMove","stopDragMove","moveSelection","freezeMove","stopFreezeMove","startFreezeMove","mousedown","lastMouseDownTarget","button","move","freeze","requestPointerLock","concat","dragging","mouseup","controlInput","focus","getAdjacentCells","first","last","keydown","adjacentCells","cols","keyCode","beginEditAt","Number","scrollIntoView","selectionFollowsActiveCell","selectedData","keyup","keypress","dblclick","fitColumnToValues","autosize","scrollWheel","deltaX","deltaY","deltaMode","touchHaltAnimation","scrollTo","pasteItem","clipData","mimeType","normalizeRowData","importingRow","existingRow","offsetX","isArray","colKey","substring","sel","cellData","colIndex","cName","getVisibleSchema","yi","getNextVisibleColumnIndex","visibleColumnIndex","getVisibleColumnIndexOf","paste","clipboardData","items","dti","getAsString","cut","copy","forEachSelectedCell","colName","htmlSafe","fCopyCell","addHeaders","headers","useHtml","hVal","join","addCellValue","trRow","textRow","outputHeaderKeys","tableRows","textRows","outputHeaders","sData","rowKeys","sSorted","setData","touchMove","touchScroll","rScrollZone","bScrollZone","tScrollZone","lScrollZone","touchScrollTimeout","rw","t1","t2","changedTouches","getTouchPos","touchDeadZone","touchContextTimeout","touchZoomSensitivity","touchZoomMin","touchZoomMax","zoomAltered","selectionScrollZone","calculatePPS","touchScrollStart","stopAnimation","animationFrames","touchSelecting","startingCell","touchSelect","touchMoving","touchIndex","rect","getBoundingClientRect","clientX","clientY","easingFunctions","linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easing","touchEasingMethod","calculatePPSTimed","touchSigmaTimed","touchSigma","touchEndAnimation","touchReleaseAnimationDurationMs","touchEditCell","touchCell","clearInterval","calculatePPSTimer","touchingCell","editCell","touchstart","disposeContextMenu","touchStartEvent","touchStart1","contextmenuEvent","touchContextMenuTimeMs","setInterval","touchEndEvents","touchmove","passive","touchend","touchcancel","handleType","bounds","dz","touchReleaseAcceleration","scrollAnimationPPSThreshold","ctor","treeGridAttributes","storageName","invalidSearchExpClass","localStyleLibraryStorageKey","orderings","add","sortFunction","col","sort","filters","currentFilter","sorters","parsers","schemaHashes","changes","componentL1Events","eventNames","expandToRow","orderedIndex","visibility","localStorage","setItem","tempSchema","createColumnOrders","applyDefaultValue","defaultValue","createNewRowData","getSchemaNameHash","applyFilter","refreshFromOrigialData","getHeaderByName","applyDataTransforms","getBestGuessDataType","columnName","drawChildGrids","gridKey","setTimer","originalData","validateColumn","setDefaults","obj1","obj2","setAttributes","setStyle","findColumnMaxTextLength","dispose","removeChild","eventParent","contextmenu","disconnect","tryLoadStoredSettings","reloadStoredValues","storedSettings","getDomRoot","host","getFontName","fontStyle","getFontHeight","parseFloat","parseStyleValue","initProp","propName","getStyleProperty","styleKeys","supressDrawAndEvent","isDim","getItem","message","addStyleKeyIfNoneExists","initialized","publicStyleKeyIntf","initScrollBox","setDom","ie","navigator","userAgent","edge","webKit","moz","cursorGrab","cursorGrabing","cursorGrabbing","appendTo","getVisibleCellByIndex","clearChangeLog","gotoCell","gotoRow","findColumnScrollLeft","findRowScrollTop","isCellVisible","isRowVisible","isColumnVisible","clipElement","getSchemaFromData","setFilter","expandTree","collapseTree","insertRow","deleteRow","addRow","insertColumn","deleteColumn","addColumn","getClippingRect","setRowHeight","setColumnWidth","resetColumnWidths","resetRowHeights","selectNone","assertPxColor","clearPxColorAssertions","integerToAlpha","DOMStyles","set","valueObject","filterFor","String","filterRegExp","regEnd","pattern","exec","flags","flagLength","invalidFilterRegEx","RegExp","toLocaleUpperCase","innerText","textContent","blur","TypeError","currentCursor","find","eventName","RangeError","getTypes","parseInnerHtml","callback","etl","autoGenerateSchema","autoResizeColumns","setScrollTop","preventScrollEvent","setScrollLeft","sHeight","sWidth","supressDrawEvent","applyContextItemStyle","contextItemContainer","createInlineStyle","createContextMenu","parentContextMenu","createItems","removeChildContext","relatedTarget","container","childMenuArrow","contains","children","setAttribute","contextAddCallback","getAttribute","cPos","childContextMenuMarginLeft","childContextMenuMarginTop","createChildContext","addContent","content","childContextMenuArrowHTML","clickIndex","Event","checkArrowVisibility","upArrow","downArrow","startHoverScroll","contextHoverScrollAmount","hoverScrollTimeout","contextHoverScrollRateMs","endHoverScroll","selectedIndex","loc","scrollOffset","zIndexTop","contextMenuZIndex","position","contextMenuArrowColor","zIndex","inputDropdown","maxHeight","innerHeight","autocompleteBottomMargin","minWidth","contextMenuArrowUpHTML","contextMenuArrowDownHTML","contextMenuWindowMargin","innerWidth","isFinite","createFilterContextMenuItems","checkRegExpErrorState","filterInput","background","contextFilterInputBackground","contextFilterInputColor","contextFilterInvalidRegExpBackground","contextFilterInvalidRegExpColor","fillAutoComplete","count","autoCompleteItems","maxAutoCompleteItems","disposeAutocomplete","createAutoCompleteContext","iRect","autoCompleteContext","filterContainer","filterLabel","filterAutoCompleteButton","onclick","filterOptionText","contextFilterButtonHTML","cf","removeFilterOptionText","addDefaultContextMenuItem","isNormalCell","isBackground","isScrollBar","showFilter","showCopy","copyText","execCommand","showPaste","clipBoardData","pasteText","showColumnSelector","columnSelectorText","toggleColumnVisibility","columnSelectorHiddenText","columnSelectorVisibleText","hideColumnText","showClearSettingsOption","clearSettingsOptionText","columnWidth","allowSorting","showOrderByOption","showOrderByOptionTextAsc","showOrderByOptionTextDesc","createDiposeEvent","contextPosition","contextMenuMarginLeft","contextMenuMarginTop","mobileContextMenuMargin","ele","boundingRect","eleRect","clipRect","parentRect","Infinity","scrollingElement","borderWidth","mobileEditInputHeight","cellPaddingLeft","ignoreScrollOffset","abort","abortEdit","newValue","oldValue","aborted","editable","enumItems","enu","option","valueInEnum","multiLine","editCellZIndex","fontSize","editCellFontSize","nx","ny","className","css","verticalAlign","marginLeft","padding","border","contextFilterInputBorder","borderRadius","contextFilterInputBorderRadius","fontWeight","fontFamily","contextFilterInputFontFamily","contextFilterInputFontSize","contextMenuBackground","contextMenuColor","contextFilterButtonBorder","contextFilterButtonBorderRadius","contextMenuFilterButtonFontFamily","contextMenuFilterButtonFontSize","cssFloat","childContextMenuArrowColor","contextMenuChildArrowFontSize","contextMenuFontFamily","contextMenuFontSize","contextMenuBorder","contextMenuPadding","contextMenuBorderRadius","opacity","contextMenuOpacity","overflow","contextMenuHoverBackground","contextMenuHoverColor","display","boxSizing","outline","margin","mobileEditFontFamily","mobileEditFontSize","editCellBorder","editCellColor","editCellBackgroundColor","appearance","webkitAppearance","mozAppearance","editCellPaddingLeft","editCellFontFamily","boxShadow","editCellBoxShadow","contextMenuItemMargin","contextMenuItemBorderRadius","contextMenuLabelMargin","contextMenuLabelDisplay","contextMenuLabelMinWidth","maxWidth","contextMenuLabelMaxWidth","contextMenuCursor","contextMenuFilterInvalidExpresion","onblur","parentIsCanvas","getContext","textBaseline","ordA","charCodeAt","ordZ","len","fromCharCode","offsetY","targetX","targetY","sbh","isColumnSelected","colIsSelected","shift","supressEvent","addCol","de","ri","st","dragObject","childGrid","trArgs","treeGridHeight","dontSetStorageData","sorter","xi","maxRowLength","minXi","lastSourceIndex","cidx","useTouchScrollZones","checkFrozenRow","mustFrozenRow","moveBorder","entitiy","tsz","touchScrollZone","moveMode","borderDragBehavior","xBorderBehavior","yBorderBehavior","pinnedIndex","isVerticalScrollBar","isHorizontalScrollBar","borderResizeZone","allowColumnResize","allowColumnResizeFromCell","allowRowHeaderResize","allowRowResize","allowRowResizeFromCell","rowGrabZoneSize","frozenCell","maxCol","minCol","rowHeaderCellFont","autosizePadding","autosizeHeaderCellPadding","rowHeaderCellPaddingRight","rowHeaderCellPaddingLeft","columnHeaderCellFont","headerCellPaddingRight","headerCellPaddingLeft","cellFont","cellPaddingRight","cellAutoResizePadding","total","getRowHeight","headerCell","int","asc","localeCompare","date","Date","getTime"],"mappings":"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","file":"canvas-datagrid.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"canvasDatagrid\"] = factory();\n\telse\n\t\troot[\"canvasDatagrid\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 3b60e274f13db23bc864","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"canvasDatagrid\"] = factory();\n\telse\n\t\troot[\"canvasDatagrid\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\r\n  'use strict';\r\n  return function (self) {\r\n    self.defaults = {\r\n      attributes: [\r\n        ['allowColumnReordering', true],\r\n        ['allowColumnResize', true],\r\n        ['allowColumnResizeFromCell', false],\r\n        ['allowFreezingRows', false],\r\n        ['allowFreezingColumns', false],\r\n        ['allowMovingSelection', true],\r\n        ['allowRowHeaderResize', true],\r\n        ['allowRowReordering', false],\r\n        ['allowRowResize', true],\r\n        ['allowRowResizeFromCell', false],\r\n        ['allowSorting', true],\r\n        ['autoGenerateSchema', false],\r\n        ['autoResizeColumns', false],\r\n        ['borderDragBehavior', 'none'],\r\n        ['borderResizeZone', 10],\r\n        ['clearSettingsOptionText', 'Clear saved settings'],\r\n        ['columnHeaderClickBehavior', 'sort'],\r\n        ['columnSelectorHiddenText', '&nbsp;&nbsp;&nbsp;'],\r\n        ['columnSelectorText', 'Add/Remove columns'],\r\n        ['columnSelectorVisibleText', '\\u2713'],\r\n        ['contextHoverScrollAmount', 2],\r\n        ['contextHoverScrollRateMs', 5],\r\n        ['copyHeadersOnSelectAll', true],\r\n        ['copyText', 'Copy'],\r\n        ['debug', false],\r\n        ['editable', true],\r\n        ['ellipsisText', '...'],\r\n        ['filterOptionText', 'Filter %s'],\r\n        ['filterTextPrefix', '(filtered) '],\r\n        ['globalRowResize', false],\r\n        ['hideColumnText', 'Hide %s'],\r\n        ['maxAutoCompleteItems', 200],\r\n        ['multiLine', false],\r\n        ['name', ''],\r\n        ['pageUpDownOverlap', 1],\r\n        ['pasteText', 'Paste'],\r\n        ['persistantSelectionMode', false],\r\n        ['removeFilterOptionText', 'Remove filter on %s'],\r\n        ['reorderDeadZone', 3],\r\n        ['resizeScrollZone', 20],\r\n        ['rowGrabZoneSize', 10],\r\n        ['saveAppearance', true],\r\n        ['scrollAnimationPPSThreshold', 0.75],\r\n        ['scrollPointerLock', false],\r\n        ['scrollRepeatRate', 75],\r\n        ['selectionFollowsActiveCell', false],\r\n        ['selectionHandleBehavior', 'none'],\r\n        ['selectionMode', 'cell'],\r\n        ['selectionScrollIncrement', 20],\r\n        ['selectionScrollZone', 20],\r\n        ['showClearSettingsOption', true],\r\n        ['showColumnHeaders', true],\r\n        ['showColumnSelector', true],\r\n        ['showCopy', false],\r\n        ['showFilter', true],\r\n        ['showNewRow', false],\r\n        ['showOrderByOption', true],\r\n        ['showOrderByOptionTextAsc', 'Order by %s ascending'],\r\n        ['showOrderByOptionTextDesc', 'Order by %s descending'],\r\n        ['showPaste', false],\r\n        ['showPerformance', false],\r\n        ['showRowHeaders', true],\r\n        ['showRowNumbers', true],\r\n        ['singleSelectionMode', false],\r\n        ['snapToRow', false],\r\n        ['touchContextMenuTimeMs', 800],\r\n        ['touchDeadZone', 3],\r\n        ['touchEasingMethod', 'easeOutQuad'],\r\n        ['touchReleaseAcceleration', 1000],\r\n        ['touchReleaseAnimationDurationMs', 2000],\r\n        ['touchScrollZone', 20],\r\n        ['touchSelectHandleZone', 20],\r\n        ['touchZoomSensitivity', 0.005],\r\n        ['touchZoomMin', 0.5],\r\n        ['touchZoomMax', 1.75],\r\n        ['maxPixelRatio', 2],\r\n        ['tree', false],\r\n        ['treeHorizontalScroll', false]\r\n      ],\r\n      styles: [\r\n        ['activeCellBackgroundColor', 'rgba(255, 255, 255, 1)'],\r\n        ['activeCellBorderColor', 'rgba(110, 168, 255, 1)'],\r\n        ['activeCellBorderWidth', 1],\r\n        ['activeCellColor', 'rgba(0, 0, 0, 1)'],\r\n        ['activeCellFont', '16px sans-serif'],\r\n        ['activeCellHoverBackgroundColor', 'rgba(255, 255, 255, 1)'],\r\n        ['activeCellHorizontalAlignment', 'left'],\r\n        ['activeCellHoverColor', 'rgba(0, 0, 0, 1)'],\r\n        ['activeCellOverlayBorderColor', 'rgba(66, 133, 244, 1)'],\r\n        ['activeCellOverlayBorderWidth', 1],\r\n        ['activeCellPaddingBottom', 5],\r\n        ['activeCellPaddingLeft', 5],\r\n        ['activeCellPaddingRight', 5],\r\n        ['activeCellPaddingTop', 5],\r\n        ['activeCellSelectedBackgroundColor', 'rgba(236, 243, 255, 1)'],\r\n        ['activeCellSelectedColor', 'rgba(0, 0, 0, 1)'],\r\n        ['activeCellVerticalAlignment', 'center'],\r\n        ['activeColumnHeaderCellBackgroundColor', 'rgba(225, 225, 225, 1)'],\r\n        ['activeColumnHeaderCellColor', 'rgba(0, 0, 0, 1)'],\r\n        ['activeRowHeaderCellBackgroundColor', 'rgba(225, 225, 225, 1)'],\r\n        ['activeRowHeaderCellColor', 'rgba(0, 0, 0, 1)'],\r\n        ['autocompleteBottomMargin', 60],\r\n        ['autosizeHeaderCellPadding', 8],\r\n        ['autosizePadding', 5],\r\n        ['cellAutoResizePadding', 13],\r\n        ['cellBackgroundColor', 'rgba(255, 255, 255, 1)'],\r\n        ['cellBorderColor', 'rgba(195, 199, 202, 1)'],\r\n        ['cellBorderWidth', 1],\r\n        ['cellColor', 'rgba(0, 0, 0, 1)'],\r\n        ['cellFont', '16px sans-serif'],\r\n        ['cellGridHeight', 250],\r\n        ['cellHeight', 24],\r\n        ['cellHeightWithChildGrid', 150],\r\n        ['cellHorizontalAlignment', 'left'],\r\n        ['cellHoverBackgroundColor', 'rgba(255, 255, 255, 1)'],\r\n        ['cellHoverColor', 'rgba(0, 0, 0, 1)'],\r\n        ['cellPaddingBottom', 5],\r\n        ['cellPaddingLeft', 5],\r\n        ['cellPaddingRight', 5],\r\n        ['cellPaddingTop', 5],\r\n        ['cellSelectedBackgroundColor', 'rgba(236, 243, 255, 1)'],\r\n        ['cellSelectedColor', 'rgba(0, 0, 0, 1)'],\r\n        ['cellVerticalAlignment', 'center'],\r\n        ['cellWidth', 250],\r\n        ['cellWidthWithChildGrid', 250],\r\n        ['cellWhiteSpace', 'nowrap'],\r\n        ['cellLineHeight', 1],\r\n        ['cellLineSpacing', 3],\r\n        ['childContextMenuArrowColor', 'rgba(43, 48, 43, 1)'],\r\n        ['childContextMenuArrowHTML', '&#x25BA;'],\r\n        ['childContextMenuMarginLeft', -11],\r\n        ['childContextMenuMarginTop', -6],\r\n        ['columnHeaderCellBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n        ['columnHeaderCellBorderColor', 'rgba(172, 172, 172, 1)'],\r\n        ['columnHeaderCellBorderWidth', 1],\r\n        ['columnHeaderCellCapBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n        ['columnHeaderCellCapBorderColor', 'rgba(172, 172, 172, 1)'],\r\n        ['columnHeaderCellCapBorderWidth', 1],\r\n        ['columnHeaderCellColor', 'rgba(50, 50, 50, 1)'],\r\n        ['columnHeaderCellFont', '16px sans-serif'],\r\n        ['columnHeaderCellHeight', 25],\r\n        ['columnHeaderCellHorizontalAlignment', 'left'],\r\n        ['columnHeaderCellHoverBackgroundColor', 'rgba(235, 235, 235, 1)'],\r\n        ['columnHeaderCellHoverColor', 'rgba(0, 0, 0, 1)'],\r\n        ['columnHeaderCellPaddingBottom', 5],\r\n        ['columnHeaderCellPaddingLeft', 5],\r\n        ['columnHeaderCellPaddingRight', 5],\r\n        ['columnHeaderCellPaddingTop', 5],\r\n        ['columnHeaderCellVerticalAlignment', 'center'],\r\n        ['columnHeaderOrderByArrowBorderColor', 'rgba(195, 199, 202, 1)'],\r\n        ['columnHeaderOrderByArrowBorderWidth', 1],\r\n        ['columnHeaderOrderByArrowColor', 'rgba(155, 155, 155, 1)'],\r\n        ['columnHeaderOrderByArrowHeight', 8],\r\n        ['columnHeaderOrderByArrowMarginLeft', 0],\r\n        ['columnHeaderOrderByArrowMarginRight', 5],\r\n        ['columnHeaderOrderByArrowMarginTop', 6],\r\n        ['columnHeaderOrderByArrowWidth', 13],\r\n        ['contextFilterButtonBorder', 'solid 1px rgba(158, 163, 169, 1)'],\r\n        ['contextFilterButtonBorderRadius', '3px'],\r\n        ['contextFilterButtonHTML', '&#x25BC;'],\r\n        ['contextFilterInputBackground', 'rgba(255,255,255,1)'],\r\n        ['contextFilterInputBorder', 'solid 1px rgba(158, 163, 169, 1)'],\r\n        ['contextFilterInputBorderRadius', '0'],\r\n        ['contextFilterInputColor', 'rgba(0,0,0,1)'],\r\n        ['contextFilterInputFontFamily', 'sans-serif'],\r\n        ['contextFilterInputFontSize', '14px'],\r\n        ['contextFilterInvalidRegExpBackground', 'rgba(180, 6, 1, 1)'],\r\n        ['contextFilterInvalidRegExpColor', 'rgba(255, 255, 255, 1)'],\r\n        ['contextMenuArrowColor', 'rgba(43, 48, 43, 1)'],\r\n        ['contextMenuArrowDownHTML', '&#x25BC;'],\r\n        ['contextMenuArrowUpHTML', '&#x25B2;'],\r\n        ['contextMenuBackground', 'rgba(240, 240, 240, 1)'],\r\n        ['contextMenuBorder', 'solid 1px rgba(158, 163, 169, 1)'],\r\n        ['contextMenuBorderRadius', '3px'],\r\n        ['contextMenuChildArrowFontSize', '12px'],\r\n        ['contextMenuColor', 'rgba(43, 48, 43, 1)'],\r\n        ['contextMenuCursor', 'default'],\r\n        ['contextMenuFilterButtonFontFamily', 'sans-serif'],\r\n        ['contextMenuFilterButtonFontSize', '10px'],\r\n        ['contextMenuFilterInvalidExpresion', 'rgba(237, 155, 156, 1)'],\r\n        ['contextMenuFontFamily', 'sans-serif'],\r\n        ['contextMenuFontSize', '16px'],\r\n        ['contextMenuHoverBackground', 'rgba(182, 205, 250, 1)'],\r\n        ['contextMenuHoverColor', 'rgba(43, 48, 153, 1)'],\r\n        ['contextMenuItemBorderRadius', '3px'],\r\n        ['contextMenuItemMargin', '2px'],\r\n        ['contextMenuLabelDisplay', 'inline-block'],\r\n        ['contextMenuLabelMargin', '0 3px 0 0'],\r\n        ['contextMenuLabelMaxWidth', '700px'],\r\n        ['contextMenuLabelMinWidth', '75px'],\r\n        ['contextMenuMarginLeft', 3],\r\n        ['contextMenuMarginTop', -3],\r\n        ['contextMenuOpacity', '0.98'],\r\n        ['contextMenuPadding', '2px'],\r\n        ['contextMenuWindowMargin', 30],\r\n        ['contextMenuZIndex', 10000],\r\n        ['cornerCellBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n        ['cornerCellBorderColor', 'rgba(202, 202, 202, 1)'],\r\n        ['debugBackgroundColor', 'rgba(0, 0, 0, .0)'],\r\n        ['debugColor', 'rgba(255, 15, 24, 1)'],\r\n        ['debugEntitiesColor', 'rgba(76, 231, 239, 1.00)'],\r\n        ['debugFont', '11px sans-serif'],\r\n        ['debugPerfChartBackground', 'rgba(29, 25, 26, 1.00)'],\r\n        ['debugPerfChartTextColor', 'rgba(255, 255, 255, 0.8)'],\r\n        ['debugPerformanceColor', 'rgba(252, 255, 37, 1.00)'],\r\n        ['debugScrollHeightColor', 'rgba(248, 33, 103, 1.00)'],\r\n        ['debugScrollWidthColor', 'rgba(66, 255, 27, 1.00)'],\r\n        ['debugTouchPPSXColor', 'rgba(246, 102, 24, 1.00)'],\r\n        ['debugTouchPPSYColor', 'rgba(186, 0, 255, 1.00)'],\r\n        ['display', 'inline-block'],\r\n        ['editCellBackgroundColor', 'white'],\r\n        ['editCellBorder', 'solid 1px rgba(110, 168, 255, 1)'],\r\n        ['editCellBoxShadow', '0 2px 5px rgba(0,0,0,0.4)'],\r\n        ['editCellColor', 'black'],\r\n        ['editCellFontFamily', 'sans-serif'],\r\n        ['editCellFontSize', '16px'],\r\n        ['editCellPaddingLeft', 4],\r\n        ['editCellZIndex', 10000],\r\n        ['frozenMarkerHoverColor', 'rgba(236, 243, 255, 1)'],\r\n        ['frozenMarkerHoverBorderColor', 'rgba(110, 168, 255, 1)'],\r\n        ['frozenMarkerActiveColor', 'rgba(236, 243, 255, 1)'],\r\n        ['frozenMarkerActiveBorderColor', 'rgba(110, 168, 255, 1)'],\r\n        ['frozenMarkerColor', 'rgba(222, 222, 222, 1)'],\r\n        ['frozenMarkerBorderColor', 'rgba(168, 168, 168, 1)'],\r\n        ['frozenMarkerBorderWidth', 1],\r\n        ['frozenMarkerWidth', 2],\r\n        ['gridBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n        ['gridBorderCollapse', 'collapse'],\r\n        ['gridBorderColor', 'rgba(202, 202, 202, 1)'],\r\n        ['gridBorderWidth', 1],\r\n        ['height', 'auto'],\r\n        ['maxHeight', 'inherit'],\r\n        ['maxWidth', 'inherit'],\r\n        ['minColumnWidth', 45],\r\n        ['minHeight', 'inherit'],\r\n        ['minRowHeight', 24],\r\n        ['minWidth', 'inherit'],\r\n        ['mobileContextMenuMargin', 10],\r\n        ['mobileEditInputHeight', 30],\r\n        ['mobileEditFontFamily', 'sans-serif'],\r\n        ['mobileEditFontSize', '16px'],\r\n        ['moveOverlayBorderWidth', 1],\r\n        ['moveOverlayBorderColor', 'rgba(66, 133, 244, 1)'],\r\n        ['moveOverlayBorderSegments', '12, 7'],\r\n        ['name', 'default'],\r\n        ['overflowY', 'auto'],\r\n        ['overflowX', 'auto'],\r\n        ['reorderMarkerBackgroundColor', 'rgba(0, 0, 0, 0.1)'],\r\n        ['reorderMarkerBorderColor', 'rgba(0, 0, 0, 0.2)'],\r\n        ['reorderMarkerBorderWidth', 1.25],\r\n        ['reorderMarkerIndexBorderColor', 'rgba(66, 133, 244, 1)'],\r\n        ['reorderMarkerIndexBorderWidth', 2.75],\r\n        ['rowHeaderCellBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n        ['rowHeaderCellBorderColor', 'rgba(200, 200, 200, 1)'],\r\n        ['rowHeaderCellBorderWidth', 1],\r\n        ['rowHeaderCellColor', 'rgba(50, 50, 50, 1)'],\r\n        ['rowHeaderCellFont', '16px sans-serif'],\r\n        ['rowHeaderCellHeight', 25],\r\n        ['rowHeaderCellHorizontalAlignment', 'left'],\r\n        ['rowHeaderCellHoverBackgroundColor', 'rgba(235, 235, 235, 1)'],\r\n        ['rowHeaderCellHoverColor', 'rgba(0, 0, 0, 1)'],\r\n        ['rowHeaderCellPaddingBottom', 5],\r\n        ['rowHeaderCellPaddingLeft', 5],\r\n        ['rowHeaderCellPaddingRight', 5],\r\n        ['rowHeaderCellPaddingTop', 5],\r\n        ['rowHeaderCellSelectedBackgroundColor', 'rgba(217, 217, 217, 1)'],\r\n        ['rowHeaderCellSelectedColor', 'rgba(50, 50, 50, 1)'],\r\n        ['rowHeaderCellVerticalAlignment', 'center'],\r\n        ['rowHeaderCellWidth', 57],\r\n        ['scrollBarActiveColor', 'rgba(125, 125, 125, 1)'],\r\n        ['scrollBarBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n        ['scrollBarBorderColor', 'rgba(202, 202, 202, 1)'],\r\n        ['scrollBarBorderWidth', 0.5],\r\n        ['scrollBarBoxBorderRadius', 4.125],\r\n        ['scrollBarBoxColor', 'rgba(192, 192, 192, 1)'],\r\n        ['scrollBarBoxMargin', 2],\r\n        ['scrollBarBoxMinSize', 15],\r\n        ['scrollBarBoxWidth', 8],\r\n        ['scrollBarCornerBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n        ['scrollBarCornerBorderColor', 'rgba(202, 202, 202, 1)'],\r\n        ['scrollBarWidth', 11],\r\n        ['selectionHandleBorderColor', 'rgba(255, 255, 255, 1)'],\r\n        ['selectionHandleBorderWidth', 1.5],\r\n        ['selectionHandleColor', 'rgba(66, 133, 244, 1)'],\r\n        ['selectionHandleSize', 8],\r\n        ['selectionHandleType', 'square'],\r\n        ['selectionOverlayBorderColor', 'rgba(66, 133, 244, 1)'],\r\n        ['selectionOverlayBorderWidth', 1],\r\n        ['treeArrowBorderColor', 'rgba(195, 199, 202, 1)'],\r\n        ['treeArrowBorderWidth', 1],\r\n        ['treeArrowClickRadius', 5],\r\n        ['treeArrowColor', 'rgba(155, 155, 155, 1)'],\r\n        ['treeArrowHeight', 8],\r\n        ['treeArrowMarginLeft', 0],\r\n        ['treeArrowMarginRight', 5],\r\n        ['treeArrowMarginTop', 6],\r\n        ['treeArrowWidth', 13],\r\n        ['treeGridHeight', 250],\r\n        ['width', 'auto']\r\n      ]\r\n    };\r\n  };\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true, evil: true*/\r\n/*globals Reflect: false, HTMLElement: true, define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\r\n    __webpack_require__(2),\r\n    __webpack_require__(0),\r\n    __webpack_require__(3),\r\n    __webpack_require__(4),\r\n    __webpack_require__(5),\r\n    __webpack_require__(6),\r\n    __webpack_require__(7),\r\n    __webpack_require__(8),\r\n    __webpack_require__(9)\r\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function context(component) {\r\n    'use strict';\r\n    component = component();\r\n    var modules = Array.prototype.slice.call(arguments);\r\n    function Grid(args) {\r\n        args = args || {};\r\n        var self = {};\r\n        self.isComponent = args.component === undefined;\r\n        self.isChildGrid = args.parentNode && /canvas-datagrid-(cell|tree)/.test(args.parentNode.nodeType);\r\n        if (self.isChildGrid) {\r\n            self.intf = {};\r\n        } else {\r\n            self.intf = self.isComponent ? eval('Reflect.construct(HTMLElement, [], new.target)')\r\n                : document.createElement('canvas');\r\n        }\r\n        self.args = args;\r\n        self.intf.args = args;\r\n        self.applyComponentStyle = component.applyComponentStyle;\r\n        self.hyphenateProperty = component.hyphenateProperty;\r\n        self.dehyphenateProperty = component.dehyphenateProperty;\r\n        self.createGrid = function grid(args) {\r\n            args.component = false;\r\n            return new Grid(args);\r\n        };\r\n        modules.forEach(function (module) {\r\n            module(self);\r\n        });\r\n        if (self.isChildGrid) {\r\n            self.shadowRoot = args.parentNode.shadowRoot;\r\n            self.parentNode = args.parentNode;\r\n        } else {\r\n            self.shadowRoot = self.intf.attachShadow({mode: 'open'});\r\n            self.parentNode = self.shadowRoot;\r\n        }\r\n        self.init();\r\n        return self.intf;\r\n    }\r\n    if (window.HTMLElement) {\r\n        Grid.prototype = Object.create(window.HTMLElement.prototype);\r\n    }\r\n    // export web component\r\n    if (window.customElements) {\r\n        Grid.observedAttributes = component.getObservableAttributes();\r\n        Grid.prototype.disconnectedCallback = component.disconnectedCallback;\r\n        Grid.prototype.attributeChangedCallback = component.attributeChangedCallback;\r\n        Grid.prototype.connectedCallback = component.connectedCallback;\r\n        Grid.prototype.adoptedCallback = component.adoptedCallback;\r\n        window.customElements.define('canvas-datagrid', Grid);\r\n    }\r\n    // export global\r\n    if (window && !window.canvasDatagrid && !window.require) {\r\n        window.canvasDatagrid = function (args) { return new Grid(args); };\r\n    }\r\n    // export amd loader\r\n    module.exports = function grid(args) {\r\n        args = args || {};\r\n        var i, tKeys = ['style', 'formatters', 'sorters', 'filters',\r\n                    'treeGridAttributes', 'cellGridAttributes', 'data', 'schema'];\r\n        if (window.customElements) {\r\n            i = document.createElement('canvas-datagrid');\r\n            Object.keys(args).forEach(function (argKey) {\r\n                // set data and parentNode after everything else\r\n                if (argKey === 'data') { return; }\r\n                if (argKey === 'parentNode') { return; }\r\n                // top level keys in args\r\n                if (tKeys.indexOf(argKey) !== -1) {\r\n                    tKeys.forEach(function (tKey) {\r\n                        if (args[tKey] === undefined || tKey !== argKey) { return; }\r\n                        if (['formatters', 'sorters', 'filters'].indexOf(argKey) !== -1) {\r\n                            if (typeof args[tKey] === 'object' && args[tKey] !== null) {\r\n                                Object.keys(args[tKey]).forEach(function (sKey) {\r\n                                    i[tKey][sKey] = args[tKey][sKey];\r\n                                });\r\n                            }\r\n                        } else {\r\n                            i[tKey] = args[tKey];\r\n                        }\r\n                    });\r\n                    return;\r\n                }\r\n                // all others are attribute level keys\r\n                i.attributes[argKey] = args[argKey];\r\n            });\r\n            if (args.data) {\r\n                i.data = args.data;\r\n            }\r\n            // add to the dom very last to avoid redraws\r\n            if (args.parentNode) {\r\n                args.parentNode.appendChild(i);\r\n            }\r\n            return i;\r\n        }\r\n        args.component = false;\r\n        i = new Grid(args);\r\n        if (args.parentNode && args.parentNode.appendChild) {\r\n            args.parentNode.appendChild(i);\r\n        }\r\n        return i;\r\n    };\r\n    return module.exports;\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (defaults) {\r\n    'use strict';\r\n    return function () {\r\n        var typeMap, component = {};\r\n        component.dehyphenateProperty = function hyphenateProperty(prop) {\r\n            prop = prop.replace('--cdg-', '');\r\n            var p = '', nextLetterCap;\r\n            Array.prototype.forEach.call(prop, function (char) {\r\n                if (nextLetterCap) {\r\n                    nextLetterCap = false;\r\n                    p += char.toUpperCase();\r\n                    return;\r\n                }\r\n                if (char === '-') {\r\n                    nextLetterCap = true;\r\n                    return;\r\n                }\r\n                p += char;\r\n            });\r\n            return p;\r\n        };\r\n        component.hyphenateProperty = function hyphenateProperty(prop, cust) {\r\n            var p = '';\r\n            Array.prototype.forEach.call(prop, function (char) {\r\n                if (char === char.toUpperCase()) {\r\n                    p += '-' + char.toLowerCase();\r\n                    return;\r\n                }\r\n                p += char;\r\n            });\r\n            return (cust ? '--cdg-' : '') + p;\r\n        };\r\n        function getDefaultItem(base, item) {\r\n            var i = {},\r\n                r;\r\n            defaults(i);\r\n            r = i.defaults[base].filter(function (i) {\r\n                return i[0].toLowerCase() === item.toLowerCase()\r\n                    || component.hyphenateProperty(i[0]) === item.toLowerCase()\r\n                    || component.hyphenateProperty(i[0], true) === item.toLowerCase();\r\n            })[0];\r\n            return r;\r\n        }\r\n        component.applyComponentStyle = function (supressChangeAndDrawEvents, intf) {\r\n            if (!intf.isComponent) { return; }\r\n            var cStyle = window.getComputedStyle(intf.tagName === 'CANVAS-DATAGRID' ? intf : intf.canvas, null),\r\n                defs = {};\r\n            intf.computedStyle = cStyle;\r\n            defaults(defs);\r\n            defs = defs.defaults.styles;\r\n            defs.forEach(function (def) {\r\n                var val;\r\n                val = cStyle.getPropertyValue(component.hyphenateProperty(def[0], true));\r\n                if (val === \"\") {\r\n                    val = cStyle.getPropertyValue(component.hyphenateProperty(def[0], false));\r\n                }\r\n                if (val !== \"\" && typeof val === 'string') {\r\n                    intf.setStyleProperty(def[0], typeMap[typeof def[1]](val\r\n                        .replace(/^\\s+/, '').replace(/\\s+$/, ''), def[1]), true);\r\n                }\r\n            });\r\n            if (!supressChangeAndDrawEvents && intf.dispatchEvent) {\r\n                requestAnimationFrame(function () { intf.resize(true); });\r\n                intf.dispatchEvent('stylechanged', intf.style);\r\n            }\r\n        };\r\n        typeMap = {\r\n            data: function (strData) {\r\n                try {\r\n                    return JSON.parse(strData);\r\n                } catch (e) {\r\n                    throw new Error('Cannot read JSON data in canvas-datagrid data.');\r\n                }\r\n            },\r\n            schema: function (strSchema) {\r\n                try {\r\n                    return JSON.parse(strSchema);\r\n                } catch (e) {\r\n                    throw new Error('Cannot read JSON data in canvas-datagrid schema attribute.');\r\n                }\r\n            },\r\n            number: function (strNum, def) {\r\n                var n = parseInt(strNum, 10);\r\n                return isNaN(n) ? def : n;\r\n            },\r\n            boolean: function (strBool) {\r\n                return (/true/i).test(strBool);\r\n            },\r\n            string: function (str) {\r\n                return str;\r\n            }\r\n        };\r\n        component.getObservableAttributes = function () {\r\n            var i = {}, attrs = ['data', 'schema', 'style', 'className', 'name'];\r\n            defaults(i);\r\n            i.defaults.attributes.forEach(function (attr) {\r\n                attrs.push(attr[0].toLowerCase());\r\n            });\r\n            return attrs;\r\n        };\r\n        component.disconnectedCallback = function () {\r\n            this.connected = false;\r\n        };\r\n        component.connectedCallback = function () {\r\n            var intf = this;\r\n            intf.parentDOMNode.innerHTML = \"\";\r\n            intf.parentDOMNode.appendChild(intf.canvas);\r\n            intf.connected = true;\r\n            component.observe(intf);\r\n            component.applyComponentStyle(true, intf);\r\n            intf.resize(true);\r\n        };\r\n        component.adoptedCallback = function () {\r\n            this.resize();\r\n        };\r\n        component.attributeChangedCallback = function (attrName, oldVal, newVal) {\r\n            var tfn, intf = this, def;\r\n            if (attrName === 'style') {\r\n                component.applyComponentStyle(false, intf);\r\n                return;\r\n            }\r\n            if (attrName === 'data') {\r\n                if (intf.dataType === 'application/x-canvas-datagrid') {\r\n                    intf.dataType = 'application/json+x-canvas-datagrid';\r\n                }\r\n                intf.args.data = newVal;\r\n                return;\r\n            }\r\n            if (attrName === 'schema') {\r\n                intf.args.schema = typeMap.schema(newVal);\r\n                return;\r\n            }\r\n            if (attrName === 'name') {\r\n                intf.name = newVal;\r\n                return;\r\n            }\r\n            if (attrName === 'class' || attrName === 'className') {\r\n                return;\r\n            }\r\n            def = getDefaultItem('attributes', attrName);\r\n            if (def) {\r\n                tfn = typeMap[typeof def[1]];\r\n                intf.attributes[def[0]] = tfn(newVal);\r\n                return;\r\n            }\r\n            if (/^on/.test(attrName)) {\r\n                intf.addEventListener('on' + attrName, function (e) {\r\n                    eval(newVal);\r\n                });\r\n            }\r\n            return;\r\n        };\r\n        component.observe = function (intf) {\r\n            var observer;\r\n            if (!window.MutationObserver) { return; }\r\n            intf.applyComponentStyle = function () { component.applyComponentStyle(false, intf); intf.resize(); };\r\n            /**\r\n             * Applies the computed css styles to the grid.  In some browsers, changing directives in attached style sheets does not automatically update the styles in this component.  It is necessary to call this method to update in these cases.\r\n             * @memberof canvasDatagrid\r\n             * @name applyComponentStyle\r\n             * @method\r\n             */\r\n            observer = new window.MutationObserver(function (mutations) {\r\n                var checkInnerHTML, checkStyle;\r\n                Array.prototype.forEach.call(mutations, function (mutation) {\r\n                    if (mutation.attributeName === 'class'\r\n                            || mutation.attributeName === 'style') {\r\n                        checkStyle = true;\r\n                        return;\r\n                    }\r\n                    if (mutation.target.nodeName === 'STYLE') {\r\n                        checkStyle = true;\r\n                        return;\r\n                    }\r\n                    if (mutation.target.parentNode\r\n                            && mutation.target.parentNode.nodeName === 'STYLE') {\r\n                        checkStyle = true;\r\n                        return;\r\n                    }\r\n                    if (mutation.target === intf && (mutation.addedNodes.length > 0 || mutation.type === 'characterData')) {\r\n                        checkInnerHTML = true;\r\n                    }\r\n                });\r\n                if (checkStyle) {\r\n                    intf.applyComponentStyle(false, intf);\r\n                }\r\n                if (checkInnerHTML) {\r\n                    if (intf.dataType === 'application/x-canvas-datagrid') {\r\n                        intf.dataType = 'application/json+x-canvas-datagrid';\r\n                    }\r\n                    intf.data = intf.innerHTML;\r\n                }\r\n            });\r\n            observer.observe(intf, { characterData: true, childList: true, attributes: true, subtree: true });\r\n            Array.prototype.forEach.call(document.querySelectorAll('style'), function (el) {\r\n                observer.observe(el, { characterData: true, childList: true, attributes: true, subtree: true });\r\n            });\r\n        };\r\n        return component;\r\n    };\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals XMLSerializer: false, define: true, Blob: false, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\r\n  'use strict';\r\n  return function (self) {\r\n    var perfCounters = [],\r\n      cachedImagesDrawn = false,\r\n      drawCount = 0,\r\n      perfWindowSize = 300,\r\n      entityCount = [],\r\n      hiddenFrozenColumnCount = 0,\r\n      scrollDebugCounters = [],\r\n      touchPPSCounters = [];\r\n    self.htmlImageCache = {};\r\n    // more heavyweight version than fillArray defined in intf.js\r\n    function fillArray(low, high, step, def) {\r\n      step = step || 1;\r\n      var i = [], x;\r\n      for (x = low; x <= high; x += step) {\r\n        i[x] = def === undefined ? x : (typeof def === 'function' ? def(x) : def);\r\n      }\r\n      return i;\r\n    }\r\n    function drawPerfLine(w, h, x, y, perfArr, arrIndex, max, color, useAbs) {\r\n      var i = w / perfArr.length,\r\n        r = h / max;\r\n      x += self.canvasOffsetLeft;\r\n      y += self.canvasOffsetTop;\r\n      self.ctx.beginPath();\r\n      self.ctx.moveTo(x, y + h);\r\n      perfArr.forEach(function (n) {\r\n        var val = (arrIndex === undefined ? n : n[arrIndex]),\r\n          cx,\r\n          cy;\r\n        if (useAbs) {\r\n          val = Math.abs(val);\r\n        }\r\n        cx = x + i;\r\n        cy = y + h - (val * r);\r\n        self.ctx.lineTo(cx, cy);\r\n        x += i;\r\n      });\r\n      self.ctx.moveTo(x + w, y + h);\r\n      self.ctx.strokeStyle = color;\r\n      self.ctx.stroke();\r\n    }\r\n    function drawOnAllImagesLoaded() {\r\n      var loaded = true;\r\n      Object.keys(self.htmlImageCache).forEach(function (html) {\r\n        if (!self.htmlImageCache[html].img.complete) {\r\n          loaded = false;\r\n        }\r\n      });\r\n      if (loaded && !cachedImagesDrawn) {\r\n        cachedImagesDrawn = true;\r\n        self.draw();\r\n      }\r\n    }\r\n    function drawHtml(cell) {\r\n      var img,\r\n        v = cell.innerHTML || cell.formattedValue,\r\n        cacheKey = v.toString() + cell.rowIndex.toString() + cell.columnIndex.toString(),\r\n        x = cell.x + self.canvasOffsetLeft,\r\n        y = cell.y + self.canvasOffsetTop;\r\n      if (self.htmlImageCache[cacheKey]) {\r\n        img = self.htmlImageCache[cacheKey].img;\r\n        if (self.htmlImageCache[cacheKey].height !== cell.height || self.htmlImageCache[cacheKey].width !== cell.width) {\r\n          // height and width of the cell has changed, invalidate cache\r\n          self.htmlImageCache[cacheKey] = undefined;\r\n        } else {\r\n          if (!img.complete) {\r\n            return;\r\n          }\r\n          return self.ctx.drawImage(img, x, y);\r\n        }\r\n      } else {\r\n        cachedImagesDrawn = false;\r\n      }\r\n      img = new Image(cell.width, cell.height);\r\n      self.htmlImageCache[cacheKey] = { img: img, width: cell.width, height: cell.height };\r\n      img.onload = function () {\r\n        self.ctx.drawImage(img, x, y);\r\n        drawOnAllImagesLoaded();\r\n      };\r\n      img.src = 'data:image/svg+xml;base64,' + btoa(\r\n        '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"' + cell.width + '\" height=\"' + cell.height + '\">\\n' +\r\n        '<foreignObject class=\"node\" x=\"0\" y=\"0\" width=\"100%\" height=\"100%\">\\n' +\r\n        '<body xmlns=\"http://www.w3.org/1999/xhtml\" style=\"margin:0;padding:0;\">\\n' +\r\n        v + '\\n' +\r\n        '</body>' +\r\n        '</foreignObject>\\n' +\r\n        '</svg>\\n'\r\n      );\r\n    }\r\n    function drawOrderByArrow(x, y) {\r\n      var mt = self.style.columnHeaderOrderByArrowMarginTop * self.scale,\r\n        ml = self.style.columnHeaderOrderByArrowMarginLeft * self.scale,\r\n        mr = self.style.columnHeaderOrderByArrowMarginRight * self.scale,\r\n        aw = self.style.columnHeaderOrderByArrowWidth * self.scale,\r\n        ah = self.style.columnHeaderOrderByArrowHeight * self.scale;\r\n      x += self.canvasOffsetLeft;\r\n      y += self.canvasOffsetTop;\r\n      self.ctx.fillStyle = self.style.columnHeaderOrderByArrowColor;\r\n      self.ctx.strokeStyle = self.style.columnHeaderOrderByArrowBorderColor;\r\n      self.ctx.beginPath();\r\n      x = x + ml;\r\n      y = y + mt;\r\n      if (self.orderDirection === 'asc') {\r\n        self.ctx.moveTo(x, y);\r\n        self.ctx.lineTo(x + aw, y);\r\n        self.ctx.lineTo(x + (aw * 0.5), y + ah);\r\n        self.ctx.moveTo(x, y);\r\n      } else {\r\n        self.ctx.lineTo(x, y + ah);\r\n        self.ctx.lineTo(x + aw, y + ah);\r\n        self.ctx.lineTo(x + (aw * 0.5), y);\r\n        self.ctx.lineTo(x, y + ah);\r\n      }\r\n      self.ctx.stroke();\r\n      self.ctx.fill();\r\n      return ml + aw + mr;\r\n    }\r\n    function drawTreeArrow(cell, x, y) {\r\n      var mt = self.style.treeArrowMarginTop * self.scale,\r\n        mr = self.style.treeArrowMarginRight * self.scale,\r\n        ml = self.style.treeArrowMarginLeft * self.scale,\r\n        aw = self.style.treeArrowWidth * self.scale,\r\n        ah = self.style.treeArrowHeight * self.scale;\r\n      x += self.canvasOffsetLeft;\r\n      y += self.canvasOffsetTop;\r\n      self.ctx.fillStyle = self.style.treeArrowColor;\r\n      self.ctx.strokeStyle = self.style.treeArrowBorderColor;\r\n      self.ctx.beginPath();\r\n      x = x + ml;\r\n      y = y + mt;\r\n      if (self.openChildren[cell.rowIndex]) {\r\n        self.ctx.moveTo(x, y);\r\n        self.ctx.lineTo(x + aw, y);\r\n        self.ctx.lineTo(x + (aw * 0.5), y + ah);\r\n        self.ctx.moveTo(x, y);\r\n      } else {\r\n        self.ctx.lineTo(x, y);\r\n        self.ctx.lineTo(x + ah, y + (aw * 0.5));\r\n        self.ctx.lineTo(x, y + aw);\r\n        self.ctx.lineTo(x, y);\r\n      }\r\n      self.ctx.stroke();\r\n      self.ctx.fill();\r\n      return ml + aw + mr;\r\n    }\r\n    function radiusRect(x, y, w, h, radius) {\r\n      x += self.canvasOffsetLeft;\r\n      y += self.canvasOffsetTop;\r\n      var r = x + w, b = y + h;\r\n      self.ctx.beginPath();\r\n      self.ctx.moveTo(x + radius, y);\r\n      self.ctx.lineTo(r - radius, y);\r\n      self.ctx.quadraticCurveTo(r, y, r, y + radius);\r\n      self.ctx.lineTo(r, y + h - radius);\r\n      self.ctx.quadraticCurveTo(r, b, r - radius, b);\r\n      self.ctx.lineTo(x + radius, b);\r\n      self.ctx.quadraticCurveTo(x, b, x, b - radius);\r\n      self.ctx.lineTo(x, y + radius);\r\n      self.ctx.quadraticCurveTo(x, y, x + radius, y);\r\n    }\r\n    function fillRect(x, y, w, h) {\r\n      x += self.canvasOffsetLeft;\r\n      y += self.canvasOffsetTop;\r\n      self.ctx.fillRect(x, y, w, h);\r\n    }\r\n    function strokeRect(x, y, w, h) {\r\n      x += self.canvasOffsetLeft;\r\n      y += self.canvasOffsetTop;\r\n      self.ctx.strokeRect(x, y, w, h);\r\n    }\r\n    function fillText(text, x, y) {\r\n      x += self.canvasOffsetLeft;\r\n      y += self.canvasOffsetTop;\r\n      self.ctx.fillText(text, x, y);\r\n    }\r\n    function fillCircle(x, y, r) {\r\n      x += self.canvasOffsetLeft;\r\n      y += self.canvasOffsetTop;\r\n      self.ctx.beginPath();\r\n      self.ctx.arc(x, y, r, 0, 2 * Math.PI);\r\n      self.ctx.fill();\r\n    }\r\n    function strokeCircle(x, y, r) {\r\n      x += self.canvasOffsetLeft;\r\n      y += self.canvasOffsetTop;\r\n      self.ctx.beginPath();\r\n      self.ctx.arc(x, y, r, 0, 2 * Math.PI);\r\n      self.ctx.stroke();\r\n    }\r\n    function clipFrozenArea(mode) {\r\n      // 0 both, 1 rows, 2 cols\r\n      // self.lastFrozenColumnPixel;\r\n      // self.lastFrozenRowPixel;\r\n      self.ctx.beginPath();\r\n      if (mode === 0) {\r\n        self.ctx.moveTo(self.lastFrozenColumnPixel, self.lastFrozenRowPixel);\r\n        self.ctx.lineTo(self.lastFrozenColumnPixel, self.height);\r\n        self.ctx.lineTo(self.width, self.height);\r\n        self.ctx.lineTo(self.width, self.lastFrozenRowPixel);\r\n      }\r\n      if (mode === 1) {\r\n        self.ctx.moveTo(0, self.lastFrozenRowPixel);\r\n        self.ctx.lineTo(0, self.height);\r\n        self.ctx.lineTo(self.width, self.height);\r\n        self.ctx.lineTo(self.width, self.lastFrozenRowPixel);\r\n      }\r\n      if (mode === 2) {\r\n        self.ctx.moveTo(self.lastFrozenColumnPixel, 0);\r\n        self.ctx.lineTo(self.width, 0);\r\n        self.ctx.lineTo(self.width, self.height);\r\n        self.ctx.lineTo(self.lastFrozenColumnPixel, self.height);\r\n      }\r\n      self.ctx.clip();\r\n    }\r\n    function fillHandle(x, y, r) {\r\n      if (self.style.selectionHandleType === 'circle') {\r\n        return fillCircle(x, y, r * 0.5);\r\n      }\r\n      fillRect(x - r * 0.5, y - r * 0.5, r, r);\r\n    }\r\n    function strokeHandle(x, y, r) {\r\n      if (self.style.selectionHandleType === 'circle') {\r\n        return strokeCircle(x, y, r * 0.5);\r\n      }\r\n      strokeRect(x - r * 0.5, y - r * 0.5, r, r);\r\n    }\r\n    function addselectionHandle(c, pos) {\r\n      var hw = self.style.selectionHandleSize,\r\n        p = {\r\n          tr: function () {\r\n            fillHandle(c.x + c.width, c.y, hw);\r\n            strokeHandle(c.x + c.width, c.y, hw);\r\n          },\r\n          br: function () {\r\n            fillHandle(c.x + c.width, c.y + c.height, hw);\r\n            strokeHandle(c.x + c.width, c.y + c.height, hw);\r\n          },\r\n          tl: function () {\r\n            fillHandle(c.x, c.y, hw);\r\n            strokeHandle(c.x, c.y, hw);\r\n          },\r\n          bl: function () {\r\n            fillHandle(c.x, c.y + c.height, hw);\r\n            strokeHandle(c.x, c.y + c.height, hw);\r\n          }\r\n        };\r\n      p[pos]();\r\n    }\r\n    function addBorderLine(c, pos) {\r\n      self.ctx.beginPath();\r\n      var p = {\r\n        t: function () {\r\n          self.ctx.moveTo(c.x + self.canvasOffsetLeft, c.y + self.canvasOffsetTop);\r\n          self.ctx.lineTo(c.x + self.canvasOffsetLeft + c.width, c.y + self.canvasOffsetTop);\r\n        },\r\n        r: function () {\r\n          self.ctx.moveTo(c.x + self.canvasOffsetLeft + c.width, c.y + self.canvasOffsetTop);\r\n          self.ctx.lineTo(c.x + self.canvasOffsetLeft + c.width, c.y + self.canvasOffsetTop + c.height);\r\n        },\r\n        b: function () {\r\n          self.ctx.moveTo(c.x + self.canvasOffsetLeft, c.y + self.canvasOffsetTop + c.height);\r\n          self.ctx.lineTo(c.x + self.canvasOffsetLeft + c.width, c.y + self.canvasOffsetTop + c.height);\r\n        },\r\n        l: function () {\r\n          self.ctx.moveTo(c.x + self.canvasOffsetLeft, c.y + self.canvasOffsetTop);\r\n          self.ctx.lineTo(c.x + self.canvasOffsetLeft, c.y + self.canvasOffsetTop + c.height);\r\n        }\r\n      };\r\n      p[pos]();\r\n      self.ctx.stroke();\r\n    }\r\n    function addEllipsis(text, width) {\r\n      var c, w = 0;\r\n      if (self.ellipsisCache[text] && self.ellipsisCache[text][width]) {\r\n        return self.ellipsisCache[text][width];\r\n      }\r\n      //TODO Add ellipsis back when there is a fast way to do it\r\n      w = self.ctx.measureText(text).width;\r\n      self.ellipsisCache[text] = self.ellipsisCache[text] || {};\r\n      c = { value: text, width: w };\r\n      self.ellipsisCache[text][width] = c;\r\n      return c;\r\n    }\r\n    function wrapText(cell, splitChar) {\r\n      if (!cell.formattedValue) {\r\n        return { lines: [{ width: 0, value: '' }], width: 0, height: cell.calculatedLineHeight };\r\n      }\r\n      var max = 0,\r\n        n = '\\n',\r\n        x,\r\n        word,\r\n        words = cell.formattedValue.split(splitChar),\r\n        textHeight = cell.calculatedLineHeight,\r\n        lines = [],\r\n        out = [],\r\n        wrap = self.style.cellWhiteSpace !== 'nowrap',\r\n        elWidth,\r\n        et = self.attributes.ellipsisText,\r\n        elClipLength,\r\n        plWidth,\r\n        clippedVal,\r\n        ogWordWidth,\r\n        previousLine,\r\n        line = {\r\n          width: 0,\r\n          value: ''\r\n        },\r\n        cHeight = wrap ? cell.paddedHeight : cell.calculatedLineHeight;\r\n      lines.push(line);\r\n      elWidth = self.ctx.measureText(' ' + et).width;\r\n      for (x = 0; x < words.length; x += 1) {\r\n        word = words[x];\r\n        var measure = self.ctx.measureText(word + splitChar);\r\n        if (line.width + measure.width + elWidth < cell.paddedWidth) {\r\n          line.value += word + splitChar;\r\n          line.width += measure.width;\r\n          continue;\r\n        }\r\n        // if there is a hyphenated word that is too long\r\n        // split it and add the split set to the array\r\n        // then back up and re-read new split set\r\n        // this behavior seems right, it might not be\r\n        if (/\\w-\\w/.test(word) && cell.paddedWidth < measure.width) {\r\n          words.splice(x, 1, word.split('-')[0] + '-', word.split('-')[1]);\r\n          x -= 1;\r\n          continue;\r\n        }\r\n        line = {\r\n          width: measure.width,\r\n          value: word + splitChar\r\n        };\r\n        if (x === 0) {\r\n          lines = [];\r\n          lines.push(line);\r\n        }\r\n        textHeight += cell.calculatedLineHeight;\r\n        if (textHeight > cHeight) {\r\n          if (lines.length === 0) { break; }\r\n          elClipLength = 1;\r\n          previousLine = lines[lines.length - 1];\r\n          if (previousLine.width < cell.paddedWidth && words.length === 1) { break; }\r\n          clippedVal = previousLine.value + word;\r\n          plWidth = self.ctx.measureText(clippedVal + et).width;\r\n          var originText = clippedVal;\r\n          if (plWidth > cell.paddedWidth) {\r\n            var stepLength = parseInt(clippedVal.length / 2);\r\n            var direction = -1;\r\n            while (stepLength > 0) {\r\n              clippedVal = originText.substr(0, stepLength * direction + clippedVal.length);\r\n              plWidth = self.ctx.measureText(clippedVal + et).width;\r\n              direction = plWidth > cell.paddedWidth ? -1 : 1;\r\n              stepLength = parseInt(stepLength / 2);\r\n            }\r\n          }\r\n          clippedVal = clippedVal + (originText.length != clippedVal.length ? et : '');\r\n          previousLine.value = clippedVal;\r\n          previousLine.width = plWidth;\r\n          break;\r\n        }\r\n        if (x > 0) {\r\n          lines.push(line);\r\n        }\r\n      }\r\n      return {\r\n        lines: lines,\r\n        width: max,\r\n        height: cell.calculatedLineHeight * lines.length\r\n      }\r\n    }\r\n    function drawText(cell) {\r\n      var ll = cell.text.lines.length,\r\n        h = (cell.fontHeight * cell.lineHeight),\r\n        x,\r\n        line,\r\n        wrap = self.style.cellWhiteSpace !== 'nowrap',\r\n        textHeight = 0;\r\n      for (x = 0; x < cell.text.lines.length; x += 1) {\r\n        line = cell.text.lines[x];\r\n        var vPos = Math.max((cell.height - (wrap ? cell.text.height : cell.calculatedLineHeight)) * 0.5, 0) + h,\r\n          hPos = cell.paddingLeft + cell.treeArrowWidth + cell.orderByArrowWidth;\r\n        if (cell.horizontalAlignment === 'right') {\r\n          hPos = cell.paddingLeft + cell.paddedWidth - line.width;\r\n        } else if (cell.horizontalAlignment === 'center') {\r\n          hPos = cell.paddingLeft + ((cell.paddedWidth + cell.paddingRight) / 2) - (line.width / 2);\r\n        }\r\n        if (cell.verticalAlignment === 'top') {\r\n          vPos = cell.calculatedLineHeight;\r\n        } else if (cell.verticalAlignment === 'bottom') {\r\n          vPos = cell.height - cell.paddingBottom - cell.text.height;\r\n        }\r\n        line.height = h + cell.lineSpacing;\r\n        line.offsetLeft = hPos;\r\n        line.offsetTop = vPos;\r\n        line.x = cell.x + hPos;\r\n        line.y = cell.y + textHeight + vPos;\r\n        textHeight += line.height;\r\n        fillText(line.value, line.x, line.y);\r\n      }\r\n      if (self.attributes.debug && cell.active) {\r\n        requestAnimationFrame(function () {\r\n          self.ctx.font = self.style.debugFont;\r\n          self.ctx.fillStyle = self.style.debugColor;\r\n          fillText(JSON.stringify({\r\n            x: cell.x,\r\n            y: cell.y,\r\n            h: cell.height,\r\n            w: cell.width,\r\n            pw: cell.paddedWidth,\r\n            idx: cell.columnIndex,\r\n            idx_ord: cell.sortColumnIndex\r\n          }, null, '\\t'),\r\n            cell.x + 14, cell.y + 14);\r\n          fillText(JSON.stringify(cell.text.lines.map(function (l) { return { w: l.width, v: l.value.length }; }), null, '\\t'),\r\n            cell.x + 14, cell.y + 30);\r\n        });\r\n      }\r\n    }\r\n    function getFrozenColumnsWidth() {\r\n      var w = 0,\r\n        s = self.getSchema(),\r\n        x = 0,\r\n        n = Math.min(self.frozenColumn, s.length),\r\n        column;\r\n      hiddenFrozenColumnCount = 0;\r\n      while (x < n) {\r\n        column = s[x];\r\n        if (column.hidden) {\r\n          hiddenFrozenColumnCount += 1;\r\n        } else {\r\n          w += self.getColummnWidth(x);\r\n        }\r\n        x += 1;\r\n      }\r\n      return w;\r\n    }\r\n    /**\r\n     * Redraws the grid. No matter what the change, this is the only method required to refresh everything.\r\n     * @memberof canvasDatagrid\r\n     * @name draw\r\n     * @method\r\n     */\r\n    // r = literal row index\r\n    // rd = row data array\r\n    // i = user order index\r\n    // o = literal data index\r\n    // y = y drawing cursor\r\n    // x = x drawing cursor\r\n    // s = visible schema array\r\n    // cx = current x drawing cursor sub calculation var\r\n    // cy = current y drawing cursor sub calculation var\r\n    // a = static cell (like corner cell)\r\n    // p = perf counter\r\n    // l = data length\r\n    // u = current cell\r\n    // h = current height\r\n    // w = current width\r\n    self.draw = function (internal) {\r\n      if (self.dispatchEvent('beforedraw', {})) { return; }\r\n      if (!self.isChildGrid && (!self.height || !self.width)) {\r\n        return;\r\n      }\r\n      if (self.isChildGrid && internal) {\r\n        requestAnimationFrame(self.parentGrid.draw);\r\n        return;\r\n      }\r\n      if (self.intf.visible === false) {\r\n        return;\r\n      }\r\n      // initial values\r\n      var checkScrollHeight, rowHeaderCell, p, cx, cy, treeGrid, rowOpen,\r\n        rowHeight, cornerCell, y, x, c, h, w, s, r, rd, aCell,\r\n        data = (self.data || []),\r\n        bc = self.style.gridBorderCollapse === 'collapse',\r\n        selectionBorders = [],\r\n        moveBorders = [],\r\n        selectionHandles = [],\r\n        rowHeaders = [],\r\n        l = data.length,\r\n        u = self.currentCell || {},\r\n        columnHeaderCellHeight = self.getColumnHeaderCellHeight(),\r\n        rowHeaderCellWidth = self.getRowHeaderCellWidth(),\r\n        cellHeight = self.style.cellHeight;\r\n      drawCount += 1;\r\n      p = performance.now();\r\n      self.visibleRowHeights = [];\r\n      // if data length has changed, there is no way to know\r\n      if (data.length > self.orders.rows.length) {\r\n        self.createRowOrders();\r\n      }\r\n      function drawScrollBars() {\r\n        var drawCorner,\r\n          en = self.scrollBox.entities,\r\n          m = (self.style.scrollBarBoxMargin * 2);\r\n        self.ctx.strokeStyle = self.style.scrollBarBorderColor;\r\n        self.ctx.lineWidth = self.style.scrollBarBorderWidth;\r\n        en.horizontalBox.x = rowHeaderCellWidth + self.style.scrollBarBoxMargin\r\n          + ((en.horizontalBar.width - self.scrollBox.scrollBoxWidth)\r\n            * (self.scrollBox.scrollLeft / self.scrollBox.scrollWidth));\r\n        en.verticalBox.y = columnHeaderCellHeight + self.style.scrollBarBoxMargin\r\n          + ((en.verticalBar.height - self.scrollBox.scrollBoxHeight)\r\n            * (self.scrollBox.scrollTop / self.scrollBox.scrollHeight));\r\n        if (self.scrollBox.horizontalBarVisible) {\r\n          self.ctx.fillStyle = self.style.scrollBarBackgroundColor;\r\n          fillRect(en.horizontalBar.x, en.horizontalBar.y, en.horizontalBar.width + m, en.horizontalBar.height);\r\n          strokeRect(en.horizontalBar.x, en.horizontalBar.y, en.horizontalBar.width + m, en.horizontalBar.height);\r\n          self.ctx.fillStyle = self.style.scrollBarBoxColor;\r\n          if (self.scrollBox.horizontalBoxVisible) {\r\n            if (/horizontal/.test(u.context)) {\r\n              self.ctx.fillStyle = self.style.scrollBarActiveColor;\r\n            }\r\n            radiusRect(en.horizontalBox.x, en.horizontalBox.y,\r\n              en.horizontalBox.width, en.horizontalBox.height, self.style.scrollBarBoxBorderRadius);\r\n            self.ctx.stroke();\r\n            self.ctx.fill();\r\n          }\r\n          drawCorner = true;\r\n          self.visibleCells.unshift(en.horizontalBar);\r\n          self.visibleCells.unshift(en.horizontalBox);\r\n        }\r\n        if (self.scrollBox.verticalBarVisible) {\r\n          self.ctx.fillStyle = self.style.scrollBarBackgroundColor;\r\n          fillRect(en.verticalBar.x, en.verticalBar.y, en.verticalBar.width, en.verticalBar.height + m);\r\n          strokeRect(en.verticalBar.x, en.verticalBar.y, en.verticalBar.width, en.verticalBar.height + m);\r\n          if (self.scrollBox.verticalBoxVisible) {\r\n            self.ctx.fillStyle = self.style.scrollBarBoxColor;\r\n            if (/vertical/.test(u.context)) {\r\n              self.ctx.fillStyle = self.style.scrollBarActiveColor;\r\n            }\r\n            radiusRect(en.verticalBox.x, en.verticalBox.y, en.verticalBox.width,\r\n              en.verticalBox.height, self.style.scrollBarBoxBorderRadius);\r\n            self.ctx.stroke();\r\n            self.ctx.fill();\r\n          }\r\n          drawCorner = true;\r\n          self.visibleCells.unshift(en.verticalBar);\r\n          self.visibleCells.unshift(en.verticalBox);\r\n        }\r\n        if (drawCorner) {\r\n          //corner\r\n          self.ctx.strokeStyle = self.style.scrollBarCornerBorderColor;\r\n          self.ctx.fillStyle = self.style.scrollBarCornerBackgroundColor;\r\n          radiusRect(en.corner.x, en.corner.y, en.corner.width, en.corner.height, 0);\r\n          self.ctx.stroke();\r\n          self.ctx.fill();\r\n          self.visibleCells.unshift(en.corner);\r\n        }\r\n      }\r\n      function createHandlesOverlayArray(cell) {\r\n        if (self.attributes.allowMovingSelection || self.mobile) {\r\n          if (cell.selectionBorderTop && cell.selectionBorderRight && self.mobile) {\r\n            selectionHandles.push([cell, 'tr']);\r\n            cell.selectionHandle = 'tr';\r\n          }\r\n          if (cell.selectionBorderTop && cell.selectionBorderLeft && self.mobile) {\r\n            selectionHandles.push([cell, 'tl']);\r\n            cell.selectionHandle = 'tl';\r\n          }\r\n          if (cell.selectionBorderBottom && cell.selectionBorderLeft && self.mobile) {\r\n            selectionHandles.push([cell, 'bl']);\r\n            cell.selectionHandle = 'bl';\r\n          }\r\n          if (cell.selectionBorderBottom && cell.selectionBorderRight\r\n            && (self.attributes.selectionHandleBehavior !== 'none' || self.mobile)) {\r\n            selectionHandles.push([cell, 'br']);\r\n            cell.selectionHandle = 'br';\r\n          }\r\n        }\r\n      }\r\n      function createBorderOverlayArray(cell, drawArray, propPrefix, offsetPoint) {\r\n        offsetPoint = offsetPoint || { x: 0, y: 0 };\r\n        cell.selectionBorder = '';\r\n        if (!cell.isRowHeader\r\n          && self.selections[cell.rowIndex + -offsetPoint.y]\r\n          && self.selections[cell.rowIndex + -offsetPoint.y].indexOf(cell.columnIndex + -offsetPoint.x) !== -1) {\r\n          if ((!self.selections[cell.rowIndex - 1 + -offsetPoint.y]\r\n            || self.selections[cell.rowIndex - 1 + -offsetPoint.y].indexOf(cell.columnIndex + -offsetPoint.x) === -1\r\n            || cell.rowIndex === 0)\r\n            && !cell.isHeader) {\r\n            drawArray.push([cell, 't']);\r\n            cell[propPrefix + 'BorderTop'] = true;\r\n            cell[propPrefix + 'Border'] += 't';\r\n          }\r\n          if (!self.selections[cell.rowIndex + 1 + -offsetPoint.y]\r\n            || self.selections[cell.rowIndex + 1 + -offsetPoint.y].indexOf(cell.columnIndex + -offsetPoint.x) === -1) {\r\n            drawArray.push([cell, 'b']);\r\n            cell[propPrefix + 'BorderBottom'] = true;\r\n            cell[propPrefix + 'Border'] += 'b';\r\n          }\r\n          if (!self.selections[cell.rowIndex + -offsetPoint.y] || cell.columnIndex === 0\r\n            || self.selections[cell.rowIndex + -offsetPoint.y].indexOf(cell.columnIndex - 1 + -offsetPoint.x) === -1) {\r\n            drawArray.push([cell, 'l']);\r\n            cell[propPrefix + 'BorderLeft'] = true;\r\n            cell[propPrefix + 'Border'] += 'l';\r\n          }\r\n          if (!self.selections[cell.rowIndex + -offsetPoint.y] || cell.columnIndex === s.length\r\n            || self.selections[cell.rowIndex + -offsetPoint.y].indexOf(cell.columnIndex + 1 + -offsetPoint.x) === -1) {\r\n            drawArray.push([cell, 'r']);\r\n            cell[propPrefix + 'BorderRight'] = true;\r\n            cell[propPrefix + 'Border'] += 'r';\r\n          }\r\n        }\r\n      }\r\n      function drawCell(d, rowOrderIndex, rowIndex) {\r\n        return function drawEach(header, headerIndex, columnOrderIndex) {\r\n          if (header.hidden) { return 0; }\r\n          var cellStyle = header.style || 'cell',\r\n            cellGridAttributes,\r\n            cell,\r\n            isHeader = /HeaderCell/.test(cellStyle),\r\n            isCorner = /cornerCell/.test(cellStyle),\r\n            isRowHeader = 'rowHeaderCell' === cellStyle,\r\n            isColumnHeader = 'columnHeaderCell' === cellStyle,\r\n            selected = self.selections[rowOrderIndex] && self.selections[rowOrderIndex].indexOf(columnOrderIndex) !== -1,\r\n            hovered = self.hovers.rowIndex === rowOrderIndex && self.hovers.columnIndex === columnOrderIndex,\r\n            active = self.activeCell.rowIndex === rowOrderIndex && self.activeCell.columnIndex === columnOrderIndex,\r\n            isColumnHeaderCellCap = cellStyle === 'columnHeaderCellCap',\r\n            rawValue = d ? d[header.name] : undefined,\r\n            isGrid = header.type === 'canvas-datagrid',\r\n            activeHeader = (self.orders.rows[self.activeCell.rowIndex] === rowOrderIndex\r\n              || self.orders.columns[self.activeCell.columnIndex] === headerIndex)\r\n              && (columnOrderIndex === -1 || rowOrderIndex === -1)\r\n              ? (isRowHeader ? 'activeRowHeaderCell' : 'activeColumnHeaderCell') : false,\r\n            val,\r\n            f = self.formatters[header.type || 'string'],\r\n            orderByArrowSize = 0,\r\n            treeArrowSize = 0,\r\n            cellWidth = self.sizes.columns[headerIndex] || header.width,\r\n            ev = {\r\n              value: rawValue,\r\n              row: d,\r\n              header: header\r\n            };\r\n          if (isColumnHeaderCellCap) {\r\n            cellWidth = w - x;\r\n          }\r\n          // if no data or schema are defined, a width is provided to the stub column\r\n          if (cellWidth === undefined) {\r\n            cellWidth = self.style.cellWidth;\r\n          }\r\n          cellWidth = cellWidth * self.scale;\r\n          if (x + cellWidth + self.style.cellBorderWidth < 0) {\r\n            x += cellWidth + self.style.cellBorderWidth;\r\n          }\r\n          if (active && cellStyle !== 'cornerCell') {\r\n            cellStyle = 'activeCell';\r\n          }\r\n          if (self.visibleRows.indexOf(rowIndex) === -1 && !isHeader) {\r\n            self.visibleRows.push(rowIndex);\r\n          }\r\n          val = self.dispatchEvent('formatcellvalue', ev);\r\n          cx = x;\r\n          cy = y;\r\n          if (cellStyle === 'cornerCell') {\r\n            cx = 0;\r\n            cy = 0;\r\n          } else if (isRowHeader) {\r\n            cx = 0;\r\n          } else if (isHeader) {\r\n            cy = 0;\r\n          }\r\n          cell = {\r\n            type: isGrid ? 'canvas-datagrid-cell' : header.type,\r\n            style: cellStyle,\r\n            nodeType: 'canvas-datagrid-cell',\r\n            x: cx,\r\n            y: cy,\r\n            fontHeight: (self.style[cellStyle + 'FontHeight'] || 0) * self.scale,\r\n            horizontalAlignment: self.style[cellStyle + 'HorizontalAlignment'],\r\n            verticalAlignment: self.style[cellStyle + 'VerticalAlignment'],\r\n            paddingLeft: (self.style[cellStyle + 'PaddingLeft'] || 0) * self.scale,\r\n            paddingTop: (self.style[cellStyle + 'PaddingTop'] || 0) * self.scale,\r\n            paddingRight: (self.style[cellStyle + 'PaddingRight'] || 0) * self.scale,\r\n            paddingBottom: (self.style[cellStyle + 'PaddingBottom'] || 0) * self.scale,\r\n            whiteSpace: self.style.cellWhiteSpace,\r\n            lineHeight: self.style.cellLineHeight,\r\n            lineSpacing: self.style.cellLineSpacing,\r\n            offsetTop: self.canvasOffsetTop + cy,\r\n            offsetLeft: self.canvasOffsetLeft + cx,\r\n            scrollTop: self.scrollBox.scrollTop,\r\n            scrollLeft: self.scrollBox.scrollLeft,\r\n            active: active || activeHeader,\r\n            hovered: hovered,\r\n            selected: selected,\r\n            width: cellWidth,\r\n            height: cellHeight,\r\n            offsetWidth: cellWidth,\r\n            offsetHeight: cellHeight,\r\n            parentNode: self.intf.parentNode,\r\n            offsetParent: self.intf.parentNode,\r\n            data: d,\r\n            isCorner: isCorner,\r\n            isHeader: isHeader,\r\n            isColumnHeader: isColumnHeader,\r\n            isColumnHeaderCellCap: isColumnHeaderCellCap,\r\n            isRowHeader: isRowHeader,\r\n            rowOpen: rowOpen,\r\n            header: header,\r\n            columnIndex: columnOrderIndex,\r\n            rowIndex: rowOrderIndex,\r\n            sortColumnIndex: headerIndex,\r\n            sortRowIndex: rowIndex,\r\n            isGrid: isGrid,\r\n            isNormal: !isGrid && !isCorner && !isHeader,\r\n            gridId: (self.attributes.name || '') + rowIndex + ':' + headerIndex,\r\n            parentGrid: self.intf,\r\n            innerHTML: '',\r\n            activeHeader: activeHeader,\r\n            value: isHeader && !isRowHeader ? (header.title || header.name) : rawValue\r\n          };\r\n          cell.calculatedLineHeight = (cell.fontHeight * cell.lineHeight) + cell.lineSpacing;\r\n          cell.paddedWidth = cell.width - cell.paddingRight - cell.paddingLeft;\r\n          cell.paddedHeight = cell.height - cell.paddingTop - cell.paddingBottom;\r\n          ev.cell = cell;\r\n          cell.userHeight = cell.isHeader ? self.sizes.rows[-1] : rowHeight;\r\n          cell.userWidth = cell.isHeader ? self.sizes.columns.cornerCell : self.sizes.columns[headerIndex];\r\n          self.visibleCells.unshift(cell);\r\n          if (self.dispatchEvent('beforerendercell', ev)) { return; }\r\n          self.ctx.fillStyle = self.style[cellStyle + 'BackgroundColor'];\r\n          self.ctx.strokeStyle = self.style[cellStyle + 'BorderColor'];\r\n          self.ctx.lineWidth = self.style[cellStyle + 'BorderWidth'];\r\n          if (hovered) {\r\n            self.ctx.fillStyle = self.style[cellStyle + 'HoverBackgroundColor'];\r\n            self.ctx.strokeStyle = self.style[cellStyle + 'HoverBorderColor'];\r\n          }\r\n          if (selected) {\r\n            self.ctx.fillStyle = self.style[cellStyle + 'SelectedBackgroundColor'];\r\n            self.ctx.strokeStyle = self.style[cellStyle + 'SelectedBorderColor'];\r\n          }\r\n          if (activeHeader) {\r\n            self.ctx.fillStyle = self.style[activeHeader + 'BackgroundColor'];\r\n          }\r\n          self.dispatchEvent('rendercell', ev);\r\n          if (cell.isGrid) {\r\n            if (cell.height !== rowHeight) {\r\n              cell.height = rowHeight || self.style.cellHeightWithChildGrid;\r\n              checkScrollHeight = true;\r\n            }\r\n            cell.width = self.sizes.columns[headerIndex] || self.style.cellWidthWithChildGrid;\r\n          }\r\n          if (rowOpen && !cell.isRowHeader) {\r\n            cell.height = self.sizes.rows[rowIndex] || self.style.cellHeight;\r\n          }\r\n          if (!cell.isGrid) {\r\n            fillRect(cx, cy, cell.width, cell.height);\r\n            strokeRect(cx, cy, cell.width, cell.height);\r\n          }\r\n          self.ctx.save();\r\n          radiusRect(cell.x, cell.y, cell.width, cell.height, 0);\r\n          self.ctx.clip();\r\n          self.dispatchEvent('afterrendercell', ev);\r\n          if (cell.height !== cellHeight && !(rowOpen && !cell.isRowHeader)) {\r\n            self.sizes.rows[isHeader ? -1 : rowIndex] = cell.height;\r\n            checkScrollHeight = true;\r\n          }\r\n          if (cell.width !== cellWidth) {\r\n            self.sizes.columns[headerIndex] = cell.width;\r\n            checkScrollHeight = true;\r\n          }\r\n          if (isRowHeader && self.attributes.tree) {\r\n            if (!self.dispatchEvent('rendertreearrow', ev)) {\r\n              treeArrowSize = drawTreeArrow(cell, self.style[cellStyle + 'PaddingLeft'], cy, 0);\r\n            }\r\n          }\r\n          if ((self.attributes.showRowNumbers && isRowHeader)\r\n            || !isRowHeader) {\r\n            if (cell.isGrid && !self.dispatchEvent('beforerendercellgrid', ev)) {\r\n              if (!self.childGrids[cell.gridId]) {\r\n                // HACK: this only allows setting of the child grids styles if data is set _after_\r\n                // this is less than desirable.  An interface needs to be made to effect the\r\n                // style of all cell grids.  One for individual grids already exists.\r\n                cellGridAttributes = self.cellGridAttributes;\r\n                cellGridAttributes.name = self.attributes.saveAppearance ? cell.gridId : undefined;\r\n                cellGridAttributes.component = false;\r\n                cellGridAttributes.parentNode = cell;\r\n                cellGridAttributes.data = rawValue;\r\n                ev.cellGridAttributes = cellGridAttributes;\r\n                if (self.dispatchEvent('beforecreatecellgrid', ev)) { return; }\r\n                self.childGrids[cell.gridId] = self.createGrid(cellGridAttributes);\r\n                self.sizes.rows[rowIndex]\r\n                  = self.sizes.rows[rowIndex] || self.style.cellGridHeight;\r\n                checkScrollHeight = true;\r\n              }\r\n              cell.grid = self.childGrids[cell.gridId];\r\n              cell.grid.parentNode = cell;\r\n              cell.grid.visible = true;\r\n              cell.grid.draw();\r\n              self.dispatchEvent('rendercellgrid', ev);\r\n            } else if (!cell.isGrid) {\r\n              if (self.childGrids[cell.gridId]) {\r\n                self.childGrids[cell.gridId].parentNode.offsetHeight = 0;\r\n              }\r\n              if (isHeader && self.orderBy === header.name) {\r\n                if (!self.dispatchEvent('renderorderbyarrow', ev)) {\r\n                  orderByArrowSize = drawOrderByArrow(cx + self.style[cellStyle + 'PaddingLeft'], 0);\r\n                }\r\n              }\r\n              self.ctx.fillStyle = self.style[cellStyle + 'Color'];\r\n              if (hovered) {\r\n                self.ctx.fillStyle = self.style[cellStyle + 'HoverColor'];\r\n              }\r\n              if (selected) {\r\n                self.ctx.fillStyle = self.style[cellStyle + 'SelectedColor'];\r\n              }\r\n              if (activeHeader) {\r\n                self.ctx.fillStyle = self.style[activeHeader + 'Color'];\r\n              }\r\n              cell.treeArrowWidth = treeArrowSize;\r\n              cell.orderByArrowWidth = orderByArrowSize;\r\n              // create text ref to see if height needs to expand\r\n              val = val !== undefined ? val : f\r\n                ? f(ev) : '';\r\n              if (val === undefined && !f) {\r\n                val = '';\r\n                console.warn('canvas-datagrid: Unknown format '\r\n                  + header.type + ' add a cellFormater');\r\n              }\r\n              cell.formattedValue = ((val !== undefined && val !== null) ? val : '').toString();\r\n              if (self.columnFilters && self.columnFilters[val] !== undefined && isHeader) {\r\n                cell.formattedValue = self.attributes.filterTextPrefix + val;\r\n              }\r\n              self.ctx.font = (self.style[cellStyle + 'FontHeight'] * self.scale) + 'px ' + self.style[cellStyle + 'FontName'];\r\n              if (!self.dispatchEvent('formattext', ev)) {\r\n                cell.text = wrapText(cell, ' ');\r\n              }\r\n              if (!self.dispatchEvent('rendertext', ev)) {\r\n                if (cell.innerHTML || header.type === 'html') {\r\n                  drawHtml(cell);\r\n                } else {\r\n                  drawText(cell);\r\n                }\r\n              }\r\n            }\r\n          }\r\n          if (active) {\r\n            aCell = cell;\r\n          }\r\n          createBorderOverlayArray(cell, selectionBorders, 'selection');\r\n          // createBorderOverlayArray calculates data for createHandlesOverlayArray so it must go 2nd\r\n          createHandlesOverlayArray(cell);\r\n          if (self.movingSelection) {\r\n            createBorderOverlayArray(cell, moveBorders, 'move', self.moveOffset);\r\n          }\r\n          self.ctx.restore();\r\n          x += cell.width + (bc ? 0 : self.style.cellBorderWidth);\r\n          return cell.width;\r\n        };\r\n      }\r\n      function drawRowHeader(rowData, index, rowOrderIndex) {\r\n        var a, i;\r\n        if (self.attributes.showRowHeaders) {\r\n          x = 0;\r\n          i = index + 1;\r\n          rowHeaderCell = { 'rowHeaderCell': i };\r\n          a = {\r\n            name: 'rowHeaderCell',\r\n            width: self.sizes.columns[-1] || self.style.rowHeaderCellWidth,\r\n            style: 'rowHeaderCell',\r\n            type: 'string',\r\n            data: i,\r\n            index: -1\r\n          };\r\n          rowOpen = self.openChildren[index];\r\n          drawCell(rowHeaderCell, index, rowOrderIndex)(a, -1, -1);\r\n        }\r\n      }\r\n      function drawHeaders() {\r\n        var d, g = s.length, i, o, columnHeaderCell, header, nonFrozenHeaderWidth;\r\n        function drawHeaderColumnRange(start, end) {\r\n          end = Math.min(end, g);\r\n          for (o = start; o < end; o += 1) {\r\n            i = self.orders.columns[o];\r\n            header = s[i];\r\n            if (!header.hidden) {\r\n              d = {\r\n                title: header.title,\r\n                name: header.name,\r\n                width: header.width || self.style.cellWidth,\r\n                style: 'columnHeaderCell',\r\n                type: 'string',\r\n                index: o,\r\n                order: i\r\n              };\r\n              columnHeaderCell = { 'columnHeaderCell': header.title || header.name };\r\n              x += drawCell(columnHeaderCell, -1, -1)(d, i, o);\r\n              if (x > self.width + self.scrollBox.scrollLeft) {\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n        rowHeaders.forEach(function (rArgs, rhIndex) {\r\n          y = rArgs[3];\r\n          cellHeight = rArgs[4];\r\n          if (rhIndex === self.frozenRow) {\r\n            self.ctx.save();\r\n            radiusRect(0, self.lastFrozenRowPixel, self.width, self.height - self.lastFrozenRowPixel, 0);\r\n            self.ctx.clip();\r\n          }\r\n          drawRowHeader(rArgs[0], rArgs[1], rArgs[2]);\r\n        });\r\n        self.ctx.restore();\r\n        if (self.attributes.showColumnHeaders) {\r\n          x = -self.scrollBox.scrollLeft + self.scrollPixelLeft + self.style.columnHeaderCellBorderWidth;\r\n          if (self.attributes.showRowHeaders) {\r\n            x += rowHeaderCellWidth;\r\n          }\r\n          y = 0;\r\n          // cell height might have changed during drawing\r\n          cellHeight = self.getColumnHeaderCellHeight();\r\n          drawHeaderColumnRange(self.scrollIndexLeft, g);\r\n          nonFrozenHeaderWidth = x;\r\n          x = self.style.columnHeaderCellBorderWidth;\r\n          if (self.attributes.showRowHeaders) {\r\n            x += rowHeaderCellWidth;\r\n          }\r\n          drawHeaderColumnRange(0, self.frozenColumn);\r\n          // fill in the space right of the headers\r\n          x = nonFrozenHeaderWidth;\r\n          if (x < w) {\r\n            c = {\r\n              name: '',\r\n              width: self.style.scrollBarWidth,\r\n              style: 'columnHeaderCellCap',\r\n              isColumnHeaderCell: true,\r\n              isColumnHeaderCellCap: true,\r\n              type: 'string',\r\n              index: s.length\r\n            };\r\n            drawCell({ endCap: '' }, -1, -1)(c, -1, -1);\r\n          }\r\n          // fill in the space right of the headers\r\n          if (self.attributes.showRowHeaders) {\r\n            cornerCell = { 'cornerCell': '' };\r\n            x = 0;\r\n            c = {\r\n              name: 'cornerCell',\r\n              width: self.style.rowHeaderCellWidth,\r\n              style: 'cornerCell',\r\n              type: 'string',\r\n              index: -1\r\n            };\r\n            drawCell(cornerCell, -1, -1)(c, -1, -1);\r\n          }\r\n        }\r\n      }\r\n      function drawRow(r, d) {\r\n        var i, treeHeight, rowSansTreeHeight, o, g = s.length;\r\n        if (y - (cellHeight * 2) > h) {\r\n          return false;\r\n        }\r\n        rd = data[r];\r\n        rowOpen = self.openChildren[r];\r\n        rowSansTreeHeight = (self.sizes.rows[r] || self.style.cellHeight) * self.scale;\r\n        treeHeight = (rowOpen ? self.sizes.trees[r] : 0) * self.scale;\r\n        rowHeight = (rowSansTreeHeight + treeHeight);\r\n        if (y < -rowHeight) {\r\n          return false;\r\n        }\r\n        if (self.attributes.showRowHeaders) {\r\n          x += rowHeaderCellWidth;\r\n        }\r\n        cellHeight = rowHeight;\r\n        //draw normal columns\r\n        for (o = (self.scrollIndexLeft); o < g; o += 1) {\r\n          i = self.orders.columns[o];\r\n          x += drawCell(rd, r, d)(s[i], i, o);\r\n          if (x > self.width) {\r\n            self.scrollIndexRight = o;\r\n            self.scrollPixelRight = x;\r\n            break;\r\n          }\r\n        }\r\n        //draw frozen columns\r\n        x = 0;\r\n        if (self.attributes.showRowHeaders) {\r\n          x += rowHeaderCellWidth;\r\n        }\r\n        for (o = 0; o < self.frozenColumn; o += 1) {\r\n          i = self.orders.columns[o];\r\n          x += drawCell(rd, r, d)(s[i], i, o);\r\n          if (x > self.width) {\r\n            break;\r\n          }\r\n        }\r\n        self.lastFrozenColumnPixel = x;\r\n        // cell height might have changed during drawing\r\n        cellHeight = rowHeight;\r\n        x = -self.scrollBox.scrollLeft + self.scrollPixelLeft + self.style.cellBorderWidth;\r\n        // don't draw a tree for the new row\r\n        treeGrid = self.childGrids[r];\r\n        if (r !== data.length && rowOpen) {\r\n          treeGrid.visible = true;\r\n          treeGrid.parentNode = {\r\n            offsetTop: y + rowSansTreeHeight + self.canvasOffsetTop,\r\n            offsetLeft: rowHeaderCellWidth - 1 + self.canvasOffsetLeft,\r\n            offsetHeight: treeHeight,\r\n            offsetWidth: self.width - rowHeaderCellWidth - self.style.scrollBarWidth - 1,\r\n            offsetParent: self.intf.parentNode,\r\n            parentNode: self.intf.parentNode,\r\n            style: self.style,\r\n            nodeType: 'canvas-datagrid-tree',\r\n            scrollTop: self.scrollBox.scrollTop,\r\n            scrollLeft: self.scrollBox.scrollLeft,\r\n            rowIndex: r\r\n          };\r\n          self.visibleCells.unshift({\r\n            rowIndex: r,\r\n            columnIndex: 0,\r\n            y: treeGrid.parentNode.offsetTop,\r\n            x: treeGrid.parentNode.offsetLeft,\r\n            height: treeGrid.height,\r\n            width: treeGrid.width,\r\n            style: 'tree-grid',\r\n            type: treeGrid.parentNode.nodeType\r\n          });\r\n          treeGrid.draw();\r\n        } else if (treeGrid) {\r\n          treeGrid.parentNode.offsetHeight = 0;\r\n          delete self.sizes.trees[r];\r\n        }\r\n        rowHeaders.push([rd, r, d, y, rowHeight]);\r\n        self.visibleRowHeights[r] = rowHeight;\r\n        y += cellHeight + (bc ? 0 : self.style.cellBorderWidth);\r\n        return true;\r\n      }\r\n      function initDraw() {\r\n        self.visibleRows = [];\r\n        s = self.getSchema();\r\n        self.visibleCells = [];\r\n        self.canvasOffsetTop = self.isChildGrid ? self.parentNode.offsetTop : 0;\r\n        self.canvasOffsetLeft = self.isChildGrid ? self.parentNode.offsetLeft : 0;\r\n        h = self.height;\r\n        w = self.width;\r\n      }\r\n      function drawBackground() {\r\n        radiusRect(0, 0, w, h, 0);\r\n        self.ctx.clip();\r\n        self.ctx.fillStyle = self.style.gridBackgroundColor;\r\n        fillRect(0, 0, w, h);\r\n      }\r\n      function drawFrozenRows() {\r\n        var n, ln = Math.min(data.length, self.frozenRow);\r\n        x = -self.scrollBox.scrollLeft + self.scrollPixelLeft + self.style.cellBorderWidth;\r\n        y = columnHeaderCellHeight;\r\n        for (r = 0; r < ln; r += 1) {\r\n          n = self.orders.rows[r];\r\n          if (!drawRow(n, r)) {\r\n            break;\r\n          }\r\n        }\r\n        if (self.attributes.allowFreezingRows) {\r\n          // HACK great, another stupid magic number.\r\n          // Background will appear as a 0.5px artifact behind the row freeze bar without this hack\r\n          y += self.style.frozenMarkerBorderWidth + self.style.frozenMarkerWidth - 0.4999999999;\r\n        }\r\n        self.lastFrozenRowPixel = y;\r\n      }\r\n      function drawRows() {\r\n        self.ctx.save();\r\n        if (self.frozenRow > 0) {\r\n          radiusRect(0, self.lastFrozenRowPixel, self.width, self.height - self.lastFrozenRowPixel, 0);\r\n          self.ctx.clip();\r\n        }\r\n        var o, n, i, g = s.length;\r\n        x = -self.scrollBox.scrollLeft + self.scrollPixelLeft + self.style.cellBorderWidth;\r\n        if (!self.attributes.snapToRow) {\r\n          y += -self.scrollBox.scrollTop + self.scrollPixelTop + self.style.cellBorderWidth;\r\n        }\r\n        for (r = self.frozenRow + self.scrollIndexTop; r < l; r += 1) {\r\n          n = self.orders.rows[r];\r\n          self.scrollIndexBottom = r;\r\n          self.scrollPixelBottom = y;\r\n          if (!drawRow(n, r)) {\r\n            break;\r\n          }\r\n        }\r\n        if (self.attributes.showNewRow) {\r\n          if (self.attributes.showRowHeaders) {\r\n            x += rowHeaderCellWidth;\r\n          }\r\n          rowHeight = cellHeight = self.style.cellHeight;\r\n          rowOpen = false;\r\n          for (o = self.scrollIndexLeft; o < g; o += 1) {\r\n            i = self.orders.columns[o];\r\n            x += drawCell(self.newRow, data.length, data.length)(s[i], i, o);\r\n            if (x > self.width + self.scrollBox.scrollLeft) {\r\n              break;\r\n            }\r\n          }\r\n          rowHeaders.push([self.newRow, data.length, data.length, y, rowHeight]);\r\n        }\r\n        self.ctx.restore();\r\n      }\r\n      function drawMoveMarkers() {\r\n        if (!self.movingSelection) { return; }\r\n        self.ctx.lineWidth = self.style.moveOverlayBorderWidth;\r\n        self.ctx.strokeStyle = self.style.moveOverlayBorderColor;\r\n        self.ctx.setLineDash(self.style.moveOverlayBorderSegments);\r\n        moveBorders.forEach(function (c) {\r\n          addBorderLine(c[0], c[1]);\r\n        });\r\n        self.ctx.setLineDash([]);\r\n      }\r\n      function drawReorderMarkers() {\r\n        if (!self.reorderObject) { return; }\r\n        var b = {\r\n          height: self.reorderObject.height,\r\n          width: self.reorderObject.width,\r\n          x: self.reorderObject.x + self.reorderObject.dragOffset.x,\r\n          y: self.reorderObject.y + self.reorderObject.dragOffset.y\r\n        },\r\n          m = {\r\n            width: w,\r\n            height: h,\r\n            x: 0,\r\n            y: 0\r\n          };\r\n        self.ctx.fillStyle = self.style.reorderMarkerBackgroundColor;\r\n        self.ctx.lineWidth = self.style.reorderMarkerBorderWidth;\r\n        self.ctx.strokeStyle = self.style.reorderMarkerBorderColor;\r\n        if (self.dragMode === 'row-reorder') {\r\n          b.width = w;\r\n          b.x = 0;\r\n          m.width = w;\r\n          m.height = self.currentCell.height;\r\n          m.y = self.currentCell.y;\r\n          fillRect(b.x, b.y, b.width, b.height);\r\n          strokeRect(b.x, b.y, b.width, b.height);\r\n          self.ctx.lineWidth = self.style.reorderMarkerIndexBorderWidth;\r\n          self.ctx.strokeStyle = self.style.reorderMarkerIndexBorderColor;\r\n          if (self.currentCell.rowIndex !== self.reorderObject.rowIndex\r\n            && self.currentCell.rowIndex > -1\r\n            && self.currentCell.rowIndex < l) {\r\n            addBorderLine(m, self.reorderTarget.sortRowIndex > self.reorderObject.sortRowIndex ? 'b' : 't');\r\n          }\r\n        } else if (self.dragMode === 'column-reorder' && self.reorderObject) {\r\n          b.height = h;\r\n          b.y = 0;\r\n          m.height = h;\r\n          m.width = self.currentCell.width;\r\n          m.y = 0;\r\n          m.x = self.currentCell.x;\r\n          fillRect(b.x, b.y, b.width, b.height);\r\n          strokeRect(b.x, b.y, b.width, b.height);\r\n          self.ctx.lineWidth = self.style.reorderMarkerIndexBorderWidth;\r\n          self.ctx.strokeStyle = self.style.reorderMarkerIndexBorderColor;\r\n          if (self.currentCell.sortColumnIndex !== self.reorderObject.sortColumnIndex\r\n            && self.currentCell.sortColumnIndex > -1\r\n            && self.currentCell.sortColumnIndex < s.length) {\r\n            addBorderLine(m, self.reorderTarget.columnIndex > self.reorderObject.columnIndex ? 'r' : 'l');\r\n          }\r\n        }\r\n      }\r\n      function drawBorder() {\r\n        self.ctx.lineWidth = self.style.gridBorderWidth;\r\n        self.ctx.strokeStyle = self.style.gridBorderColor;\r\n        strokeRect(0, 0, self.width, self.height);\r\n      }\r\n      function drawSelectionBorders() {\r\n        self.ctx.lineWidth = self.style.selectionOverlayBorderWidth;\r\n        self.ctx.strokeStyle = self.style.selectionOverlayBorderColor;\r\n        function dsb(c) {\r\n          addBorderLine(c[0], c[1]);\r\n        }\r\n        selectionBorders.filter(function (c) {\r\n          return c[0].rowIndex < self.frozenRow && c[0].columnIndex < self.frozenColumn;\r\n        }).forEach(dsb);\r\n        self.ctx.save();\r\n        clipFrozenArea(0);\r\n        selectionBorders.filter(function (c) {\r\n          return c[0].rowIndex >= self.frozenRow && c[0].columnIndex >= self.frozenColumn;\r\n        }).forEach(dsb);\r\n        self.ctx.restore();\r\n        self.ctx.save();\r\n        clipFrozenArea(1);\r\n        selectionBorders.filter(function (c) {\r\n          return c[0].rowIndex >= self.frozenRow && c[0].columnIndex < self.frozenColumn;\r\n        }).forEach(dsb);\r\n        self.ctx.restore();\r\n        self.ctx.save();\r\n        clipFrozenArea(2);\r\n        selectionBorders.filter(function (c) {\r\n          return c[0].rowIndex < self.frozenRow && c[0].columnIndex >= self.frozenColumn;\r\n        }).forEach(dsb);\r\n        self.ctx.restore();\r\n      }\r\n      function drawSelectionHandles() {\r\n        if (self.mobile || self.attributes.allowMovingSelection) {\r\n          self.ctx.lineWidth = self.style.selectionHandleBorderWidth;\r\n          self.ctx.strokeStyle = self.style.selectionHandleBorderColor;\r\n          self.ctx.fillStyle = self.style.selectionHandleColor;\r\n          selectionHandles.forEach(function (c) {\r\n            addselectionHandle(c[0], c[1]);\r\n            var az = self.attributes.touchSelectHandleZone / 2,\r\n              ax = c[0].x + (c[1] === 'tl' || c[1] === 'bl' ? 0 : c[0].width) - az,\r\n              ay = c[0].y + (c[1] === 'bl' || c[1] === 'br' ? c[0].height : 0) - az;\r\n            self.visibleCells.unshift({\r\n              x: ax,\r\n              y: ay,\r\n              height: self.style.selectionHandleSize + az,\r\n              width: self.style.selectionHandleSize + az,\r\n              style: 'selection-handle-' + c[1]\r\n            });\r\n          });\r\n        }\r\n      }\r\n      function drawActiveCell() {\r\n        if (!aCell) { return; }\r\n        self.ctx.save();\r\n        var cl = self.activeCell.columnIndex + 1 > self.frozenColumn || self.activeCell.rowIndex + 1 > self.frozenRow,\r\n          acx = cl ? self.lastFrozenColumnPixel : 0,\r\n          acy = cl ? self.lastFrozenRowPixel : 0,\r\n          acw = cl ? self.width - self.lastFrozenColumnPixel : self.width,\r\n          ach = cl ? self.height - self.lastFrozenRowPixel : self.height;\r\n        radiusRect(acx, acy, acw, ach, 0);\r\n        self.ctx.clip();\r\n        if (self.attributes.selectionMode === 'row') {\r\n          if (self.activeCell && self.activeCell.rowIndex === aCell.rowIndex) {\r\n            self.ctx.lineWidth = self.style.activeCellOverlayBorderWidth;\r\n            self.ctx.strokeStyle = self.style.activeCellOverlayBorderColor;\r\n            strokeRect(0, aCell.y, self.getHeaderWidth() + rowHeaderCellWidth, self.visibleRowHeights[aCell.rowIndex]);\r\n          }\r\n        } else {\r\n          self.ctx.lineWidth = self.style.activeCellOverlayBorderWidth;\r\n          self.ctx.strokeStyle = self.style.activeCellOverlayBorderColor;\r\n          strokeRect(aCell.x, aCell.y, aCell.width, aCell.height);\r\n        }\r\n        self.ctx.restore();\r\n      }\r\n      function drawFrozenMarkers() {\r\n        var my = self.lastFrozenRowPixel - self.style.frozenMarkerWidth,\r\n          mx = self.lastFrozenColumnPixel - self.style.frozenMarkerBorderWidth,\r\n          xHover = self.currentCell && self.currentCell.style === 'frozen-row-marker',\r\n          yHover = self.currentCell && self.currentCell.style === 'frozen-column-marker';\r\n        self.ctx.lineWidth = self.style.frozenMarkerBorderWidth;\r\n        if (self.attributes.allowFreezingColumns) {\r\n          self.ctx.fillStyle = yHover ? self.style.frozenMarkerHoverColor : self.style.frozenMarkerColor;\r\n          self.ctx.strokeStyle = yHover ? self.style.frozenMarkerHoverBorderColor : self.style.frozenMarkerBorderColor;\r\n          fillRect(mx, 0, self.style.frozenMarkerWidth, self.height);\r\n          strokeRect(mx, 0, self.style.frozenMarkerWidth, self.height);\r\n          self.visibleCells.unshift({\r\n            x: mx,\r\n            y: 0,\r\n            height: self.height,\r\n            width: self.style.frozenMarkerWidth + self.style.frozenMarkerBorderWidth,\r\n            style: 'frozen-column-marker'\r\n          });\r\n        }\r\n        if (self.attributes.allowFreezingRows) {\r\n          self.ctx.fillStyle = xHover ? self.style.frozenMarkerHoverColor : self.style.frozenMarkerColor;\r\n          self.ctx.strokeStyle = xHover ? self.style.frozenMarkerHoverBorderColor : self.style.frozenMarkerBorderColor;\r\n          fillRect(0, my, self.width, self.style.frozenMarkerWidth);\r\n          strokeRect(0, my, self.width, self.style.frozenMarkerWidth);\r\n          self.visibleCells.unshift({\r\n            x: 0,\r\n            y: my,\r\n            height: self.style.frozenMarkerWidth + self.style.frozenMarkerBorderWidth,\r\n            width: self.width,\r\n            style: 'frozen-row-marker'\r\n          });\r\n        }\r\n        if (self.freezeMarkerPosition) {\r\n          self.ctx.fillStyle = self.style.frozenMarkerActiveColor;\r\n          self.ctx.strokeStyle = self.style.frozenMarkerActiveBorderColor;\r\n          if (self.dragMode === 'frozen-column-marker') {\r\n            fillRect(self.freezeMarkerPosition.x, 0, self.style.frozenMarkerWidth, self.height);\r\n            strokeRect(self.freezeMarkerPosition.x, 0, self.style.frozenMarkerWidth, self.height);\r\n          } else {\r\n            fillRect(0, self.freezeMarkerPosition.y, self.width, self.style.frozenMarkerWidth);\r\n            strokeRect(0, self.freezeMarkerPosition.y, self.width, self.style.frozenMarkerWidth);\r\n          }\r\n        }\r\n      }\r\n      function drawPerfLines() {\r\n        if (!self.attributes.showPerformance) { return; }\r\n        var pw = 250,\r\n          px = self.width - pw - self.style.scrollBarWidth - (self.style.scrollBarBorderWidth * 2),\r\n          py = columnHeaderCellHeight,\r\n          ph = 100;\r\n        if (scrollDebugCounters.length === 0) { scrollDebugCounters = fillArray(0, perfWindowSize, 1, function () { return [0, 0]; }); }\r\n        if (touchPPSCounters.length === 0) { touchPPSCounters = fillArray(0, perfWindowSize, 1, function () { return [0, 0]; }); }\r\n        if (entityCount.length === 0) { entityCount = fillArray(0, perfWindowSize, 1, 0); }\r\n        self.ctx.lineWidth = 0.5;\r\n        function dpl(name, perfArr, arrIndex, max, color, useAbs, rowIndex) {\r\n          var v;\r\n          drawPerfLine(pw, ph, px, py, perfArr, arrIndex, max, color, useAbs);\r\n          self.ctx.fillStyle = color;\r\n          fillRect(3 + px, py + 9 + (rowIndex * 11), 8, 8);\r\n          self.ctx.fillStyle = self.style.debugPerfChartTextColor;\r\n          v = arrIndex !== undefined ? perfArr[0][arrIndex] : perfArr[0];\r\n          fillText(name + ' ' + (isNaN(v) ? 0 : v).toFixed(3), 14 + px, py + 16 + (rowIndex * 11));\r\n        }\r\n        self.ctx.textAlign = 'left';\r\n        self.ctx.font = self.style.debugFont;\r\n        self.ctx.fillStyle = self.style.debugPerfChartBackground;\r\n        fillRect(px, py, pw, ph);\r\n        [['Scroll Height', scrollDebugCounters, 0, self.scrollBox.scrollHeight, self.style.debugScrollHeightColor, false],\r\n        ['Scroll Width', scrollDebugCounters, 1, self.scrollBox.scrollWidth, self.style.debugScrollWidthColor, false],\r\n        ['Performance', perfCounters, undefined, 200, self.style.debugPerformanceColor, false],\r\n        ['Entities', entityCount, undefined, 1500, self.style.debugEntitiesColor, false],\r\n        ['TouchPPSX', touchPPSCounters, 0, 1000, self.style.debugTouchPPSXColor, true],\r\n        ['TouchPPSY', touchPPSCounters, 1, 1000, self.style.debugTouchPPSYColor, true]\r\n        ].forEach(function (i, index) {\r\n          i.push(index);\r\n          dpl.apply(null, i);\r\n        });\r\n        self.ctx.fillStyle = self.style.debugPerfChartBackground;\r\n        entityCount.pop();\r\n        entityCount.unshift(self.visibleCells.length);\r\n        scrollDebugCounters.pop();\r\n        scrollDebugCounters.unshift([self.scrollBox.scrollTop, self.scrollBox.scrollLeft]);\r\n        touchPPSCounters.pop();\r\n        touchPPSCounters.unshift([self.yPPS, self.xPPS]);\r\n      }\r\n      function drawDebug() {\r\n        self.ctx.save();\r\n        var d;\r\n        if (self.attributes.showPerformance || self.attributes.debug) {\r\n          if (perfCounters.length === 0) { perfCounters = fillArray(0, perfWindowSize, 1, 0); }\r\n          perfCounters.pop();\r\n          perfCounters.unshift(performance.now() - p);\r\n        }\r\n        if (!self.attributes.debug) {\r\n          self.ctx.restore();\r\n          return;\r\n        }\r\n        self.ctx.font = self.style.debugFont;\r\n        d = {};\r\n        d.perf = (perfCounters.reduce(function (a, b) {\r\n          return a + b;\r\n        }, 0) / Math.min(drawCount, perfCounters.length)).toFixed(1);\r\n        d.perfDelta = perfCounters[0].toFixed(1);\r\n        d.frozenColumnsWidth = getFrozenColumnsWidth();\r\n        d.htmlImages = Object.keys(self.htmlImageCache).length;\r\n        d.reorderObject = 'x: ' + (self.reorderObject || { columnIndex: 0 }).columnIndex + ', y: ' + (self.reorderObject || { rowIndex: 0 }).rowIndex;\r\n        d.reorderTarget = 'x: ' + (self.reorderTarget || { columnIndex: 0 }).columnIndex + ', y: ' + (self.reorderTarget || { rowIndex: 0 }).rowIndex;\r\n        d.scale = self.scale;\r\n        d.startScale = self.startScale;\r\n        d.scaleDelta = self.scaleDelta;\r\n        d.zoomDeltaStart = self.zoomDeltaStart;\r\n        d.touchLength = self.touchLength;\r\n        d.touches = 'y0: ' + (self.touchPosition || { y: 0 }).y + ' y1: ' + (self.touchPosition1 || { y: 0 }).y;\r\n        d.scrollBox = self.scrollBox.toString();\r\n        d.scrollIndex = 'x: ' + self.scrollIndexLeft + ', y: ' + self.scrollIndexTop;\r\n        d.scrollPixel = 'x: ' + self.scrollPixelLeft + ', y: ' + self.scrollPixelTop;\r\n        d.canvasOffset = 'x: ' + self.canvasOffsetLeft + ', y: ' + self.canvasOffsetTop;\r\n        d.touchDelta = 'x: ' + self.touchDelta.x + ', y: ' + self.touchDelta.y;\r\n        d.touchAnimateTo = 'x: ' + self.touchAnimateTo.x + ', y: ' + self.touchAnimateTo.y;\r\n        d.scrollAnimation = 'x: ' + self.scrollAnimation.x + ', y: ' + self.scrollAnimation.y;\r\n        d.touchPPS = 'x: ' + self.xPPS + ', y: ' + self.yPPS;\r\n        d.touchPPST = 'x: ' + self.xPPST + ', y: ' + self.yPPST;\r\n        d.touchDuration = self.touchDuration;\r\n        d.pointerLockPosition = self.pointerLockPosition ?\r\n          self.pointerLockPosition.x + ', ' + self.pointerLockPosition.y : '';\r\n        d.size = 'w: ' + self.width + ', h: ' + self.height;\r\n        d.mouse = 'x: ' + self.mouse.x + ', y: ' + self.mouse.y;\r\n        d.touch = !self.touchStart\r\n          ? '' : 'x: ' + self.touchStart.x + ', y: ' + self.touchStart.y;\r\n        d.entities = self.visibleCells.length;\r\n        d.hasFocus = self.hasFocus;\r\n        d.dragMode = self.dragMode;\r\n        if (self.currentCell) {\r\n          d.columnIndex = self.currentCell.columnIndex;\r\n          d.rowIndex = self.currentCell.rowIndex;\r\n          d.sortColumnIndex = self.currentCell.sortColumnIndex;\r\n          d.sortRowIndex = self.currentCell.sortRowIndex;\r\n          d.context = self.currentCell.context;\r\n          d.dragContext = self.currentCell.dragContext;\r\n          d.style = self.currentCell.style;\r\n          d.type = self.currentCell.type;\r\n        }\r\n        self.ctx.textAlign = 'right';\r\n        self.ctx.fillStyle = self.style.debugBackgroundColor;\r\n        fillRect(0, 0, self.width, self.height);\r\n        Object.keys(d).forEach(function (key, index) {\r\n          var m = key + ': ' + d[key],\r\n            lh = 14;\r\n          self.ctx.fillStyle = self.style.debugColor;\r\n          fillText(m, w - 20, (self.attributes.showPerformance ? 140 : 24) + (index * lh));\r\n        });\r\n        self.ctx.restore();\r\n      }\r\n      self.ctx.save();\r\n      initDraw();\r\n      drawBackground();\r\n      drawFrozenRows();\r\n      drawRows();\r\n      drawActiveCell();\r\n      drawHeaders();\r\n      drawFrozenMarkers();\r\n      drawSelectionHandles();\r\n      drawReorderMarkers();\r\n      drawMoveMarkers();\r\n      drawBorder();\r\n      drawSelectionBorders();\r\n      drawScrollBars();\r\n      if (checkScrollHeight) {\r\n        self.resize(true);\r\n      }\r\n      drawDebug();\r\n      drawPerfLines();\r\n      if (self.dispatchEvent('afterdraw', {})) { return; }\r\n      self.ctx.restore();\r\n    };\r\n  };\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true, plusplus: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\r\n  'use strict';\r\n  return function (self) {\r\n    var wheeling;\r\n    self.stopPropagation = function (e) { e.stopPropagation(); };\r\n    /**\r\n     * Adds an event listener to the given event.\r\n     * @memberof canvasDatagrid\r\n     * @name addEventListener\r\n     * @method\r\n     * @param {string} ev The name of the event to subscribe to.\r\n     * @param {function} fn The event procedure to execute when the event is raised.\r\n     */\r\n    self.addEventListener = function (ev, fn) {\r\n      self.events[ev] = self.events[ev] || [];\r\n      self.events[ev].unshift(fn);\r\n    };\r\n    /**\r\n     * Removes the given listener function from the given event.  Must be an actual reference to the function that was bound.\r\n     * @memberof canvasDatagrid\r\n     * @name removeEventListener\r\n     * @method\r\n     * @param {string} ev The name of the event to unsubscribe from.\r\n     * @param {function} fn The event procedure to execute when the event is raised.\r\n     */\r\n    self.removeEventListener = function (ev, fn) {\r\n      (self.events[ev] || []).forEach(function removeEachListener(sfn, idx) {\r\n        if (fn === sfn) {\r\n          self.events[ev].splice(idx, 1);\r\n        }\r\n      });\r\n    };\r\n    /**\r\n     * Fires the given event, padding an event object to the event subscribers.\r\n     * @memberof canvasDatagrid\r\n     * @name dispatchEvent\r\n     * @method\r\n     * @param {number} ev The name of the event to dispatch.\r\n     * @param {number} e The event object.\r\n     */\r\n    self.dispatchEvent = function (ev, e) {\r\n      e = ev.type ? ev : (e || {});\r\n      ev = ev.type || ev;\r\n      var defaultPrevented;\r\n      function preventDefault() {\r\n        defaultPrevented = true;\r\n      }\r\n      if (!self.events[ev]) { return; }\r\n      self.events[ev].forEach(function dispatchEachEvent(fn) {\r\n        e.ctx = self.ctx;\r\n        e.preventDefault = preventDefault;\r\n        fn.apply(self.intf, [e]);\r\n      });\r\n      return defaultPrevented;\r\n    };\r\n    self.getRatio = function () {\r\n      return Math.min(self.attributes.maxPixelRatio, (window.devicePixelRatio || 1) /\r\n        (self.ctx.webkitBackingStorePixelRatio ||\r\n          self.ctx.mozBackingStorePixelRatio ||\r\n          self.ctx.msBackingStorePixelRatio ||\r\n          self.ctx.oBackingStorePixelRatio ||\r\n          self.ctx.backingStorePixelRatio || 1));\r\n    };\r\n    self.resize = function (drawAfterResize) {\r\n      if (!self.canvas) { return; }\r\n      var x,\r\n        v = {\r\n          x: 0,\r\n          y: 0,\r\n          height: 0,\r\n          width: 0,\r\n          style: 'vertical-scroll-bar'\r\n        },\r\n        n = {\r\n          x: 0,\r\n          y: 0,\r\n          height: 0,\r\n          width: 0,\r\n          style: 'horizontal-scroll-bar'\r\n        },\r\n        vb = {\r\n          x: 0,\r\n          y: 0,\r\n          height: 0,\r\n          width: 0,\r\n          style: 'vertical-scroll-box'\r\n        },\r\n        nb = {\r\n          x: 0,\r\n          y: 0,\r\n          height: 0,\r\n          width: 0,\r\n          style: 'horizontal-scroll-box'\r\n        },\r\n        co = {\r\n          x: 0,\r\n          y: 0,\r\n          height: 0,\r\n          width: 0,\r\n          isCorner: true,\r\n          isScrollBoxCorner: true,\r\n          style: 'scroll-box-corner'\r\n        },\r\n        m = (self.style.scrollBarBoxMargin * 2),\r\n        b = (self.style.scrollBarBorderWidth * 2),\r\n        d = self.style.scrollBarBoxMargin * 0.5,\r\n        sbw = self.style.scrollBarWidth + (self.style.scrollBarBorderWidth * 2),\r\n        ratio = self.getRatio(),\r\n        bm = self.style.gridBorderCollapse === 'collapse' ? 1 : 2,\r\n        cellBorder = self.style.cellBorderWidth * bm,\r\n        columnHeaderCellBorder = self.style.columnHeaderCellBorderWidth * bm,\r\n        dataHeight = 0,\r\n        dataWidth = 0,\r\n        dims,\r\n        l = (self.data || []).length,\r\n        columnHeaderCellHeight = self.getColumnHeaderCellHeight(),\r\n        rowHeaderCellWidth = self.getRowHeaderCellWidth(),\r\n        ch = self.style.cellHeight,\r\n        s = self.getSchema();\r\n      // sets actual DOM canvas element\r\n      function checkScrollBoxVisibility() {\r\n        self.scrollBox.horizontalBarVisible = (self.style.width !== 'auto' && dataWidth > self.scrollBox.width && self.style.overflowX !== 'hidden')\r\n          || self.style.overflowX === 'scroll';\r\n        self.scrollBox.horizontalBoxVisible = dataWidth > self.scrollBox.width;\r\n        self.scrollBox.verticalBarVisible = (self.style.height !== 'auto' && dataHeight > self.scrollBox.height && self.style.overflowY !== 'hidden')\r\n          || self.style.overflowY === 'scroll';\r\n        self.scrollBox.verticalBoxVisible = dataHeight > self.scrollBox.height;\r\n      }\r\n      function setScrollBoxSize() {\r\n        self.scrollBox.width = self.width - rowHeaderCellWidth;\r\n        self.scrollBox.height = self.height - columnHeaderCellHeight;\r\n      }\r\n      function setCanvasSize() {\r\n        if (self.isChildGrid) {\r\n          return;\r\n        }\r\n        dims = {\r\n          // HACK +1 ? maybe it's a magic cell border?  Required to line up properly in auto height mode.\r\n          height: columnHeaderCellHeight + dataHeight + cellBorder + 1,\r\n          width: dataWidth + rowHeaderCellWidth + cellBorder\r\n        };\r\n        ['width', 'height'].forEach(function (dim) {\r\n          //TODO: support inherit\r\n          if (['auto', undefined].indexOf(self.style[dim]) !== -1\r\n            && ['auto', undefined].indexOf(self.appliedInlineStyles[dim]) !== -1) {\r\n            self.parentNodeStyle[dim] = dims[dim] + 'px';\r\n          } else {\r\n            self.parentNodeStyle[dim] = self.style[dim];\r\n            if (self.isComponet) {\r\n              self.canvas.style[dim] = self.style[dim];\r\n            }\r\n          }\r\n        });\r\n      }\r\n      self.scrollCache.x = [];\r\n      self.scrollCache.y = [];\r\n      for (x = 0; x < l; x += 1) {\r\n        self.scrollCache.y[x] = dataHeight;\r\n        dataHeight += (((self.sizes.rows[x] || ch) + (self.sizes.trees[x] || 0)) * self.scale)\r\n          // HACK? if an expanded tree row is frozen it is necessary to add the tree row's height a second time.\r\n          + (self.frozenRow > x ? (self.sizes.trees[x] || 0) : 0);\r\n      }\r\n      if (l > 1) {\r\n        self.scrollCache.y[x] = dataHeight;\r\n      }\r\n      dataWidth = s.reduce(function reduceSchema(accumulator, column, columnIndex) {\r\n        // intentional redefintion of column.  This causes scrollCache to be in the correct order\r\n        column = s[self.orders.columns[columnIndex]];\r\n        if (column.hidden) {\r\n          self.scrollCache.x[columnIndex] = accumulator;\r\n          return accumulator;\r\n        }\r\n        var va = accumulator + self.getColummnWidth(self.orders.columns[columnIndex]);\r\n        self.scrollCache.x[columnIndex] = va;\r\n        return va;\r\n      }, 0) || 0;\r\n      if (self.attributes.showNewRow) {\r\n        dataHeight += ch;\r\n      }\r\n      if (self.attributes.snapToRow) {\r\n        dataHeight += self.style.cellHeight;\r\n      }\r\n      setCanvasSize();\r\n      if (self.isChildGrid) {\r\n        self.width = self.parentNode.offsetWidth;\r\n        self.height = self.parentNode.offsetHeight;\r\n      } else if (self.height !== self.canvas.offsetHeight || self.width !== self.canvas.offsetWidth) {\r\n        self.height = self.canvas.offsetHeight;\r\n        self.width = self.canvas.offsetWidth;\r\n        self.canvasOffsetLeft = self.args.canvasOffsetLeft || 0;\r\n        self.canvasOffsetTop = self.args.canvasOffsetTop || 0;\r\n      }\r\n      /// calculate scroll bar dimensions\r\n      // non-controversial\r\n      self.scrollBox.top = columnHeaderCellHeight + columnHeaderCellBorder;\r\n      self.scrollBox.left = rowHeaderCellWidth;\r\n      // width and height of scroll box\r\n      setScrollBoxSize();\r\n      // is the data larger than the scroll box\r\n      checkScrollBoxVisibility();\r\n      // if the scroll box is visible, make room for it by expanding the size of the element\r\n      // if the other dimension is set to auto\r\n      if (self.scrollBox.horizontalBarVisible) {\r\n        if (self.style.height === 'auto' && !self.isChildGrid) {\r\n          self.height += sbw;\r\n        }\r\n        dataHeight += sbw;\r\n        setCanvasSize();\r\n        setScrollBoxSize();\r\n        checkScrollBoxVisibility();\r\n      }\r\n      if (self.scrollBox.verticalBarVisible) {\r\n        if (self.style.width === 'auto' && !self.isChildGrid) {\r\n          self.width += sbw;\r\n        }\r\n        dataWidth += sbw;\r\n        setCanvasSize();\r\n        setScrollBoxSize();\r\n        checkScrollBoxVisibility();\r\n      }\r\n      // set again after bar visibility checks\r\n      setScrollBoxSize();\r\n      self.scrollBox.scrollWidth = dataWidth - self.scrollBox.width;\r\n      self.scrollBox.scrollHeight = dataHeight - self.scrollBox.height;\r\n      self.scrollBox.widthBoxRatio = self.scrollBox.width / dataWidth;\r\n      self.scrollBox.scrollBoxWidth = self.scrollBox.width\r\n        * self.scrollBox.widthBoxRatio\r\n        - self.style.scrollBarWidth - b - d;\r\n      // TODO: This heightBoxRatio number is terribly wrong.\r\n      // They should be a result of the size of the grid/canvas?\r\n      // it being off causes the scroll bar to \"slide\" under\r\n      // the dragged mouse.\r\n      // https://github.com/TonyGermaneri/canvas-datagrid/issues/97\r\n      self.scrollBox.heightBoxRatio = (self.scrollBox.height - columnHeaderCellHeight) / dataHeight;\r\n      self.scrollBox.scrollBoxHeight = self.scrollBox.height\r\n        * self.scrollBox.heightBoxRatio\r\n        - self.style.scrollBarWidth - b - d;\r\n      self.scrollBox.scrollBoxWidth = Math.max(self.scrollBox.scrollBoxWidth, self.style.scrollBarBoxMinSize);\r\n      self.scrollBox.scrollBoxHeight = Math.max(self.scrollBox.scrollBoxHeight, self.style.scrollBarBoxMinSize);\r\n      // horizontal\r\n      n.x += rowHeaderCellWidth;\r\n      n.y += self.height - self.style.scrollBarWidth - d;\r\n      n.width = self.width - self.style.scrollBarWidth - rowHeaderCellWidth - d - m;\r\n      n.height = self.style.scrollBarWidth + self.style.scrollBarBorderWidth + d;\r\n      // horizontal box\r\n      nb.y = n.y + self.style.scrollBarBoxMargin;\r\n      nb.width = self.scrollBox.scrollBoxWidth;\r\n      nb.height = self.style.scrollBarBoxWidth;\r\n      // vertical\r\n      v.x += self.width - self.style.scrollBarWidth - self.style.scrollBarBorderWidth - d;\r\n      v.y += columnHeaderCellHeight;\r\n      v.width = self.style.scrollBarWidth + self.style.scrollBarBorderWidth + d;\r\n      v.height = self.height - columnHeaderCellHeight - self.style.scrollBarWidth - d - m;\r\n      // vertical box\r\n      vb.x = v.x + self.style.scrollBarBoxMargin;\r\n      vb.width = self.style.scrollBarBoxWidth;\r\n      vb.height = self.scrollBox.scrollBoxHeight;\r\n      // corner\r\n      co.x = n.x + n.width + m;\r\n      co.y = v.y + v.height + m;\r\n      co.width = self.style.scrollBarWidth + self.style.scrollBarBorderWidth;\r\n      co.height = self.style.scrollBarWidth + self.style.scrollBarBorderWidth;\r\n      self.scrollBox.entities = {\r\n        horizontalBar: n,\r\n        horizontalBox: nb,\r\n        verticalBar: v,\r\n        verticalBox: vb,\r\n        corner: co\r\n      };\r\n      self.scrollBox.bar = {\r\n        v: v,\r\n        h: n\r\n      };\r\n      self.scrollBox.box = {\r\n        v: vb,\r\n        h: nb\r\n      };\r\n      /// calculate page and dom elements\r\n      self.page = Math.max(1, self.visibleRows.length - 3 - self.attributes.pageUpDownOverlap);\r\n      // set canvas drawing related items\r\n      if (!self.isChildGrid) {\r\n        self.canvas.width = self.width * ratio;\r\n        self.canvas.height = self.height * ratio;\r\n        self.ctx.scale(ratio, ratio);\r\n      }\r\n      // resize any open dom elements (input/textarea)\r\n      self.resizeEditInput();\r\n      self.scroll(true);\r\n      if (drawAfterResize) {\r\n        self.draw(true);\r\n      }\r\n      self.dispatchEvent('resize', {});\r\n      return true;\r\n    };\r\n    self.scroll = function (dontDraw) {\r\n      var s = self.getSchema(),\r\n        l = (self.data || []).length,\r\n        ch = self.style.cellHeight;\r\n      // go too far in leaps, then get focused\r\n      self.scrollIndexTop = Math.floor((l * (self.scrollBox.scrollTop / self.scrollBox.scrollHeight)) - 100);\r\n      self.scrollIndexTop = Math.max(self.scrollIndexTop, 0);\r\n      self.scrollPixelTop = self.scrollCache.y[self.scrollIndexTop];\r\n      // sometimes the grid is rendered but the height is zero\r\n      if (self.scrollBox.scrollHeight === 0) {\r\n        self.scrollIndexTop = 0;\r\n      }\r\n      self.scrollPixelTop = 0;\r\n      self.scrollIndexLeft = self.frozenColumn;\r\n      self.scrollPixelLeft = 0;\r\n      while (self.scrollPixelTop < self.scrollBox.scrollTop && self.scrollIndexTop < self.data.length) {\r\n        // start on index +1 since index 0 was used in \"go too far\" section above\r\n        self.scrollIndexTop += 1;\r\n        self.scrollPixelTop = self.scrollCache.y[self.scrollIndexTop];\r\n      }\r\n      while (self.scrollPixelLeft < (self.scrollBox.scrollLeft + 1) && self.scrollIndexLeft < s.length) {\r\n        self.scrollPixelLeft = self.scrollCache.x[self.scrollIndexLeft];\r\n        self.scrollIndexLeft += 1;\r\n      }\r\n      if (s.length > 0) {\r\n        self.scrollIndexLeft = Math.max(self.scrollIndexLeft - 1, 0);\r\n        self.scrollPixelLeft -= self.getColummnWidth(self.orders.columns[self.scrollIndexLeft]);\r\n      }\r\n      if ((self.data || []).length > 0) {\r\n        self.scrollIndexTop = Math.max(self.scrollIndexTop - 1, 0);\r\n        self.scrollPixelTop = Math.max((self.scrollPixelTop\r\n          - (\r\n            self.data[self.scrollIndexTop] ? (self.sizes.rows[self.scrollIndexTop] || ch)\r\n              + (self.sizes.trees[self.scrollIndexTop] || 0)\r\n              : ch\r\n          ) * self.scale), 0);\r\n      }\r\n      self.ellipsisCache = {};\r\n      if (!dontDraw) {\r\n        self.draw(true);\r\n      }\r\n      //TODO: figure out why this has to be delayed for child grids\r\n      //BUG: wheeling event on 3rd level hierarchy fails to move input box\r\n      requestAnimationFrame(self.resizeEditInput);\r\n      self.dispatchEvent('scroll', { top: self.scrollBox.scrollTop, left: self.scrollBox.scrollLeft });\r\n    };\r\n    self.mousemove = function (e, overridePos) {\r\n      if (self.contextMenu || self.input) {\r\n        return;\r\n      }\r\n      self.mouse = overridePos || self.getLayerPos(e);\r\n      var ctrl = ((e.ctrlKey || e.metaKey || self.attributes.persistantSelectionMode) && !self.attributes.singleSelectionMode),\r\n        i,\r\n        s = self.getSchema(),\r\n        dragBounds,\r\n        sBounds,\r\n        x = self.mouse.x,\r\n        y = self.mouse.y,\r\n        o = self.getCellAt(x, y),\r\n        delta,\r\n        ev = { NativeEvent: e, cell: o, x: x, y: y },\r\n        previousCell = self.currentCell;\r\n      clearTimeout(self.scrollTimer);\r\n      if (!self.isInGrid({ x: x, y: y })) {\r\n        self.hasFocus = false;\r\n      }\r\n      if (self.dispatchEvent('mousemove', ev)) {\r\n        return;\r\n      }\r\n      if (o && self.currentCell) {\r\n        self.rowBoundaryCrossed = self.currentCell.rowIndex !== o.rowIndex;\r\n        self.columnBoundaryCrossed = self.currentCell.columnIndex !== o.columnIndex;\r\n        self.cellBoundaryCrossed = self.rowBoundaryCrossed || self.columnBoundaryCrossed;\r\n        ['row', 'column', 'cell'].forEach(function (prefix) {\r\n          if (self[prefix + 'BoundaryCrossed']) {\r\n            ev.cell = previousCell;\r\n            self.dispatchEvent(prefix + 'mouseout', ev);\r\n            ev.cell = o;\r\n            self.dispatchEvent(prefix + 'mouseover', ev);\r\n          }\r\n        });\r\n      }\r\n      self.currentCell = o;\r\n      if (!self.hasFocus) {\r\n        return;\r\n      }\r\n      self.hovers = {};\r\n      if (!self.draggingItem\r\n        && o\r\n        && self.scrollModes.indexOf(o.context) === -1) {\r\n        self.dragItem = o;\r\n        self.dragMode = o.dragContext;\r\n        self.cursor = o.context;\r\n        if (o.context === 'cell') {\r\n          self.cursor = 'default';\r\n          self.hovers = { rowIndex: o.rowIndex, columnIndex: o.columnIndex };\r\n        }\r\n        if ((self.selecting || self.reorderObject)\r\n          && o.context === 'cell') {\r\n          delta = {\r\n            x: Math.abs(self.dragStart.x - x),\r\n            y: Math.abs(self.dragStart.y - y)\r\n          };\r\n          if (self.dragStartObject.columnIndex !== -1 && e.shiftKey) {\r\n            self.dragStartObject = {\r\n              rowIndex: self.activeCell.rowIndex,\r\n              columnIndex: self.activeCell.columnIndex\r\n            };\r\n          }\r\n          dragBounds = {\r\n            top: Math.min(self.dragStartObject.rowIndex, o.rowIndex),\r\n            left: Math.min(self.dragStartObject.columnIndex, o.columnIndex),\r\n            bottom: Math.max(self.dragStartObject.rowIndex, o.rowIndex),\r\n            right: Math.max(self.dragStartObject.columnIndex, o.columnIndex)\r\n          };\r\n          if (self.dragStartObject.columnIndex === -1) {\r\n            sBounds = self.getSelectionBounds();\r\n            dragBounds.left = -1;\r\n            dragBounds.right = s.length - 1;\r\n            dragBounds.top = Math.min(sBounds.top, o.rowIndex);\r\n            dragBounds.bottom = Math.max(sBounds.bottom, o.rowIndex);\r\n          }\r\n          if (self.dragStartObject.rowIndex !== o.rowIndex\r\n            || self.dragStartObject.columnIndex !== o.columnIndex) {\r\n            self.ignoreNextClick = true;\r\n          }\r\n          if (self.cellBoundaryCrossed || (delta.x === 0 && delta.y === 0) || (self.attributes.selectionMode === 'row')) {\r\n            if (((self.attributes.selectionMode === 'row') || self.dragStartObject.columnIndex === -1)\r\n              && self.rowBoundaryCrossed) {\r\n              self.selectRow(o.rowIndex, ctrl, null, true);\r\n            } else if (self.attributes.selectionMode !== 'row') {\r\n              if (!self.dragAddToSelection && o.rowIndex !== undefined) {\r\n                if (self.selections[o.rowIndex] && self.selections[o.rowIndex].indexOf(o.columnIndex) !== -1) {\r\n                  self.selections[o.rowIndex].splice(self.selections[o.rowIndex].indexOf(o.columnIndex), 1);\r\n                }\r\n              } else {\r\n                self.selections[o.rowIndex] = self.selections[o.rowIndex] || [];\r\n                if (self.selections[o.rowIndex].indexOf(o.columnIndex) === -1) {\r\n                  self.selections[o.rowIndex].push(o.columnIndex);\r\n                }\r\n              }\r\n            }\r\n          }\r\n          if ((!self.selectionBounds || (dragBounds.top !== self.selectionBounds.top\r\n            || dragBounds.left !== self.selectionBounds.left\r\n            || dragBounds.bottom !== self.selectionBounds.bottom\r\n            || dragBounds.right !== self.selectionBounds.right)) && !ctrl) {\r\n            self.selections = [];\r\n            sBounds = dragBounds;\r\n            if (self.attributes.selectionMode === 'row') {\r\n              for (i = sBounds.top; i <= sBounds.bottom; i += 1) {\r\n                self.selectRow(i, true, null, true);\r\n              }\r\n            } else if (dragBounds.top !== -1) {\r\n              self.selectArea(sBounds, true);\r\n            }\r\n          }\r\n          self.autoScrollZone(e, x, y, ctrl);\r\n        }\r\n      }\r\n      self.cellBoundaryCrossed = false;\r\n      self.rowBoundaryCrossed = false;\r\n      self.columnBoundaryCrossed = false;\r\n      self.draw(true);\r\n    };\r\n    self.click = function (e, overridePos) {\r\n      var i,\r\n        startingBounds = JSON.stringify(self.getSelectionBounds()),\r\n        ctrl = ((e.ctrlKey || e.metaKey || self.attributes.persistantSelectionMode) && !self.attributes.singleSelectionMode),\r\n        pos = overridePos || self.getLayerPos(e);\r\n      self.currentCell = self.getCellAt(pos.x, pos.y, false, true, false);\r\n\r\n      if (self.currentCell.grid !== undefined) {\r\n        return;\r\n      }\r\n      function checkSelectionChange() {\r\n        var ev, sb = self.getSelectionBounds();\r\n        if (startingBounds === JSON.stringify(sb)) {\r\n          return;\r\n        }\r\n        ev = {\r\n          selections: self.selections,\r\n          selectionBounds: self.getSelectionBounds()\r\n        };\r\n        Object.defineProperty(ev, 'selectedData', {\r\n          get: function () {\r\n            return self.getSelectedData();\r\n          }\r\n        });\r\n        self.dispatchEvent('selectionchanged', ev);\r\n      }\r\n      if (self.input) {\r\n        self.endEdit();\r\n      }\r\n      if (self.ignoreNextClick) {\r\n        self.ignoreNextClick = false;\r\n        return;\r\n      }\r\n      i = self.currentCell;\r\n      if (self.dispatchEvent('click', { NativeEvent: e, cell: self.currentCell })) { return; }\r\n      if (!self.hasFocus) {\r\n        return;\r\n      }\r\n      if (['rowHeaderCell', 'columnHeaderCell'].indexOf(self.currentCell.style) === -1 && !ctrl) {\r\n        self.setActiveCell(i.columnIndex, i.rowIndex);\r\n      }\r\n      if (self.currentCell.context === 'cell') {\r\n        if (self.currentCell.style === 'cornerCell') {\r\n          self.selectAll();\r\n          self.draw();\r\n          checkSelectionChange();\r\n          return;\r\n        }\r\n        if (self.currentCell.style === 'columnHeaderCell') {\r\n          if (self.attributes.columnHeaderClickBehavior === 'sort') {\r\n            if (self.orderBy === i.header.name) {\r\n              self.orderDirection = self.orderDirection === 'asc' ? 'desc' : 'asc';\r\n            } else {\r\n              self.orderDirection = 'asc';\r\n            }\r\n            self.order(i.header.name, self.orderDirection);\r\n            checkSelectionChange();\r\n            return;\r\n          }\r\n          if (self.attributes.columnHeaderClickBehavior === 'select') {\r\n            self.selectColumn(i.header.index, ctrl, e.shiftKey);\r\n            self.draw();\r\n            return;\r\n          }\r\n        }\r\n        self.selections[i.rowIndex] = self.selections[i.rowIndex] || [];\r\n        if (((self.attributes.selectionMode === 'row') || self.currentCell.style === 'rowHeaderCell')) {\r\n          if (self.currentCell.style === 'rowHeaderCell'\r\n            && self.attributes.tree && pos.x > 0\r\n            && pos.x - self.currentCell.x < self.style.treeArrowWidth\r\n            + self.style.treeArrowMarginLeft\r\n            + self.style.treeArrowMarginRight + self.style.treeArrowClickRadius\r\n            && pos.y - self.currentCell.y < self.style.treeArrowHeight\r\n            + self.style.treeArrowMarginTop + self.style.treeArrowClickRadius\r\n            && pos.y > 0) {\r\n            self.toggleTree(i.rowIndex);\r\n            return;\r\n          }\r\n        }\r\n        if (e.shiftKey && !ctrl) {\r\n          self.selectionBounds = self.getSelectionBounds();\r\n          self.selectArea(undefined, false);\r\n        }\r\n      }\r\n      checkSelectionChange();\r\n      self.draw(true);\r\n    };\r\n    self.dragResizeColumn = function (e) {\r\n      var pos, x, y;\r\n      pos = self.getLayerPos(e);\r\n      x = self.resizingStartingWidth + pos.x - self.dragStart.x;\r\n      y = self.resizingStartingHeight + pos.y - self.dragStart.y;\r\n      if (x < self.style.minColumnWidth) {\r\n        x = self.style.minColumnWidth;\r\n      }\r\n      if (y < self.style.minRowHeight) {\r\n        y = self.style.minRowHeight;\r\n      }\r\n      if (self.dispatchEvent('resizecolumn', { x: x, y: y, draggingItem: self.draggingItem })) { return false; }\r\n      if (self.scrollBox.scrollLeft > self.scrollBox.scrollWidth - self.attributes.resizeScrollZone\r\n        && self.dragMode === 'ew-resize') {\r\n        self.resize(true);\r\n        self.scrollBox.scrollLeft += x;\r\n      }\r\n      if (self.dragMode === 'ew-resize') {\r\n        self.sizes.columns[self.draggingItem.header.style === 'rowHeaderCell'\r\n          ? 'cornerCell' : self.draggingItem.sortColumnIndex] = x;\r\n        if (['rowHeaderCell', 'cornerCell'].indexOf(self.draggingItem.header.style) !== -1) {\r\n          self.resize(true);\r\n        }\r\n        self.resizeChildGrids();\r\n        return;\r\n      }\r\n      if (self.dragMode === 'ns-resize') {\r\n        if (self.draggingItem.rowOpen) {\r\n          self.sizes.trees[self.draggingItem.rowIndex] = y;\r\n        } else if (self.attributes.globalRowResize) {\r\n          self.style.cellHeight = y;\r\n        } else {\r\n          self.sizes.rows[self.draggingItem.rowIndex] = y;\r\n        }\r\n        self.dispatchEvent('resizerow', { row: y });\r\n        self.resizeChildGrids();\r\n        return;\r\n      }\r\n      self.ellipsisCache = {};\r\n    };\r\n    self.stopDragResize = function () {\r\n      self.resize();\r\n      document.body.removeEventListener('mousemove', self.dragResizeColumn, false);\r\n      document.body.removeEventListener('mouseup', self.stopDragResize, false);\r\n      self.setStorageData();\r\n      self.draw(true);\r\n      self.ignoreNextClick = true;\r\n    };\r\n    self.scrollGrid = function (e) {\r\n      var pos = self.getLayerPos(e);\r\n      if (self.attributes.scrollPointerLock && self.pointerLockPosition\r\n        && ['horizontal-scroll-box', 'vertical-scroll-box'].indexOf(self.scrollStartMode) !== -1) {\r\n        self.pointerLockPosition.x += e.movementX;\r\n        self.pointerLockPosition.y += e.movementY;\r\n        self.pointerLockPosition.x = Math.min(self.width - self.style.scrollBarWidth, Math.max(0, self.pointerLockPosition.x));\r\n        self.pointerLockPosition.y = Math.min(self.height - self.style.scrollBarWidth, Math.max(0, self.pointerLockPosition.y));\r\n        pos = self.pointerLockPosition;\r\n      }\r\n      self.scrollMode = self.getCellAt(pos.x, pos.y).context;\r\n      if (self.scrollMode === 'horizontal-scroll-box' && self.scrollStartMode !== 'horizontal-scroll-box') {\r\n        self.scrollStartMode = 'horizontal-scroll-box';\r\n        self.dragStart = pos;\r\n        self.scrollStart.left = self.scrollBox.scrollLeft;\r\n        clearTimeout(self.scrollTimer);\r\n        return;\r\n      }\r\n      if (self.scrollMode === 'vertical-scroll-box' && self.scrollStartMode !== 'vertical-scroll-box') {\r\n        self.scrollStartMode = 'vertical-scroll-box';\r\n        self.dragStart = pos;\r\n        self.scrollStart.top = self.scrollBox.scrollTop;\r\n        clearTimeout(self.scrollTimer);\r\n        return;\r\n      }\r\n      if (self.scrollStartMode === 'vertical-scroll-box'\r\n        && self.scrollMode !== 'vertical-scroll-box') {\r\n        self.scrollMode = 'vertical-scroll-box';\r\n      }\r\n      if (self.scrollStartMode === 'horizontal-scroll-box'\r\n        && self.scrollMode !== 'horizontal-scroll-box') {\r\n        self.scrollMode = 'horizontal-scroll-box';\r\n      }\r\n      clearTimeout(self.scrollTimer);\r\n      if (self.scrollModes.indexOf(self.scrollMode) === -1) {\r\n        return;\r\n      }\r\n      if (self.scrollMode === 'vertical-scroll-box') {\r\n        self.scrollBox.scrollTop = self.scrollStart.top + ((pos.y - self.dragStart.y)\r\n          / self.scrollBox.heightBoxRatio);\r\n      } else if (self.scrollMode === 'vertical-scroll-top') {\r\n        self.scrollBox.scrollTop -= (self.page * self.style.cellHeight);\r\n        self.scrollTimer = setTimeout(self.scrollGrid, self.attributes.scrollRepeatRate, e);\r\n      } else if (self.scrollMode === 'vertical-scroll-bottom') {\r\n        self.scrollBox.scrollTop += (self.page * self.style.cellHeight);\r\n        self.scrollTimer = setTimeout(self.scrollGrid, self.attributes.scrollRepeatRate, e);\r\n      }\r\n      if (self.scrollMode === 'horizontal-scroll-box') {\r\n        self.scrollBox.scrollLeft = self.scrollStart.left + ((pos.x - self.dragStart.x)\r\n          / self.scrollBox.widthBoxRatio);\r\n      } else if (self.scrollMode === 'horizontal-scroll-right') {\r\n        self.scrollBox.scrollLeft += self.attributes.selectionScrollIncrement;\r\n        self.scrollTimer = setTimeout(self.scrollGrid, self.attributes.scrollRepeatRate, e);\r\n      } else if (self.scrollMode === 'horizontal-scroll-left') {\r\n        self.scrollBox.scrollLeft -= self.attributes.selectionScrollIncrement;\r\n        self.scrollTimer = setTimeout(self.scrollGrid, self.attributes.scrollRepeatRate, e);\r\n      }\r\n    };\r\n    self.stopScrollGrid = function () {\r\n      clearTimeout(self.scrollTimer);\r\n      if (document.exitPointerLock) {\r\n        document.exitPointerLock();\r\n      }\r\n      document.removeEventListener('mousemove', self.scrollGrid, false);\r\n    };\r\n    self.dragReorder = function (e) {\r\n      var pos, x, y,\r\n        columReorder = self.dragMode === 'column-reorder',\r\n        rowReorder = self.dragMode === 'row-reorder';\r\n      pos = self.getLayerPos(e);\r\n      x = pos.x - self.dragStart.x;\r\n      y = pos.y - self.dragStart.y;\r\n      if (!self.attributes.allowColumnReordering && columReorder) {\r\n        return;\r\n      }\r\n      if (!self.attributes.allowRowReordering && rowReorder) {\r\n        return;\r\n      }\r\n      if (self.dispatchEvent('reordering', {\r\n        NativeEvent: e,\r\n        source: self.dragStartObject,\r\n        target: self.currentCell,\r\n        dragMode: self.dragMode\r\n      })) {\r\n        return;\r\n      }\r\n      if (Math.abs(x) > self.attributes.reorderDeadZone || Math.abs(y) > self.attributes.reorderDeadZone) {\r\n        self.reorderObject = self.draggingItem;\r\n        self.reorderTarget = self.currentCell;\r\n        self.reorderObject.dragOffset = {\r\n          x: x,\r\n          y: y\r\n        };\r\n        self.autoScrollZone(e, columReorder ? pos.x : -1, rowReorder ? pos.y : -1, false);\r\n      }\r\n    };\r\n    self.stopDragReorder = function (e) {\r\n      var oIndex,\r\n        tIndex,\r\n        cr = {\r\n          'row-reorder': self.orders.rows,\r\n          'column-reorder': self.orders.columns\r\n        },\r\n        i = {\r\n          'row-reorder': 'rowIndex',\r\n          'column-reorder': 'sortColumnIndex'\r\n        }[self.dragMode];\r\n      document.body.removeEventListener('mousemove', self.dragReorder, false);\r\n      document.body.removeEventListener('mouseup', self.stopDragReorder, false);\r\n      if (self.reorderObject\r\n        && self.reorderTarget\r\n        && ((self.dragMode === 'column-reorder' && self.reorderTarget.sortColumnIndex > -1\r\n          && self.reorderTarget.sortColumnIndex < self.getSchema().length)\r\n          || (self.dragMode === 'row-reorder' && self.reorderTarget.rowIndex > -1\r\n            && self.reorderTarget.rowIndex < self.data.length))\r\n        && self.reorderObject[i] !== self.reorderTarget[i]\r\n        && !self.dispatchEvent('reorder', {\r\n          NativeEvent: e,\r\n          source: self.reorderObject,\r\n          target: self.reorderTarget,\r\n          dragMode: self.dragMode\r\n        })) {\r\n        self.ignoreNextClick = true;\r\n        oIndex = cr[self.dragMode].indexOf(self.reorderObject[i]);\r\n        tIndex = cr[self.dragMode].indexOf(self.reorderTarget[i]);\r\n        cr[self.dragMode].splice(oIndex, 1);\r\n        cr[self.dragMode].splice(tIndex, 0, self.reorderObject[i]);\r\n        if (self.dragMode === 'column-reorder') {\r\n          self.orders.columns = cr[self.dragMode];\r\n        } else {\r\n          self.orders.rows = cr[self.dragMode];\r\n        }\r\n        self.resize();\r\n        self.setStorageData();\r\n      }\r\n      self.reorderObject = undefined;\r\n      self.reorderTarget = undefined;\r\n      self.draw(true);\r\n    };\r\n    self.dragMove = function (e) {\r\n      if (self.dispatchEvent('moving', { NativeEvent: e, cell: self.currentCell })) { return; }\r\n      var pos = self.getLayerPos(e);\r\n      self.moveOffset = {\r\n        x: self.currentCell.columnIndex - self.dragStartObject.columnIndex,\r\n        y: self.currentCell.rowIndex - self.dragStartObject.rowIndex\r\n      };\r\n      if (Math.abs(pos.x) > self.attributes.reorderDeadZone || Math.abs(pos.y) > self.attributes.reorderDeadZone) {\r\n        setTimeout(function () {\r\n          self.autoScrollZone(e, pos.x, pos.y, false);\r\n        }, 1);\r\n      }\r\n    };\r\n    self.stopDragMove = function (e) {\r\n      document.body.removeEventListener('mousemove', self.dragMove, false);\r\n      document.body.removeEventListener('mouseup', self.stopDragMove, false);\r\n      var b = self.getSelectionBounds();\r\n      if (self.dispatchEvent('endmove', { NativeEvent: e, cell: self.currentCell })) {\r\n        self.movingSelection = undefined;\r\n        self.moveOffset = undefined;\r\n        self.draw(true);\r\n        return;\r\n      }\r\n      if (self.moveOffset) {\r\n        self.moveTo(self.movingSelection, b.left + self.moveOffset.x, b.top + self.moveOffset.y);\r\n        self.moveSelection(self.moveOffset.x, self.moveOffset.y);\r\n      }\r\n      self.movingSelection = undefined;\r\n      self.moveOffset = undefined;\r\n      self.draw(true);\r\n    };\r\n    self.freezeMove = function (e) {\r\n      if (self.dispatchEvent('freezemoving', { NativeEvent: e, cell: self.currentCell })) { return; }\r\n      var pos = self.getLayerPos(e);\r\n      self.ignoreNextClick = true;\r\n      self.freezeMarkerPosition = pos;\r\n      if (self.currentCell && self.currentCell.rowIndex !== undefined && self.dragMode === 'frozen-row-marker') {\r\n        self.scrollBox.scrollTop = 0;\r\n        self.frozenRow = self.currentCell.rowIndex + 1;\r\n      }\r\n      if (self.currentCell && self.currentCell.columnIndex !== undefined && self.dragMode === 'frozen-column-marker') {\r\n        self.scrollBox.scrollLeft = 0;\r\n        self.frozenColumn = self.currentCell.columnIndex + 1;\r\n      }\r\n      if (Math.abs(pos.x) > self.attributes.reorderDeadZone || Math.abs(pos.y) > self.attributes.reorderDeadZone) {\r\n        setTimeout(function () {\r\n          self.autoScrollZone(e, pos.x, pos.y, false);\r\n        }, 1);\r\n      }\r\n    };\r\n    self.stopFreezeMove = function (e) {\r\n      document.body.removeEventListener('mousemove', self.freezeMove, false);\r\n      document.body.removeEventListener('mouseup', self.stopFreezeMove, false);\r\n      self.freezeMarkerPosition = undefined;\r\n      if (self.dispatchEvent('endfreezemove', { NativeEvent: e, cell: self.currentCell })) {\r\n        self.frozenRow = self.startFreezeMove.x;\r\n        self.frozenColumn = self.startFreezeMove.y;\r\n        self.draw(true);\r\n        return;\r\n      }\r\n      self.draw(true);\r\n    };\r\n    self.mousedown = function (e, overridePos) {\r\n      self.lastMouseDownTarget = e.target;\r\n      if (self.dispatchEvent('mousedown', { NativeEvent: e, cell: self.currentCell })) { return; }\r\n      if (!self.hasFocus) {\r\n        return;\r\n      }\r\n      if (e.button === 2 || self.input) { return; }\r\n      var ctrl = (e.ctrlKey || e.metaKey),\r\n        move = /-move/.test(self.dragMode),\r\n        freeze = /frozen-row-marker|frozen-column-marker/.test(self.dragMode),\r\n        resize = /-resize/.test(self.dragMode);\r\n      self.dragStart = overridePos || self.getLayerPos(e);\r\n      self.scrollStart = {\r\n        left: self.scrollBox.scrollLeft,\r\n        top: self.scrollBox.scrollTop\r\n      };\r\n      self.dragStartObject = self.getCellAt(self.dragStart.x, self.dragStart.y);\r\n      self.dragAddToSelection = !self.dragStartObject.selected;\r\n      if (!ctrl && !e.shiftKey && !/(vertical|horizontal)-scroll-(bar|box)/\r\n        .test(self.dragStartObject.context)\r\n        && self.currentCell\r\n        && !self.currentCell.isColumnHeader\r\n        && !move\r\n        && !freeze\r\n        && !resize) {\r\n        self.selections = [];\r\n      }\r\n      if (self.dragStartObject.isGrid) {\r\n        return;\r\n      }\r\n      if (self.scrollModes.indexOf(self.dragStartObject.context) !== -1) {\r\n        self.scrollMode = self.dragStartObject.context;\r\n        self.scrollStartMode = self.dragStartObject.context;\r\n        self.scrollGrid(e);\r\n        if (self.attributes.scrollPointerLock\r\n          && ['horizontal-scroll-box', 'vertical-scroll-box'].indexOf(self.scrollStartMode) !== -1) {\r\n          self.pointerLockPosition = {\r\n            x: self.dragStart.x,\r\n            y: self.dragStart.y\r\n          };\r\n          self.canvas.requestPointerLock();\r\n        }\r\n        document.addEventListener('mousemove', self.scrollGrid, false);\r\n        document.addEventListener('mouseup', self.stopScrollGrid, false);\r\n        self.ignoreNextClick = true;\r\n        return;\r\n      }\r\n      if (self.dragMode === 'cell') {\r\n        self.selecting = true;\r\n        if ((self.attributes.selectionMode === 'row' || self.dragStartObject.columnIndex === -1)\r\n          && self.dragStartObject.rowIndex > -1) {\r\n          self.selectRow(self.dragStartObject.rowIndex, ctrl, null);\r\n        } else if (self.attributes.selectionMode !== 'row') {\r\n          self.mousemove(e);\r\n        }\r\n        return;\r\n      }\r\n      if (move) {\r\n        self.draggingItem = self.dragItem;\r\n        self.movingSelection = self.selections.concat([]);\r\n        self.dragging = self.dragStartObject;\r\n        if (self.dispatchEvent('beginmove', { NativeEvent: e, cell: self.currentCell })) { return; }\r\n        document.body.addEventListener('mousemove', self.dragMove, false);\r\n        document.body.addEventListener('mouseup', self.stopDragMove, false);\r\n        return self.mousemove(e);\r\n      }\r\n      if (freeze) {\r\n        self.draggingItem = self.dragItem;\r\n        self.startFreezeMove = {\r\n          x: self.frozenRow,\r\n          y: self.frozenColumn\r\n        };\r\n        if (self.dispatchEvent('beginfreezemove', { NativeEvent: e })) { return; }\r\n        document.body.addEventListener('mousemove', self.freezeMove, false);\r\n        document.body.addEventListener('mouseup', self.stopFreezeMove, false);\r\n        return self.mousemove(e);\r\n      }\r\n      if (resize) {\r\n        self.draggingItem = self.dragItem;\r\n        if (self.draggingItem.rowOpen) {\r\n          self.resizingStartingHeight = self.sizes.trees[self.draggingItem.rowIndex];\r\n        } else {\r\n          self.resizingStartingHeight = self.sizes.rows[self.draggingItem.rowIndex] || self.style.cellHeight;\r\n        }\r\n        self.resizingStartingWidth = self.sizes.columns[self.draggingItem.header.style === 'rowHeaderCell'\r\n          ? 'cornerCell' : self.draggingItem.sortColumnIndex] || self.draggingItem.width;\r\n        document.body.addEventListener('mousemove', self.dragResizeColumn, false);\r\n        document.body.addEventListener('mouseup', self.stopDragResize, false);\r\n        return;\r\n      }\r\n      if (['row-reorder', 'column-reorder'].indexOf(self.dragMode) !== -1) {\r\n        self.draggingItem = self.dragStartObject;\r\n        document.body.addEventListener('mousemove', self.dragReorder, false);\r\n        document.body.addEventListener('mouseup', self.stopDragReorder, false);\r\n        return;\r\n      }\r\n    };\r\n    self.mouseup = function (e) {\r\n      clearTimeout(self.scrollTimer);\r\n      self.cellBoundaryCrossed = true;\r\n      self.rowBoundaryCrossed = true;\r\n      self.columnBoundaryCrossed = true;\r\n      self.selecting = undefined;\r\n      self.draggingItem = undefined;\r\n      self.dragStartObject = undefined;\r\n      if (self.dispatchEvent('mouseup', { NativeEvent: e, cell: self.currentCell })) { return; }\r\n      if (!self.hasFocus && e.target !== self.canvas) {\r\n        return;\r\n      }\r\n      if (self.currentCell && self.currentCell.grid !== undefined) {\r\n        return;\r\n      }\r\n      if (self.contextMenu || self.input) { return; }\r\n      if (self.dragStart && self.isInGrid(self.dragStart)) {\r\n        self.controlInput.focus();\r\n      }\r\n      e.preventDefault();\r\n    };\r\n    // gets the horizontal adjacent cells as well as first/last based on column visibility\r\n    self.getAdjacentCells = function () {\r\n      var x,\r\n        i,\r\n        s = self.getSchema(),\r\n        o = {};\r\n      for (x = 0; x < s.length; x += 1) {\r\n        i = self.orders.columns[x];\r\n        if (!s[i].hidden) {\r\n          if (o.first === undefined) {\r\n            o.first = x;\r\n            o.left = x;\r\n          }\r\n          o.last = x;\r\n          if (x > self.activeCell.columnIndex && o.right === undefined) {\r\n            o.right = x;\r\n          }\r\n          if (x < self.activeCell.columnIndex) {\r\n            o.left = x;\r\n          }\r\n        }\r\n      }\r\n      if (o.right === undefined) {\r\n        o.right = o.last;\r\n      }\r\n      return o;\r\n    };\r\n    self.keydown = function (e) {\r\n      var i,\r\n        ev,\r\n        adjacentCells = self.getAdjacentCells(),\r\n        x = self.activeCell.columnIndex,\r\n        y = self.activeCell.rowIndex,\r\n        ctrl = (e.ctrlKey || e.metaKey),\r\n        last = self.data.length - 1,\r\n        s = self.getSchema(),\r\n        cols = s.length - 1;\r\n      if (self.dispatchEvent('keydown', { NativeEvent: e, cell: self.currentCell })) { return; }\r\n      if (!self.hasFocus) {\r\n        return;\r\n      }\r\n      if (self.attributes.showNewRow) {\r\n        last += 1;\r\n      }\r\n      if (e.keyCode === 9) {\r\n        e.preventDefault();\r\n      }\r\n      // esc\r\n      if (e.keyCode === 27) {\r\n        self.selections = [];\r\n        self.draw(true);\r\n        // ctrl + a\r\n      } else if (ctrl && e.keyCode === 65) {\r\n        self.selectAll();\r\n        //ArrowDown\r\n      } else if (e.keyCode === 40) {\r\n        y += 1;\r\n        //ArrowUp\r\n      } else if (e.keyCode === 38) {\r\n        y -= 1;\r\n        //ArrowLeft Tab\r\n      } else if (e.keyCode === 37 || (e.shiftKey && e.keyCode === 9)) {\r\n        x = adjacentCells.left;\r\n        //ArrowRight Tab\r\n      } else if (e.keyCode === 39 || (!e.shiftKey && e.keyCode === 9)) {\r\n        x = adjacentCells.right;\r\n        //PageUp\r\n      } else if (e.keyCode === 33) {\r\n        y -= self.page;\r\n        e.preventDefault();\r\n        //PageDown\r\n      } else if (e.keyCode === 34) {\r\n        y += self.page;\r\n        e.preventDefault();\r\n        //Home ArrowUp\r\n      } else if (e.keyCode === 36 || (ctrl && e.keyCode === 38)) {\r\n        y = 0;\r\n        //End ArrowDown\r\n      } else if (e.keyCode === 35 || (ctrl && e.keyCode === 40)) {\r\n        y = self.data.length - 1;\r\n        //ArrowRight\r\n      } else if (ctrl && e.keyCode === 39) {\r\n        x = adjacentCells.last;\r\n        //ArrowLeft\r\n      } else if (ctrl && e.keyCode === 37) {\r\n        x = adjacentCells.first;\r\n      }\r\n      //Enter\r\n      if (e.keyCode === 13) {\r\n        return self.beginEditAt(x, y, e);\r\n      }\r\n      //Space\r\n      if (e.keyCode === 32) {\r\n        self.selections = [];\r\n        self.selections[Math.max(y, 0)] = [];\r\n        self.selections[Math.max(y, 0)].push(x);\r\n        self.selectionBounds = self.getSelectionBounds();\r\n        if (self.attributes.selectionMode === 'row') {\r\n          for (i = self.selectionBounds.top; i <= self.selectionBounds.bottom; i += 1) {\r\n            self.selectRow(i, ctrl, null, true);\r\n          }\r\n        } else {\r\n          self.selectArea(undefined, ctrl);\r\n        }\r\n        e.preventDefault();\r\n        self.draw(true);\r\n        return;\r\n      }\r\n      if (x < 0 || Number.isNaN(x)) {\r\n        x = adjacentCells.first;\r\n      }\r\n      if (y > last) {\r\n        y = last;\r\n      }\r\n      if (y < 0 || Number.isNaN(y)) {\r\n        y = 0;\r\n      }\r\n      if (x > cols) {\r\n        x = adjacentCells.last;\r\n      }\r\n      // TODO - most likley some column order related bugs in key based selection\r\n      // Arrows\r\n      if (e.shiftKey && [37, 38, 39, 40].indexOf(e.keyCode) !== -1) {\r\n        self.selections[Math.max(y, 0)] = self.selections[Math.max(y, 0)] || [];\r\n        self.selections[Math.max(y, 0)].push(x);\r\n        self.selectionBounds = self.getSelectionBounds();\r\n        self.selectArea(undefined, ctrl);\r\n        self.draw(true);\r\n      }\r\n      if (x !== self.activeCell.columnIndex || y !== self.activeCell.rowIndex) {\r\n        self.scrollIntoView(\r\n          x !== self.activeCell.columnIndex ? x : undefined,\r\n          y !== self.activeCell.rowIndex && !Number.isNaN(y) ? y : undefined\r\n        );\r\n\r\n        self.setActiveCell(x, y);\r\n        if (!e.shiftKey && self.attributes.selectionFollowsActiveCell) {\r\n          if (!ctrl) {\r\n            self.selections = [];\r\n          }\r\n          self.selections[y] = self.selections[y] || [];\r\n          self.selections[y].push(x);\r\n          ev = {\r\n            selectedData: self.getSelectedData(),\r\n            selections: self.selections,\r\n            selectionBounds: self.getSelectionBounds()\r\n          };\r\n          Object.defineProperty(ev, 'selectedData', {\r\n            get: function () {\r\n              return self.getSelectedData();\r\n            }\r\n          });\r\n          self.dispatchEvent('selectionchanged', ev);\r\n        }\r\n        self.draw(true);\r\n      }\r\n    };\r\n    self.keyup = function (e) {\r\n      if (self.dispatchEvent('keyup', { NativeEvent: e, cell: self.currentCell })) { return; }\r\n      if (!self.hasFocus) {\r\n        return;\r\n      }\r\n    };\r\n    self.keypress = function (e) {\r\n      if (!self.hasFocus) {\r\n        return;\r\n      }\r\n      if (self.dispatchEvent('keypress', { NativeEvent: e, cell: self.currentCell })) { return; }\r\n    };\r\n    self.dblclick = function (e) {\r\n      if (self.dispatchEvent('dblclick', { NativeEvent: e, cell: self.currentCell })) { return; }\r\n      if (!self.hasFocus) {\r\n        return;\r\n      }\r\n      if (self.currentCell.context === 'ew-resize'\r\n        && self.currentCell.style === 'columnHeaderCell') {\r\n        self.fitColumnToValues(self.currentCell.header.name);\r\n      } else if (self.currentCell.context === 'ew-resize'\r\n        && self.currentCell.style === 'cornerCell') {\r\n        self.autosize();\r\n      } else if (['cell', 'activeCell'].indexOf(self.currentCell.style) !== -1) {\r\n        self.beginEditAt(self.currentCell.columnIndex, self.currentCell.rowIndex);\r\n      }\r\n    };\r\n    self.scrollWheel = function (e) {\r\n      var l,\r\n        t,\r\n        ev = e,\r\n        deltaX = e.deltaX === undefined ? e.NativeEvent.deltaX : e.deltaX,\r\n        deltaY = e.deltaY === undefined ? e.NativeEvent.deltaY : e.deltaY,\r\n        deltaMode = e.deltaMode === undefined ? e.NativeEvent.deltaMode : e.deltaMode;\r\n      if (wheeling) {\r\n        return;\r\n      }\r\n      if (self.dispatchEvent('wheel', { NativeEvent: e })) {\r\n        return;\r\n      }\r\n      var e = e.NativeEvent || e;\r\n      self.touchHaltAnimation = true;\r\n      l = self.scrollBox.scrollLeft;\r\n      t = self.scrollBox.scrollTop;\r\n      if (self.hasFocus) {\r\n        //BUG Issue 42: https://github.com/TonyGermaneri/canvas-datagrid/issues/42\r\n        //https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\r\n        if (deltaMode === 1) {\r\n          // line mode = 17 pixels per line\r\n          deltaY = deltaY * 17;\r\n        }\r\n        if ((self.scrollBox.scrollTop < self.scrollBox.scrollHeight && deltaY > 0)\r\n          || (self.scrollBox.scrollLeft < self.scrollBox.scrollWidth && deltaX > 0)\r\n          || (self.scrollBox.scrollTop > 0 && deltaY < 0)\r\n          || (self.scrollBox.scrollLeft > 0 && deltaX < 0)) {\r\n          ev.preventDefault(e);\r\n        }\r\n        wheeling = setTimeout(function () {\r\n          wheeling = undefined;\r\n          self.scrollBox.scrollTo(deltaX + l, deltaY + t);\r\n        }, 1);\r\n      }\r\n    };\r\n    self.pasteItem = function (clipData, x, y, mimeType) {\r\n      var l, s = self.getVisibleSchema(), yi = y - 1, sel = [];\r\n      function normalizeRowData(importingRow, existingRow, offsetX, schema, mimeType, rowIndex) {\r\n        var r = existingRow;\r\n        if (!Array.isArray(importingRow) && importingRow !== null && typeof importingRow === 'object') {\r\n          importingRow = Object.keys(importingRow).map(function (colKey) {\r\n            return importingRow[colKey];\r\n          });\r\n        }\r\n        if (/^text\\/html/.test(mimeType)) {\r\n          importingRow = importingRow.substring(4, importingRow.length - 5).split('</td><td>');\r\n        }\r\n        if (typeof importingRow === 'string') {\r\n          importingRow = [importingRow];\r\n        }\r\n        sel[rowIndex] = [];\r\n        importingRow.forEach(function (cellData, colIndex) {\r\n          var cName = schema[colIndex + offsetX].name;\r\n          if (importingRow[colIndex] === undefined || importingRow[colIndex] === null) {\r\n            r[cName] = existingRow[cName];\r\n            return;\r\n          }\r\n          sel[rowIndex].push(colIndex + offsetX);\r\n          r[cName] = importingRow[colIndex];\r\n        });\r\n        return r;\r\n      }\r\n      if (/^text\\/html/.test(mimeType)) {\r\n        if (!/^(<meta[^>]+>)?<table>/.test(clipData.substring(0, 29))) {\r\n          console.warn('Unrecognized HTML format.  HTML must be a simple table, e.g.: <table><tr><td>data</td></tr></table>.  Data with the mime type text/html not in this format will not be imported as row data.');\r\n          return;\r\n        }\r\n        // strip table beginning and ending off, then split at rows\r\n        clipData = clipData.substring(clipData.indexOf('<table><tr>') + 11, clipData.length - 13).split('</tr><tr>');\r\n        // ditch any headers on the table\r\n        clipData = clipData.filter(function (row) {\r\n          return !/^<th>|^<thead>/.test(row);\r\n        });\r\n      } else {\r\n        clipData = clipData.split('\\n');\r\n      }\r\n      l = clipData.length;\r\n      clipData.forEach(function (rowData) {\r\n        yi += 1;\r\n        var i = self.orders.rows[yi];\r\n        self.data[i] = normalizeRowData(rowData, self.data[i], x, s, mimeType, i);\r\n      });\r\n      self.selections = sel;\r\n      return l;\r\n    };\r\n    self.getNextVisibleColumnIndex = function (visibleColumnIndex) {\r\n      var x, s = self.getVisibleSchema();\r\n      for (x = 0; x < s.length; x += 1) {\r\n        if (s[x].columnIndex === visibleColumnIndex) {\r\n          return s[x + 1].columnIndex;\r\n        }\r\n      }\r\n      return -1;\r\n    };\r\n    self.getVisibleColumnIndexOf = function (columnIndex) {\r\n      var x, s = self.getVisibleSchema();\r\n      for (x = 0; x < s.length; x += 1) {\r\n        if (s[x].columnIndex === columnIndex) {\r\n          return x;\r\n        }\r\n      }\r\n      return -1;\r\n    };\r\n    self.paste = function (e) {\r\n      var d;\r\n      function getItem(dti) {\r\n        var type = dti.type;\r\n        dti.getAsString(function (s) {\r\n          self.pasteItem(s, self.getVisibleColumnIndexOf(self.activeCell.columnIndex), self.activeCell.rowIndex, type);\r\n          self.draw();\r\n        });\r\n      }\r\n      d = Array.prototype.filter.call(e.clipboardData.items, function (dti) {\r\n        return dti.type === 'text/html';\r\n      })[0] || Array.prototype.filter(function (dti) {\r\n        return dti.type === 'text/csv';\r\n      })[0] || Array.prototype.filter(function (dti) {\r\n        return dti.type === 'text/plain';\r\n      })[0];\r\n      if (!d) {\r\n        console.warn('Cannot find supported clipboard data type.  Supported types are text/html, text/csv, text/plain.');\r\n        return;\r\n      }\r\n      getItem(d);\r\n    };\r\n    self.cut = function (e) {\r\n      self.copy(e);\r\n      self.forEachSelectedCell(function (data, index, colName) {\r\n        data[index][colName] = '';\r\n      });\r\n    };\r\n    self.copy = function (e) {\r\n      if (self.dispatchEvent('copy', { NativeEvent: e })) { return; }\r\n      if (!self.hasFocus || !e.clipboardData) { return; }\r\n      var t,\r\n        d,\r\n        data = (self.data || []),\r\n        tableRows = [],\r\n        textRows = [],\r\n        outputHeaders = {},\r\n        outputHeaderKeys,\r\n        sData = self.getSelectedData(),\r\n        s = self.getSchema();\r\n      function htmlSafe(v) {\r\n        return v.replace(/</g, '&lt;').replace(/>/g, '&gt;');\r\n      }\r\n      function fCopyCell(v) {\r\n        v = v === null || v === undefined ? '' : v;\r\n        return '<td>' + (typeof v === 'string' ? htmlSafe(v) : v) + '</td>';\r\n      }\r\n      function addHeaders(headers, useHtml) {\r\n        if (!s.length || headers.length < 2) { return ''; }\r\n        var h = [];\r\n        if (useHtml) {\r\n          h.push('<tr>');\r\n        }\r\n        s.forEach(function (column, columnIndex) {\r\n          // intentional redefinition of column\r\n          column = s[self.orders.columns[columnIndex]];\r\n          if (!column.hidden && headers.indexOf(column.name) !== -1) {\r\n            var ev = { NativeEvent: e, column: column };\r\n            if (self.dispatchEvent('copyonschema', ev)) {\r\n              column = ev.column;\r\n            }\r\n\r\n            var hVal = (column.name || column.title) || '';\r\n            if (useHtml) {\r\n              h.push('<th>' + htmlSafe(hVal) + '</th>');\r\n            } else {\r\n              h.push('\"' + hVal.replace(/\"/g, '\"\"') + '\"');\r\n            }\r\n          }\r\n        });\r\n        h.push(useHtml ? '</tr>' : '\\n');\r\n        return h.join(useHtml ? '' : ',');\r\n      }\r\n      function addCellValue(val, trRow, textRow, column) {\r\n        // escape strings\r\n        if (val !== null\r\n          && val !== false\r\n          && val !== undefined\r\n          && val.replace) {\r\n          trRow.push(fCopyCell(val));\r\n          textRow.push('\"' + val.replace(/\"/g, '\"\"') + '\"');\r\n          return;\r\n        }\r\n        if (val !== undefined) {\r\n          textRow.push(val);\r\n          trRow.push(fCopyCell(val));\r\n          return;\r\n        }\r\n        // issue #66\r\n        textRow.push('');\r\n        trRow.push('<td>&nbsp;</td>');\r\n      }\r\n      if (sData.length > 0) {\r\n        sData.forEach(function (row) {\r\n          var rowKeys = Object.keys(row);\r\n          if (row) {\r\n            var trRow = [],\r\n              textRow = [],\r\n              sSorted = [];\r\n            // HACK: https://github.com/TonyGermaneri/canvas-datagrid/issues/181\r\n            // I can't use sort here or O(1), so hacks\r\n            s.forEach(function (column, columnIndex) {\r\n              sSorted.push(s[self.orders.columns[columnIndex]]);\r\n            });\r\n            sSorted.forEach(function (column, columnIndex) {\r\n              if (rowKeys.indexOf(column.name) !== -1) {\r\n                outputHeaders[column.name] = true;\r\n                // escape strings\r\n                addCellValue(row[column.name], trRow, textRow, column);\r\n              }\r\n            });\r\n            tableRows.push(trRow.join(''));\r\n            textRows.push(textRow.join(','));\r\n          }\r\n        });\r\n        outputHeaderKeys = Object.keys(outputHeaders);\r\n        t = addHeaders(outputHeaderKeys) + textRows.join('\\n');\r\n        d = '<table>' + addHeaders(outputHeaderKeys, true) + '<tr>' + tableRows.join('</tr><tr>') + '</tr></table>';\r\n        if (outputHeaderKeys.length === 1) {\r\n          // if there was only one cell selected, remove the quotes from the string\r\n          t = t.substring(1, t.length - 1);\r\n        }\r\n        e.clipboardData.setData('text/html', d);\r\n        e.clipboardData.setData('text/plain', t);\r\n        e.clipboardData.setData('text/csv', t);\r\n        e.clipboardData.setData('application/json', JSON.stringify(sData));\r\n        e.preventDefault();\r\n      }\r\n    };\r\n    return;\r\n  };\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true, plusplus: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\r\n    'use strict';\r\n    return function (self) {\r\n        var touchTimerMs = 50,\r\n            debounceTouchMove,\r\n            touchMoving,\r\n            touchScrollTimeout;\r\n        self.scrollAnimation = {};\r\n        self.touchDelta = {};\r\n        self.touchAnimateTo = {};\r\n        self.animationFrames = 0;\r\n        self.getTouchPos = function (e, touchIndex) {\r\n            var t = touchIndex ? e.touches[touchIndex] : e.touches[0],\r\n                rect = self.canvas.getBoundingClientRect(),\r\n                pos;\r\n            if (!t) { return; }\r\n            pos = {\r\n                x: t.clientX - rect.left,\r\n                y: t.clientY - rect.top\r\n            };\r\n            if (self.isChildGrid) {\r\n                pos.x -= self.canvasOffsetLeft;\r\n                pos.y -= self.canvasOffsetTop;\r\n            }\r\n            return {\r\n                x: pos.x,\r\n                y: pos.y,\r\n                rect: rect\r\n            };\r\n        };\r\n        // shamelessly stolen from from https://gist.github.com/gre/1650294\r\n        self.easingFunctions = {\r\n            linear: function (t) { return t; },\r\n            easeInQuad: function (t) { return t * t; },\r\n            easeOutQuad: function (t) { return t * (2 - t); },\r\n            easeInOutQuad: function (t) { return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t; },\r\n            easeInCubic: function (t) { return t * t * t; },\r\n            easeOutCubic: function (t) { return (--t) * t * t + 1; },\r\n            easeInOutCubic: function (t) { return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1; },\r\n            easeInQuart: function (t) { return t * t * t * t; },\r\n            easeOutQuart: function (t) { return 1 - (--t) * t * t * t; },\r\n            easeInOutQuart: function (t) { return t < 0.5 ? 8 * t  * t  * t * t : 1 - 8 * (--t) * t * t * t; },\r\n            easeInQuint: function (t) { return t * t * t * t * t; },\r\n            easeOutQuint: function (t) { return 1 + (--t) * t *  t * t * t; },\r\n            easeInOutQuint: function (t) { return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t; }\r\n        };\r\n        self.easing = function (t, b, c, d) {\r\n            return c * self.easingFunctions[self.attributes.touchEasingMethod](t / d) + b;\r\n        };\r\n        self.calculatePPSTimed = function () {\r\n            self.xPPST = -((self.touchDelta.x - self.touchSigmaTimed.x) / (self.touchDelta.t - self.touchSigmaTimed.t));\r\n            self.yPPST = -((self.touchDelta.y - self.touchSigmaTimed.y) / (self.touchDelta.t - self.touchSigmaTimed.t));\r\n            self.touchSigmaTimed = {\r\n                x: self.touchDelta.x,\r\n                y: self.touchDelta.y,\r\n                t: performance.now()\r\n            };\r\n        };\r\n        self.calculatePPS = function () {\r\n            self.xPPS = -((self.touchDelta.x - self.touchSigma.x) / (self.touchDelta.t - self.touchSigma.t));\r\n            self.yPPS = -((self.touchDelta.y - self.touchSigma.y) / (self.touchDelta.t - self.touchSigma.t));\r\n            self.touchSigma = {\r\n                x: self.touchDelta.x,\r\n                y: self.touchDelta.y,\r\n                t: performance.now()\r\n            };\r\n        };\r\n        self.touchEndAnimation = function () {\r\n            if (!self.canvas || !self.scrollBox.scrollTo) { return requestAnimationFrame(self.touchEndAnimation); }\r\n            var n = performance.now(),\r\n                d = self.attributes.touchReleaseAnimationDurationMs,\r\n                t;\r\n            t = n - self.touchDelta.t;\r\n            self.animationFrames += 1;\r\n            self.scrollAnimation.x = self.easing(t, self.touchDelta.scrollLeft, self.touchAnimateTo.x, d);\r\n            self.scrollAnimation.y = self.easing(t, self.touchDelta.scrollTop, self.touchAnimateTo.y, d);\r\n            if (t > d || (self.scrollAnimation.y === self.scrollBox.scrollTop\r\n                    && self.scrollAnimation.x === self.scrollBox.scrollLeft) || self.stopAnimation) {\r\n                return;\r\n            }\r\n            self.scrollBox.scrollTo(self.scrollAnimation.x, self.scrollAnimation.y);\r\n            requestAnimationFrame(self.touchEndAnimation);\r\n        };\r\n        self.touchEditCell = function (cell) {\r\n            self.beginEditAt(cell.columnIndex, cell.rowIndex);\r\n        };\r\n        self.touchCell = function (e) {\r\n            return function () {\r\n                clearInterval(self.calculatePPSTimer);\r\n                var i, pos = self.getTouchPos(e);\r\n                if (Math.abs(self.touchDelta.x) + Math.abs(self.touchDelta.y) < self.attributes.touchDeadZone) {\r\n                    i = self.getCellAt(pos.x, pos.y);\r\n                    if (!i) { return; }\r\n                    if (self.touchingCell && self.touchingCell.rowIndex === i.rowIndex\r\n                            && self.touchingCell.columnIndex === i.columnIndex) {\r\n                        self.touchEditCell(i);\r\n                        return;\r\n                    }\r\n                    if (self.input && self.input.editCell) {\r\n                        self.endEdit();\r\n                    }\r\n                    self.touchingCell = i;\r\n                    self.selectArea({\r\n                        top: i.rowIndex,\r\n                        bottom: i.rowIndex,\r\n                        left: i.columnIndex,\r\n                        right: i.columnIndex\r\n                    });\r\n                    self.draw(true);\r\n                }\r\n            };\r\n        };\r\n        self.touchstart = function (e) {\r\n            if (e.changedTouches[0]) {\r\n                self.touchStart = self.getTouchPos(e);\r\n                self.startingCell = self.getCellAt(self.touchStart.x, self.touchStart.y, true);\r\n            }\r\n            if (self.dispatchEvent('touchstart', {NativeEvent: e, cell: self.startingCell})) { return; }\r\n            self.disposeContextMenu();\r\n            clearInterval(self.calculatePPSTimer);\r\n            clearTimeout(self.touchContextTimeout);\r\n            self.touchStartEvent = e;\r\n            self.stopAnimation = true;\r\n            self.animationFrames = 0;\r\n            self.stopPropagation(e);\r\n            e.preventDefault();\r\n            if (e.touches.length === 1 && e.changedTouches[0] && !self.zoomAltered) {\r\n                self.touchLength = 1;\r\n                self.touchStart = self.touchStart || self.touchStart1;\r\n                self.touchScrollStart = {\r\n                    x: self.scrollBox.scrollLeft,\r\n                    y: self.scrollBox.scrollTop,\r\n                    t: performance.now()\r\n                };\r\n                self.touchDelta = {\r\n                    x: 0,\r\n                    y: 0,\r\n                    scrollLeft: self.scrollBox.scrollLeft,\r\n                    scrollTop: self.scrollBox.scrollTop,\r\n                    t: self.touchScrollStart.t\r\n                };\r\n                self.touchSigma = {\r\n                    x: self.touchDelta.x,\r\n                    y: self.touchDelta.y,\r\n                    t: self.touchDelta.t\r\n                };\r\n                self.touchSigmaTimed = {\r\n                    x: self.touchDelta.x,\r\n                    y: self.touchDelta.y,\r\n                    t: self.touchDelta.t\r\n                };\r\n                self.touchContextTimeout = setTimeout(function () {\r\n                    self.contextmenuEvent(e, self.touchStart);\r\n                }, self.attributes.touchContextMenuTimeMs);\r\n                self.calculatePPSTimer = setInterval(self.calculatePPSTimed, touchTimerMs);\r\n                if (self.startingCell && (self.startingCell.isGrid || ['tree', 'inherit'].indexOf(self.startingCell.context) !== -1)) {\r\n                    self.hasFocus = false;\r\n                    return;\r\n                }\r\n                self.hasFocus = true;\r\n                if (self.startingCell.isHeader) {\r\n                    if (self.startingCell.isRowHeader) {\r\n                        self.selectArea({\r\n                            top: self.startingCell.rowIndex,\r\n                            bottom: self.startingCell.rowIndex,\r\n                            left: 0,\r\n                            right: self.getVisibleSchema().length - 1,\r\n                        });\r\n                        self.draw(true);\r\n                    } else if (self.startingCell.isColumnHeader) {\r\n                        if (self.attributes.columnHeaderClickBehavior === 'sort') {\r\n                            if (self.orderBy === self.startingCell.header.name) {\r\n                                self.orderDirection = self.orderDirection === 'asc' ? 'desc' : 'asc';\r\n                            } else {\r\n                                self.orderDirection = 'asc';\r\n                            }\r\n                            self.order(self.startingCell.header.name, self.orderDirection);\r\n                        }\r\n                        if (self.attributes.columnHeaderClickBehavior === 'select') {\r\n                            self.selectArea({\r\n                                top: 0,\r\n                                bottom: self.data.length - 1,\r\n                                left: self.startingCell.columnIndex,\r\n                                right: self.startingCell.columnIndex,\r\n                            });\r\n                            self.draw(true);\r\n                        }\r\n                    }\r\n                    self.touchEndEvents(e);\r\n                    return;\r\n                }\r\n            }\r\n            if (self.zoomAltered) { return; }\r\n            document.body.addEventListener('touchmove', self.touchmove, {passive: false});\r\n            document.body.addEventListener('touchend', self.touchend, false);\r\n            document.body.addEventListener('touchcancel', self.touchcancel, false);\r\n            self.draw(true);\r\n        };\r\n        self.touchSelect = function (cell, handleType) {\r\n            if (cell.rowIndex === undefined || cell.columnIndex === undefined) { return; }\r\n            self.touchSelecting = true;\r\n            var bounds = self.getSelectionBounds();\r\n            if (handleType === 'selection-handle-bl'\r\n                    && cell.rowIndex >= bounds.top\r\n                    && cell.columnIndex <= bounds.right) {\r\n                bounds.bottom = cell.rowIndex;\r\n                bounds.left = cell.columnIndex;\r\n            } else if (handleType === 'selection-handle-tl'\r\n                    && cell.rowIndex <= bounds.bottom\r\n                    && cell.columnIndex <= bounds.right) {\r\n                bounds.top = cell.rowIndex;\r\n                bounds.left = cell.columnIndex;\r\n            } else if (handleType === 'selection-handle-tr'\r\n                    && cell.rowIndex <= bounds.bottom\r\n                    && cell.columnIndex >= bounds.left) {\r\n                bounds.top = cell.rowIndex;\r\n                bounds.right = cell.columnIndex;\r\n            } else if (handleType === 'selection-handle-br'\r\n                    && cell.rowIndex >= bounds.top\r\n                    && cell.columnIndex >= bounds.left) {\r\n                bounds.bottom = cell.rowIndex;\r\n                bounds.right = cell.columnIndex;\r\n            }\r\n            if (self.attributes.selectionMode === 'row' || cell.rowIndex === -1) {\r\n                bounds.left = 0;\r\n                bounds.right = self.getSchema().length - 1;\r\n            } else {\r\n                bounds.left = Math.max(0, bounds.left);\r\n            }\r\n            self.selectArea(bounds);\r\n            self.draw(true);\r\n        };\r\n        function touchMove(e) {\r\n            var ch, rw, rScrollZone, lScrollZone, bScrollZone, tScrollZone, sbw, t1, t2;\r\n            if (self.dispatchEvent('beforetouchmove', {NativeEvent: e})) { return; }\r\n            clearTimeout(touchScrollTimeout);\r\n            if (e.changedTouches[0]) {\r\n                self.touchPosition = self.getTouchPos(e);\r\n            }\r\n            if (e.changedTouches[1]) {\r\n                self.touchPosition1 = self.getTouchPos(e, 1);\r\n            }\r\n            if (Math.abs(self.touchDelta.x) + Math.abs(self.touchDelta.y) > self.attributes.touchDeadZone) {\r\n                clearTimeout(self.touchContextTimeout);\r\n            }\r\n            if (e.touches.length === 2 && self.touchPosition && self.touchPosition1) {\r\n                t1 = self.touchPosition.y;\r\n                t2 = self.touchPosition1.y;\r\n                if (!self.zoomDeltaStart) {\r\n                    self.zoomDeltaStart = Math.abs(t1 - t2);\r\n                    self.startScale = self.scale;\r\n                }\r\n                self.touchLength = 2;\r\n                self.scaleDelta = self.zoomDeltaStart - Math.abs(t1 - t2);\r\n                self.scale = self.startScale - (self.scaleDelta * self.attributes.touchZoomSensitivity);\r\n                self.scale = Math.min(Math.max(self.scale, self.attributes.touchZoomMin), self.attributes.touchZoomMax);\r\n                self.zoomAltered = true;\r\n                self.resize(true);\r\n                self.resizeChildGrids();\r\n                return;\r\n            }\r\n            if (self.zoomAltered) { return; }\r\n            self.touchLength = 1;\r\n            self.touchPosition = self.touchPosition || self.touchPosition1;\r\n            ch = self.getColumnHeaderCellHeight();\r\n            rw = self.getRowHeaderCellWidth();\r\n            rScrollZone = self.width - self.style.scrollBarWidth - self.touchPosition.x < self.attributes.selectionScrollZone;\r\n            lScrollZone = self.touchPosition.x - rw < self.attributes.selectionScrollZone;\r\n            bScrollZone = self.height - self.style.scrollBarWidth - self.touchPosition.y < self.attributes.selectionScrollZone;\r\n            tScrollZone = self.touchPosition.y - ch < self.attributes.selectionScrollZone;\r\n            sbw = self.style.scrollBarWidth;\r\n            function touchScroll() {\r\n                var x = self.scrollBox.scrollLeft,\r\n                    y = self.scrollBox.scrollTop;\r\n                x += (rScrollZone ? self.attributes.selectionScrollIncrement : 0);\r\n                y += (bScrollZone ? self.attributes.selectionScrollIncrement : 0);\r\n                y -= (tScrollZone ? self.attributes.selectionScrollIncrement : 0);\r\n                x -= (lScrollZone ? self.attributes.selectionScrollIncrement : 0);\r\n                self.scrollBox.scrollTo(x, y);\r\n                touchScrollTimeout = setTimeout(touchScroll, self.attributes.scrollRepeatRate);\r\n            }\r\n            e.stopPropagation();\r\n            self.touchDelta = {\r\n                x: self.touchPosition.x - self.touchStart.x,\r\n                y: self.touchPosition.y - self.touchStart.y,\r\n                scrollLeft: self.scrollBox.scrollLeft,\r\n                scrollTop: self.scrollBox.scrollTop,\r\n                t: performance.now()\r\n            };\r\n            self.currentCell = self.getCellAt(self.touchPosition.x, self.touchPosition.y);\r\n            self.dispatchEvent('touchmove', {NativeEvent: e, cell: self.currentCell});\r\n            self.calculatePPS();\r\n            self.touchDuration = performance.now() - self.touchScrollStart.t;\r\n            self.stopAnimation = true;\r\n            self.animationFrames = 0;\r\n            if (self.touchSelecting && (rScrollZone || lScrollZone || tScrollZone || bScrollZone)) {\r\n                touchScroll();\r\n            }\r\n            if (/vertical-scroll-/.test(self.startingCell.style)) {\r\n                self.scrollBox.scrollTop = self.scrollBox.scrollHeight\r\n                    * ((self.touchPosition.y - ch - sbw) / (self.scrollBox.height - sbw - ch));\r\n                return;\r\n            }\r\n            if (/horizontal-scroll-/.test(self.startingCell.style)) {\r\n                self.scrollBox.scrollLeft = self.scrollBox.scrollWidth\r\n                    * ((self.touchPosition.x - rw - sbw) / (self.scrollBox.width - sbw - rw));\r\n                return;\r\n            }\r\n            if (/selection-handle-/.test(self.startingCell.style)) {\r\n                self.touchSelect(self.currentCell, self.startingCell.style);\r\n                return;\r\n            }\r\n            self.scrollBox.scrollTo(self.touchScrollStart.x - self.touchDelta.x,\r\n                self.touchScrollStart.y - self.touchDelta.y);\r\n        };\r\n        self.touchmove = function (e) {\r\n            if (touchMoving) {\r\n                return;\r\n            }\r\n            requestAnimationFrame(function () {\r\n                touchMoving = true;\r\n                touchMove(e);\r\n                touchMoving = false;\r\n            });\r\n        };\r\n        self.touchEndEvents = function (e) {\r\n            self.zoomDeltaStart = undefined;\r\n            self.touchSelecting = false;\r\n            clearInterval(self.touchScrollTimeout);\r\n            clearInterval(self.touchContextTimeout);\r\n            clearInterval(self.calculatePPSTimer);\r\n            e.stopPropagation();\r\n            document.body.removeEventListener('touchmove', self.touchmove, {passive: false});\r\n            document.body.removeEventListener('touchend', self.touchend, false);\r\n            document.body.removeEventListener('touchcancel', self.touchcancel, false);\r\n        };\r\n        self.touchend = function (e) {\r\n            if (self.dispatchEvent('touchend', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            self.zoomDeltaStart = undefined;\r\n            if (e.changedTouches[0]) {\r\n                self.touchPosition = undefined;\r\n            }\r\n            if (e.changedTouches[1]) {\r\n                self.touchPosition1 = undefined;\r\n            }\r\n            if (self.zoomAltered) {\r\n                if (e.touches.length === 0) {\r\n                    self.zoomAltered = false;\r\n                }\r\n                return;\r\n            }\r\n            var dz = Math.abs(self.touchDelta.x) + Math.abs(self.touchDelta.y) < self.attributes.touchDeadZone;\r\n            if (isNaN(self.xPPS)) {\r\n                self.xPPS = 0;\r\n            }\r\n            if (isNaN(self.yPPS)) {\r\n                self.yPPS = 0;\r\n            }\r\n            if (isNaN(self.xPPST)) {\r\n                self.xPPST = 0;\r\n            }\r\n            if (isNaN(self.yPPST)) {\r\n                self.yPPST = 0;\r\n            }\r\n            self.touchAnimateTo.x = self.xPPS * self.attributes.touchReleaseAcceleration;\r\n            self.touchAnimateTo.y = self.yPPS * self.attributes.touchReleaseAcceleration;\r\n            self.calculatePPSTimed();\r\n            if (dz && !self.contextMenu) {\r\n                self.touchCell(self.touchStartEvent)();\r\n            } else if (self.animationFrames === 0\r\n                    && (Math.abs(self.xPPST) > self.attributes.scrollAnimationPPSThreshold\r\n                        || Math.abs(self.yPPST) > self.attributes.scrollAnimationPPSThreshold)\r\n                    && !/-scroll-/.test(self.startingCell.style)\r\n                    && !dz) {\r\n                self.stopAnimation = false;\r\n                self.touchEndAnimation();\r\n            }\r\n            self.touchEndEvents(e);\r\n        };\r\n        self.touchcancel = function (e) {\r\n            if (self.dispatchEvent('touchcancel', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            self.touchEndEvents(e);\r\n        };\r\n    };\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals HTMLElement: false, Reflect: false, define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\r\n  'use strict';\r\n  return function (self, ctor) {\r\n    self.scale = 1;\r\n    self.orders = {\r\n      rows: [],\r\n      columns: []\r\n    };\r\n    self.appliedInlineStyles = {};\r\n    self.cellGridAttributes = {};\r\n    self.treeGridAttributes = {};\r\n    self.visibleRowHeights = [];\r\n    self.hasFocus = false;\r\n    self.activeCell = {\r\n      columnIndex: 0,\r\n      rowIndex: 0\r\n    };\r\n    self.innerHTML = '';\r\n    self.storageName = 'canvasDataGrid';\r\n    self.invalidSearchExpClass = 'canvas-datagrid-invalid-search-regExp';\r\n    self.localStyleLibraryStorageKey = 'canvas-datagrid-user-style-library';\r\n    self.dataType = 'application/x-canvas-datagrid';\r\n    self.orderBy = null;\r\n    self.orderDirection = 'asc';\r\n    self.orderings = {\r\n      columns: [],\r\n      add: function (orderBy, orderDirection, sortFunction) {\r\n        self.orderings.columns = self.orderings.columns.filter(function (col) {\r\n          return col.orderBy !== orderBy;\r\n        });\r\n        self.orderings.columns.push({\r\n          orderBy: orderBy,\r\n          orderDirection: orderDirection,\r\n          sortFunction: sortFunction\r\n        });\r\n      },\r\n      sort: function () {\r\n        self.orderings.columns.forEach(function (col) {\r\n          self.data.sort(col.sortFunction(col.orderBy, col.orderDirection));\r\n        });\r\n      }\r\n    };\r\n    self.columnFilters = {};\r\n    self.filters = {};\r\n    self.frozenRow = 0;\r\n    self.frozenColumn = 0;\r\n    self.ellipsisCache = {};\r\n    self.scrollCache = { x: [], y: [] };\r\n    self.scrollBox = {};\r\n    self.visibleRows = [];\r\n    self.visibleCells = [];\r\n    self.sizes = {\r\n      rows: {},\r\n      columns: {},\r\n      trees: {}\r\n    };\r\n    self.currentFilter = function () {\r\n      return true;\r\n    };\r\n    self.selections = [];\r\n    self.hovers = {};\r\n    self.attributes = {};\r\n    self.style = {};\r\n    self.formatters = {};\r\n    self.sorters = {};\r\n    self.parsers = {};\r\n    self.schemaHashes = {};\r\n    self.events = {};\r\n    self.changes = [];\r\n    self.scrollIndexTop = 0;\r\n    self.scrollPixelTop = 0;\r\n    self.scrollIndexLeft = 0;\r\n    self.scrollPixelLeft = 0;\r\n    self.childGrids = {};\r\n    self.openChildren = {};\r\n    self.scrollModes = [\r\n      'vertical-scroll-box',\r\n      'vertical-scroll-top',\r\n      'vertical-scroll-bottom',\r\n      'horizontal-scroll-box',\r\n      'horizontal-scroll-right',\r\n      'horizontal-scroll-left'\r\n    ];\r\n    self.componentL1Events = {};\r\n    self.eventNames = ['afterdraw', 'afterrendercell', 'attributechanged', 'beforebeginedit',\r\n      'beforecreatecellgrid', 'beforedraw', 'beforeendedit', 'beforerendercell', 'beforerendercellgrid',\r\n      'beginedit', 'cellmouseout', 'cellmouseover', 'click', 'collapsetree', 'contextmenu', 'copy',\r\n      'datachanged', 'dblclick', 'endedit', 'expandtree', 'formatcellvalue', 'keydown', 'keypress',\r\n      'keyup', 'mousedown', 'mousemove', 'mouseup', 'newrow', 'ordercolumn', 'rendercell', 'rendercellgrid',\r\n      'renderorderbyarrow', 'rendertext', 'rendertreearrow', 'reorder', 'reordering', 'resize',\r\n      'resizecolumn', 'resizerow', 'schemachanged', 'scroll', 'selectionchanged', 'stylechanged',\r\n      'touchcancel', 'touchend', 'touchmove', 'touchstart', 'wheel'];\r\n    self.mouse = { x: 0, y: 0 };\r\n    self.getSelectedData = function (expandToRow) {\r\n      var d = [], s = self.getSchema(), l = self.data.length;\r\n      if (l === 0) { return []; }\r\n      self.selections.forEach(function (row, index) {\r\n        if (!row) { return; }\r\n        if (index === l) { return; }\r\n        if (row.length === 0) {\r\n          d[index] = null;\r\n          return;\r\n        }\r\n        d[index] = {};\r\n        row.forEach(function (col) {\r\n          var orderedIndex;\r\n          if (col === -1 || !s[col]) { return; }\r\n          orderedIndex = self.orders.columns[col];\r\n          if (!expandToRow && s[orderedIndex].hidden) { return; }\r\n          if (self.data[index]) {\r\n            d[index][s[orderedIndex].name] = self.data[index][s[orderedIndex].name];\r\n          }\r\n        });\r\n      });\r\n      return d;\r\n    };\r\n    self.getColumnHeaderCellHeight = function () {\r\n      if (!self.attributes.showColumnHeaders) { return 0; }\r\n      return ((self.sizes.rows[-1] || self.style.columnHeaderCellHeight) * self.scale);\r\n    };\r\n    self.getRowHeaderCellWidth = function () {\r\n      if (!self.attributes.showRowHeaders) { return 0; }\r\n      return (self.sizes.columns[-1] || self.style.rowHeaderCellWidth) * self.scale;\r\n    };\r\n    self.setStorageData = function () {\r\n      if (!self.attributes.saveAppearance || !self.attributes.name) { return; }\r\n      var visibility = {};\r\n      self.getSchema().forEach(function (column) {\r\n        visibility[column.name] = !column.hidden;\r\n      });\r\n      localStorage.setItem(self.storageName + '-' + self.attributes.name, JSON.stringify({\r\n        sizes: {\r\n          rows: self.sizes.rows,\r\n          columns: self.sizes.columns\r\n        },\r\n        orders: {\r\n          rows: self.orders.rows,\r\n          columns: self.orders.columns\r\n        },\r\n        orderBy: self.orderBy,\r\n        orderDirection: self.orderDirection,\r\n        visibility: visibility\r\n      }));\r\n    };\r\n    self.getSchema = function () {\r\n      return self.schema || self.tempSchema || [];\r\n    };\r\n    function fillArray(low, high) {\r\n      var i = [], x;\r\n      for (x = low; x <= high; x += 1) {\r\n        i[x] = x;\r\n      }\r\n      return i;\r\n    }\r\n    self.createColumnOrders = function () {\r\n      var s = self.getSchema();\r\n      self.orders.columns = fillArray(0, s.length - 1);\r\n    };\r\n    self.createRowOrders = function () {\r\n      self.orders.rows = fillArray(0, self.data.length - 1);\r\n    };\r\n    self.getVisibleSchema = function () {\r\n      return self.getSchema().filter(function (col) {\r\n        return !col.hidden;\r\n      });\r\n    };\r\n    self.applyDefaultValue = function (row, header) {\r\n      var d = header.defaultValue || '';\r\n      if (typeof d === 'function') {\r\n        d = d.apply(self.intf, [header]);\r\n      }\r\n      row[header.name] = d;\r\n    };\r\n    self.createNewRowData = function () {\r\n      self.newRow = {};\r\n      self.getSchema().forEach(function forEachHeader(header) {\r\n        self.applyDefaultValue(self.newRow, header);\r\n      });\r\n    };\r\n    self.getSchemaNameHash = function (key) {\r\n      var n = 0;\r\n      while (self.schemaHashes[key]) {\r\n        n += 1;\r\n        key = key + n;\r\n      }\r\n      return key;\r\n    };\r\n    self.filter = function (type) {\r\n      var f = self.filters[type];\r\n      if (!f && type !== undefined) {\r\n        console.warn('Cannot find filter for type %s, falling back to substring match.', type);\r\n        f = self.filters.string;\r\n      }\r\n      return f;\r\n    };\r\n    self.applyFilter = function () {\r\n      self.refreshFromOrigialData();\r\n      Object.keys(self.columnFilters).forEach(function (filter) {\r\n        var header = self.getHeaderByName(filter);\r\n        if (!header) {\r\n          return;\r\n        }\r\n        self.currentFilter = header.filter || self.filter(header.type || 'string');\r\n        self.data = self.data.filter(function (row) {\r\n          return self.currentFilter(row[filter], self.columnFilters[filter]);\r\n        });\r\n      });\r\n      self.resize();\r\n      self.draw(true);\r\n    };\r\n    self.applyDataTransforms = function () {\r\n      self.applyFilter();\r\n      self.orderings.sort();\r\n    }\r\n    self.getBestGuessDataType = function (columnName, data) {\r\n      var t, x, l = data.length;\r\n      for (x = 0; x < l; x += 1) {\r\n        if (data[x] !== undefined && data[x] !== null && [null, undefined].indexOf(data[x][columnName]) !== -1) {\r\n          t = typeof data[x];\r\n          return t === 'object' ? 'string' : t;\r\n        }\r\n      }\r\n      return 'string';\r\n    };\r\n    self.drawChildGrids = function () {\r\n      Object.keys(self.childGrids).forEach(function (gridKey) {\r\n        self.childGrids[gridKey].draw();\r\n      });\r\n    };\r\n    self.resizeChildGrids = function () {\r\n      Object.keys(self.childGrids).forEach(function (gridKey) {\r\n        self.childGrids[gridKey].resize();\r\n      });\r\n    };\r\n    self.autoScrollZone = function (e, x, y, ctrl) {\r\n      var setTimer,\r\n        rowHeaderCellWidth = self.getRowHeaderCellWidth(),\r\n        columnHeaderCellHeight = self.getColumnHeaderCellHeight();\r\n      if (y !== -1) {\r\n        if (x > self.width - self.attributes.selectionScrollZone && x < self.width) {\r\n          self.scrollBox.scrollLeft += self.attributes.selectionScrollIncrement;\r\n          setTimer = true;\r\n        }\r\n        if (x - self.attributes.selectionScrollZone - rowHeaderCellWidth < 0) {\r\n          self.scrollBox.scrollLeft -= self.attributes.selectionScrollIncrement;\r\n          setTimer = true;\r\n        }\r\n      }\r\n      if (y !== -1) {\r\n        if (y > self.height - self.attributes.selectionScrollZone && y < self.height) {\r\n          self.scrollBox.scrollTop += self.attributes.selectionScrollIncrement;\r\n          setTimer = true;\r\n        }\r\n        if (y - self.attributes.selectionScrollZone - columnHeaderCellHeight < 0) {\r\n          self.scrollBox.scrollTop -= self.attributes.selectionScrollIncrement;\r\n          setTimer = true;\r\n        }\r\n      }\r\n      if (setTimer && !ctrl && self.currentCell && self.currentCell.columnIndex !== -1) {\r\n        self.scrollTimer = setTimeout(self.mousemove, self.attributes.scrollRepeatRate, e);\r\n      }\r\n    };\r\n    self.refreshFromOrigialData = function () {\r\n      self.data = self.originalData.filter(function (row) {\r\n        return true;\r\n      });\r\n    };\r\n    self.validateColumn = function (c, s) {\r\n      if (!c.name) {\r\n        throw new Error('A column must contain at least a name.');\r\n      }\r\n      if (s.filter(function (i) { return i.name === c.name; }).length > 0) {\r\n        throw new Error('A column with the name '\r\n          + c.name + ' already exists and cannot be added again.');\r\n      }\r\n      return true;\r\n    };\r\n    self.setDefaults = function (obj1, obj2, key, def) {\r\n      obj1[key] = obj2[key] === undefined ? def : obj2[key];\r\n    };\r\n    self.setAttributes = function () {\r\n      self.defaults.attributes.forEach(function eachAttribute(i) {\r\n        self.setDefaults(self.attributes, self.args, i[0], i[1]);\r\n      });\r\n    };\r\n    self.setStyle = function () {\r\n      self.defaults.styles.forEach(function eachStyle(i) {\r\n        self.setDefaults(self.style, self.args.style || {}, i[0], i[1]);\r\n      });\r\n    };\r\n    self.autosize = function (colName) {\r\n      self.getVisibleSchema().forEach(function (col, colIndex) {\r\n        if (col.name === colName || colName === undefined) {\r\n          self.sizes.columns[colIndex]\r\n            = Math.max(self.findColumnMaxTextLength(col.name), self.style.minColumnWidth);\r\n        }\r\n      });\r\n      self.sizes.columns[-1] = self.findColumnMaxTextLength('cornerCell');\r\n    };\r\n    self.dispose = function () {\r\n      if (!self.isChildGrid && self.canvas && self.canvas.parentNode) {\r\n        self.canvas.parentNode.removeChild(self.canvas);\r\n      }\r\n      if (!self.isChildGrid) {\r\n        document.body.removeChild(self.controlInput)\r\n      }\r\n      self.eventParent.removeEventListener('mouseup', self.mouseup, false);\r\n      self.eventParent.removeEventListener('mousedown', self.mousedown, false);\r\n      self.eventParent.removeEventListener('dblclick', self.dblclick, false);\r\n      self.eventParent.removeEventListener('click', self.click, false);\r\n      self.eventParent.removeEventListener('mousemove', self.mousemove);\r\n      self.eventParent.removeEventListener('wheel', self.scrollWheel, false);\r\n      self.canvas.removeEventListener('contextmenu', self.contextmenu, false);\r\n      self.canvas.removeEventListener('copy', self.copy);\r\n      self.controlInput.removeEventListener('copy', self.copy);\r\n      self.controlInput.removeEventListener('cut', self.cut);\r\n      self.controlInput.removeEventListener('paste', self.paste);\r\n      self.controlInput.removeEventListener('keypress', self.keypress, false);\r\n      self.controlInput.removeEventListener('keyup', self.keyup, false);\r\n      self.controlInput.removeEventListener('keydown', self.keydown, false);\r\n      window.removeEventListener('resize', self.resize);\r\n      if (self.observer && self.observer.disconnect) {\r\n        self.observer.disconnect();\r\n      }\r\n    };\r\n    self.tryLoadStoredSettings = function () {\r\n      var s;\r\n      self.reloadStoredValues();\r\n      if (self.storedSettings\r\n        && typeof self.storedSettings.orders === 'object'\r\n        && self.storedSettings.orders !== null) {\r\n        if (self.storedSettings.orders.rows.length >= (self.data || []).length) {\r\n          self.orders.rows = self.storedSettings.orders.rows;\r\n        }\r\n        s = self.getSchema();\r\n        if (self.storedSettings.orders.columns.length === s.length) {\r\n          self.orders.columns = self.storedSettings.orders.columns;\r\n        }\r\n        self.orderBy = self.storedSettings.orderBy === undefined\r\n          ? s[0].name : self.storedSettings.orderBy;\r\n        self.orderDirection = self.storedSettings.orderDirection === undefined\r\n          ? 'asc' : self.storedSettings.orderDirection;\r\n        if (self.storedSettings.orderBy !== undefined && self.getHeaderByName(self.orderBy) && self.orderDirection) {\r\n          self.order(self.orderBy, self.orderDirection);\r\n        }\r\n      }\r\n    };\r\n    self.getDomRoot = function () {\r\n      return self.shadowRoot ? self.shadowRoot.host : self.parentNode;\r\n    };\r\n    self.getFontName = function (fontStyle) {\r\n      return fontStyle.replace(/\\d+\\.?\\d*px/, '');\r\n    };\r\n    self.getFontHeight = function (fontStyle) {\r\n      return parseFloat(fontStyle, 10);\r\n    };\r\n    self.parseStyleValue = function (key) {\r\n      if (/Font/.test(key)) {\r\n        self.style[key + 'Height'] = self.getFontHeight(self.style[key]);\r\n        self.style[key + 'Name'] = self.getFontName(self.style[key]);\r\n        return;\r\n      }\r\n      // when inheriting styles from already instantiated grids, don't parse already parsed values.\r\n      if (key === 'moveOverlayBorderSegments' && typeof self.style[key] === 'string') {\r\n        self.style[key] = self.style[key].split(',')\r\n          .map(function (i) { return parseInt(i, 10); });\r\n      }\r\n    };\r\n    self.initProp = function (propName) {\r\n      if (!self.args[propName]) { return; }\r\n      Object.keys(self.args[propName]).forEach(function (key) {\r\n        self[propName][key] = self.args[propName][key];\r\n      });\r\n    };\r\n    self.getStyleProperty = function (key) {\r\n      if (self.styleKeys.indexOf(key) === -1) {\r\n        return self.parentNodeStyle[key];\r\n      }\r\n      return self.style[key];\r\n    };\r\n    self.setStyleProperty = function (key, value, supressDrawAndEvent) {\r\n      var isDim = ['height', 'width', 'minHeight', 'minWidth', 'maxHeight', 'maxWidth'].indexOf(key) !== -1;\r\n      if (self.styleKeys.indexOf(key) === -1) {\r\n        self.parentNodeStyle[key] = value;\r\n      } else {\r\n        if (/-/.test(key)) {\r\n          key = self.dehyphenateProperty(key);\r\n        }\r\n        self.style[key] = value;\r\n        self.parseStyleValue(key);\r\n      }\r\n      if (isDim) {\r\n        self.resize();\r\n      }\r\n      if (!supressDrawAndEvent) {\r\n        self.draw(true);\r\n        self.dispatchEvent('stylechanged', { name: 'style', value: value });\r\n      }\r\n    };\r\n    self.reloadStoredValues = function () {\r\n      if (self.attributes.name && self.attributes.saveAppearance) {\r\n        try {\r\n          self.storedSettings = localStorage.getItem(self.storageName + '-' + self.attributes.name);\r\n        } catch (e) {\r\n          console.warn(\"Error loading stored values. \" + e.message);\r\n          self.storedSettings = undefined;\r\n        }\r\n        if (self.storedSettings) {\r\n          try {\r\n            self.storedSettings = JSON.parse(self.storedSettings);\r\n          } catch (e) {\r\n            console.warn('could not read settings from localStore', e);\r\n            self.storedSettings = undefined;\r\n          }\r\n        }\r\n        if (self.storedSettings) {\r\n          if (typeof self.storedSettings.sizes === 'object'\r\n            && self.storedSettings.sizes !== null) {\r\n            self.sizes.rows = self.storedSettings.sizes.rows;\r\n            self.sizes.columns = self.storedSettings.sizes.columns;\r\n            ['trees', 'columns', 'rows'].forEach(function (i) {\r\n              if (!self.sizes[i]) {\r\n                self.sizes[i] = {};\r\n              }\r\n            });\r\n          }\r\n          if (typeof self.storedSettings.visibility === 'object') {\r\n            self.getSchema().forEach(function (column) {\r\n              if (self.storedSettings.visibility && self.storedSettings.visibility[column.name] !== undefined) {\r\n                column.hidden = !self.storedSettings.visibility[column.name];\r\n              }\r\n            });\r\n          }\r\n        }\r\n      }\r\n    };\r\n    self.init = function () {\r\n      if (self.initialized) { return; }\r\n      function addStyleKeyIfNoneExists(key) {\r\n        if (self.styleKeys.indexOf(key) === -1) {\r\n          self.styleKeys.push(key);\r\n        }\r\n      }\r\n      var publicStyleKeyIntf = {};\r\n      self.setAttributes();\r\n      self.setStyle();\r\n      self.initScrollBox();\r\n      self.setDom();\r\n      self.nodeType = 'canvas-datagrid';\r\n      self.ie = /Trident/.test(window.navigator.userAgent);\r\n      self.edge = /Edge/.test(window.navigator.userAgent);\r\n      self.webKit = /WebKit/.test(window.navigator.userAgent);\r\n      self.moz = /Gecko/.test(window.navigator.userAgent);\r\n      self.mobile = /Mobile/i.test(window.navigator.userAgent);\r\n      self.cursorGrab = 'move';\r\n      self.cursorGrabing = 'move';\r\n      self.cursorGrab = self.webKit ? 'move' : self.cursorGrab;\r\n      self.cursorGrabing = self.moz ? 'move' : self.cursorGrabbing;\r\n      self.pointerLockPosition = { x: 0, y: 0 };\r\n      Object.keys(self.style).forEach(self.parseStyleValue);\r\n      self.intf.moveSelection = self.moveSelection;\r\n      self.intf.moveTo = self.moveTo;\r\n      self.intf.addEventListener = self.addEventListener;\r\n      self.intf.removeEventListener = self.removeEventListener;\r\n      self.intf.dispatchEvent = self.dispatchEvent;\r\n      /**\r\n       * Releases grid resources and removes grid elements.\r\n       * @memberof canvasDatagrid\r\n       * @name dispose\r\n       * @method\r\n       */\r\n      self.intf.dispose = self.dispose;\r\n      /**\r\n       * Appends the grid to another element later.  Not implemented.\r\n       * @memberof canvasDatagrid\r\n       * @name appendTo\r\n       * @method\r\n       * @param {number} el The element to append the grid to.\r\n       */\r\n      self.intf.appendTo = self.appendTo;\r\n      self.intf.getVisibleCellByIndex = self.getVisibleCellByIndex;\r\n      self.intf.filters = self.filters;\r\n      self.intf.sorters = self.sorters;\r\n      self.intf.autosize = self.autosize;\r\n      self.intf.beginEditAt = self.beginEditAt;\r\n      self.intf.endEdit = self.endEdit;\r\n      self.intf.setActiveCell = self.setActiveCell;\r\n      self.intf.forEachSelectedCell = self.forEachSelectedCell;\r\n      self.intf.scrollIntoView = self.scrollIntoView;\r\n      self.intf.clearChangeLog = self.clearChangeLog;\r\n      self.intf.gotoCell = self.gotoCell;\r\n      self.intf.gotoRow = self.gotoRow;\r\n      self.intf.getHeaderByName = self.getHeaderByName;\r\n      self.intf.findColumnScrollLeft = self.findColumnScrollLeft;\r\n      self.intf.findRowScrollTop = self.findRowScrollTop;\r\n      self.intf.fitColumnToValues = self.fitColumnToValues;\r\n      self.intf.findColumnMaxTextLength = self.findColumnMaxTextLength;\r\n      self.intf.disposeContextMenu = self.disposeContextMenu;\r\n      self.intf.getCellAt = self.getCellAt;\r\n      self.intf.isCellVisible = self.isCellVisible;\r\n      self.intf.isRowVisible = self.isRowVisible;\r\n      self.intf.isColumnVisible = self.isColumnVisible;\r\n      self.intf.order = self.order;\r\n      self.intf.draw = self.draw;\r\n      self.intf.isComponent = self.isComponent;\r\n      self.intf.selectArea = self.selectArea;\r\n      self.intf.clipElement = self.clipElement;\r\n      self.intf.getSchemaFromData = self.getSchemaFromData;\r\n      self.intf.setFilter = self.setFilter;\r\n      self.intf.selectRow = self.selectRow;\r\n      self.intf.parentGrid = self.parentGrid;\r\n      self.intf.toggleTree = self.toggleTree;\r\n      self.intf.expandTree = self.expandTree;\r\n      self.intf.collapseTree = self.collapseTree;\r\n      self.intf.canvas = self.canvas;\r\n      self.intf.context = self.ctx;\r\n      self.intf.insertRow = self.insertRow;\r\n      self.intf.deleteRow = self.deleteRow;\r\n      self.intf.addRow = self.addRow;\r\n      self.intf.insertColumn = self.insertColumn;\r\n      self.intf.deleteColumn = self.deleteColumn;\r\n      self.intf.addColumn = self.addColumn;\r\n      self.intf.getClippingRect = self.getClippingRect;\r\n      self.intf.setRowHeight = self.setRowHeight;\r\n      self.intf.setColumnWidth = self.setColumnWidth;\r\n      self.intf.resetColumnWidths = self.resetColumnWidths;\r\n      self.intf.resetRowHeights = self.resetRowHeights;\r\n      self.intf.resize = self.resize;\r\n      self.intf.selectColumn = self.selectColumn;\r\n      self.intf.selectRow = self.selectRow;\r\n      self.intf.selectAll = self.selectAll;\r\n      self.intf.selectNone = self.selectNone;\r\n      self.intf.drawChildGrids = self.drawChildGrids;\r\n      self.intf.assertPxColor = self.assertPxColor;\r\n      self.intf.clearPxColorAssertions = self.clearPxColorAssertions;\r\n      self.intf.integerToAlpha = self.integerToAlpha;\r\n      self.intf.copy = self.copy;\r\n      self.intf.setStyleProperty = self.setStyleProperty;\r\n      Object.defineProperty(self.intf, 'defaults', {\r\n        get: function () {\r\n          return {\r\n            styles: self.defaults.styles.reduce(function (a, i) { a[i[0]] = i[1]; return a; }, {}),\r\n            attributes: self.defaults.attributes.reduce(function (a, i) { a[i[0]] = i[1]; return a; }, {})\r\n          };\r\n        }\r\n      });\r\n      self.styleKeys = Object.keys(self.intf.defaults.styles);\r\n      self.styleKeys.map(function (i) { return self.hyphenateProperty(i, false); }).forEach(addStyleKeyIfNoneExists);\r\n      self.styleKeys.map(function (i) { return self.hyphenateProperty(i, true); }).forEach(addStyleKeyIfNoneExists);\r\n      self.DOMStyles = window.getComputedStyle(document.body, null);\r\n      self.styleKeys.concat(Object.keys(self.DOMStyles)).forEach(function (key) {\r\n        // unless this line is here, Object.keys() will not work on <instance>.style\r\n        publicStyleKeyIntf[key] = undefined;\r\n        Object.defineProperty(publicStyleKeyIntf, key, {\r\n          get: function () {\r\n            return self.getStyleProperty(key);\r\n          },\r\n          set: function (value) {\r\n            if (self.initialized) {\r\n              self.appliedInlineStyles[key] = value;\r\n            }\r\n            self.setStyleProperty(key, value);\r\n          }\r\n        });\r\n      });\r\n      Object.defineProperty(self.intf, 'shadowRoot', {\r\n        get: function () {\r\n          return self.shadowRoot;\r\n        }\r\n      });\r\n      Object.defineProperty(self.intf, 'activeCell', {\r\n        get: function () {\r\n          return self.activeCell;\r\n        }\r\n      });\r\n      Object.defineProperty(self.intf, 'hasFocus', {\r\n        get: function () {\r\n          return self.hasFocus;\r\n        }\r\n      });\r\n      Object.defineProperty(self.intf, 'style', {\r\n        get: function () {\r\n          return publicStyleKeyIntf;\r\n        },\r\n        set: function (valueObject) {\r\n          Object.keys(valueObject).forEach(function (key) {\r\n            self.setStyleProperty(key, valueObject[key], true);\r\n          });\r\n          self.draw(true);\r\n          self.dispatchEvent('stylechanged', { name: 'style', value: valueObject });\r\n        }\r\n      });\r\n      Object.defineProperty(self.intf, 'attributes', { value: {} });\r\n      Object.keys(self.attributes).forEach(function (key) {\r\n        Object.defineProperty(self.intf.attributes, key, {\r\n          get: function () {\r\n            return self.attributes[key];\r\n          },\r\n          set: function (value) {\r\n            self.attributes[key] = value;\r\n            if (key === 'name') {\r\n              self.tryLoadStoredSettings();\r\n            }\r\n            self.draw(true);\r\n            self.dispatchEvent('attributechanged', { name: key, value: value[key] });\r\n          }\r\n        });\r\n      });\r\n      self.filters.string = function (value, filterFor) {\r\n        value = String(value);\r\n        var filterRegExp,\r\n          regEnd = /\\/(i|g|m)*$/,\r\n          pattern = regEnd.exec(filterFor),\r\n          flags = pattern ? pattern[0].substring(1) : '',\r\n          flagLength = flags.length;\r\n        self.invalidFilterRegEx = undefined;\r\n        if (filterFor.substring(0, 1) === '/' && pattern) {\r\n          try {\r\n            filterRegExp = new RegExp(filterFor.substring(1, filterFor.length - (flagLength + 1)), flags);\r\n          } catch (e) {\r\n            self.invalidFilterRegEx = e;\r\n            return;\r\n          }\r\n          return filterRegExp.test(value);\r\n        }\r\n        return value.toString ? value.toString().toLocaleUpperCase()\r\n          .indexOf(filterFor.toLocaleUpperCase()) !== -1 : false;\r\n      };\r\n      self.filters.number = function (value, filterFor) {\r\n        if (!filterFor) { return true; }\r\n        return value === filterFor;\r\n      };\r\n      ['formatters', 'filters', 'sorters'].forEach(self.initProp);\r\n      self.applyComponentStyle(false, self.intf);\r\n      self.reloadStoredValues();\r\n      if (self.args.data) {\r\n        self.intf.data = self.args.data;\r\n      }\r\n      if (self.intf.innerText || self.intf.textContent) {\r\n        if (self.intf.dataType === 'application/x-canvas-datagrid') {\r\n          self.intf.dataType = 'application/json+x-canvas-datagrid';\r\n        }\r\n        self.intf.data = self.intf.innerText || self.intf.textContent;\r\n      }\r\n      if (self.args.schema) {\r\n        self.intf.schema = self.args.schema;\r\n      }\r\n      if (self.isChildGrid || !self.isComponent) {\r\n        requestAnimationFrame(function () { self.resize(true); });\r\n      } else {\r\n        self.resize(true);\r\n      }\r\n      self.initialized = true;\r\n      return self;\r\n    };\r\n    /**\r\n     * Removes focus from the grid.\r\n     * @memberof canvasDatagrid\r\n     * @name blur\r\n     * @method\r\n     */\r\n    self.intf.blur = function (e) {\r\n      self.hasFocus = false;\r\n    };\r\n    /**\r\n     * Focuses on the grid.\r\n     * @memberof canvasDatagrid\r\n     * @name focus\r\n     * @method\r\n     */\r\n    self.intf.focus = function () {\r\n      self.hasFocus = true;\r\n      self.controlInput.focus();\r\n    };\r\n    if (self.shadowRoot || self.isChildGrid) {\r\n      Object.defineProperty(self.intf, 'height', {\r\n        get: function () {\r\n          if (self.shadowRoot) {\r\n            return self.shadowRoot.height;\r\n          }\r\n          return self.parentNode.height;\r\n        },\r\n        set: function (value) {\r\n          if (self.shadowRoot) {\r\n            self.shadowRoot.height = value;\r\n          } else {\r\n            self.parentNode.height = value;\r\n          }\r\n          self.resize(true);\r\n        }\r\n      });\r\n      Object.defineProperty(self.intf, 'width', {\r\n        get: function () {\r\n          if (self.shadowRoot) {\r\n            return self.shadowRoot.width;\r\n          }\r\n          return self.parentNode.width;\r\n        },\r\n        set: function (value) {\r\n          if (self.shadowRoot) {\r\n            self.shadowRoot.width = value;\r\n          } else {\r\n            self.parentNode.width = value;\r\n          }\r\n          self.resize(true);\r\n        }\r\n      });\r\n      Object.defineProperty(self.intf, 'parentNode', {\r\n        get: function () {\r\n          return self.parentNode;\r\n        },\r\n        set: function (value) {\r\n          if (!self.isChildGrid) {\r\n            throw new TypeError('Cannot set property parentNode which has only a getter');\r\n          }\r\n          self.parentNode = value;\r\n        }\r\n      });\r\n    }\r\n    Object.defineProperty(self.intf, 'visibleRowHeights', {\r\n      get: function () {\r\n        return self.visibleRowHeights;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'openChildren', {\r\n      get: function () {\r\n        return self.openChildren;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'childGrids', {\r\n      get: function () {\r\n        return Object.keys(self.childGrids).map(function (gridId) {\r\n          return self.childGrids[gridId];\r\n        });\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'isChildGrid', {\r\n      get: function () {\r\n        return self.isChildGrid;\r\n      }\r\n    });\r\n    Object.defineProperty(self, 'cursor', {\r\n      get: function () {\r\n        return self.parentNodeStyle.cursor;\r\n      },\r\n      set: function (value) {\r\n        if (value === 'cell') { value = 'default'; }\r\n        if (self.currentCursor !== value) {\r\n          self.parentNodeStyle.cursor = value;\r\n          self.currentCursor = value;\r\n        }\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'orderDirection', {\r\n      get: function () {\r\n        return self.orderDirection;\r\n      },\r\n      set: function (value) {\r\n        if (value !== 'desc') {\r\n          value = 'asc';\r\n        }\r\n        self.orderDirection = value;\r\n        self.order(self.orderBy, self.orderDirection);\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'orderBy', {\r\n      get: function () {\r\n        return self.orderBy;\r\n      },\r\n      set: function (value) {\r\n        if (self.getSchema().find(function (col) {\r\n          return col.name === value;\r\n        }) === undefined) {\r\n          throw new Error('Cannot sort by unknown column name.');\r\n        }\r\n        self.orderBy = value;\r\n        self.order(self.orderBy, self.orderDirection);\r\n      }\r\n    });\r\n    if (self.isComponent) {\r\n      Object.defineProperty(self.intf, 'offsetHeight', {\r\n        get: function () {\r\n          return self.canvas.offsetHeight;\r\n        }\r\n      });\r\n      Object.defineProperty(self.intf, 'offsetWidth', {\r\n        get: function () {\r\n          return self.canvas.offsetWidth;\r\n        }\r\n      });\r\n    }\r\n    Object.defineProperty(self.intf, 'scrollHeight', {\r\n      get: function () {\r\n        return self.scrollBox.scrollHeight;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'scrollWidth', {\r\n      get: function () {\r\n        return self.scrollBox.scrollWidth;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'scrollTop', {\r\n      get: function () {\r\n        return self.scrollBox.scrollTop;\r\n      },\r\n      set: function (value) {\r\n        self.scrollBox.scrollTop = value;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'scrollLeft', {\r\n      get: function () {\r\n        return self.scrollBox.scrollLeft;\r\n      },\r\n      set: function (value) {\r\n        self.scrollBox.scrollLeft = value;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'sizes', {\r\n      get: function () {\r\n        return self.sizes;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'parentDOMNode', {\r\n      get: function () {\r\n        return self.parentDOMNode;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'input', {\r\n      get: function () {\r\n        return self.input;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'controlInput', {\r\n      get: function () {\r\n        return self.controlInput;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'currentCell', {\r\n      get: function () {\r\n        return self.currentCell;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'visibleCells', {\r\n      get: function () {\r\n        return self.visibleCells;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'visibleRows', {\r\n      get: function () {\r\n        return self.visibleRows;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'selections', {\r\n      get: function () {\r\n        return self.selections;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'dragMode', {\r\n      get: function () {\r\n        return self.dragMode;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'changes', {\r\n      get: function () {\r\n        return self.changes;\r\n      }\r\n    });\r\n    self.intf.formatters = self.formatters;\r\n    Object.defineProperty(self.intf, 'dataType', {\r\n      get: function () {\r\n        return self.dataType;\r\n      },\r\n      set: function (value) {\r\n        if (!self.parsers[value]) {\r\n          throw new Error('No parser for MIME type ' + value);\r\n        }\r\n        self.dataType = value;\r\n      }\r\n    });\r\n    self.eventNames.forEach(function (eventName) {\r\n      Object.defineProperty(self.intf, 'on' + eventName, {\r\n        get: function () {\r\n          return self.componentL1Events[eventName];\r\n        },\r\n        set: function (value) {\r\n          self.events[eventName] = [];\r\n          self.componentL1Events[eventName] = value;\r\n          if (!value) { return; }\r\n          self.addEventListener(eventName, value);\r\n        }\r\n      });\r\n    });\r\n    Object.defineProperty(self.intf, 'frozenRow', {\r\n      get: function () {\r\n        return self.frozenRow;\r\n      },\r\n      set: function (val) {\r\n        if (isNaN(val)) {\r\n          throw new TypeError('Expected value for frozenRow to be a number.');\r\n        }\r\n        if (self.visibleRows.length < val) {\r\n          throw new RangeError('Cannot set a value larger than the number of visible rows.');\r\n        }\r\n        self.frozenRow = val;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'frozenColumn', {\r\n      get: function () {\r\n        return self.frozenColumn;\r\n      },\r\n      set: function (val) {\r\n        if (isNaN(val)) {\r\n          throw new TypeError('Expected value for frozenRow to be a number.');\r\n        }\r\n        if (self.getVisibleSchema().length < val) {\r\n          throw new RangeError('Cannot set a value larger than the number of visible columns.');\r\n        }\r\n        self.frozenColumn = val;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'scrollIndexRect', {\r\n      get: function () {\r\n        return {\r\n          top: self.scrollIndexTop,\r\n          right: self.scrollIndexRight,\r\n          bottom: self.scrollIndexBottom,\r\n          left: self.scrollIndexLeft\r\n        };\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'scrollPixelRect', {\r\n      get: function () {\r\n        return {\r\n          top: self.scrollPixelTop,\r\n          right: self.scrollPixelRight,\r\n          bottom: self.scrollPixelBottom,\r\n          left: self.scrollPixelLeft\r\n        };\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'rowOrder', {\r\n      get: function () {\r\n        return self.orders.rows;\r\n      },\r\n      set: function (val) {\r\n        if (!Array.isArray(val)) {\r\n          throw new TypeError('Value must be an array.');\r\n        }\r\n        if (!self.data || val.length < self.data.length) {\r\n          throw new RangeError('Array length must be equal to or greater than number of rows.');\r\n        }\r\n        self.orders.rows = val;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'columnOrder', {\r\n      get: function () {\r\n        return self.orders.columns;\r\n      },\r\n      set: function (val) {\r\n        if (!Array.isArray(val)) {\r\n          throw new TypeError('Value must be an array.');\r\n        }\r\n        if (val.length < self.getSchema().length) {\r\n          throw new RangeError('Array length must be equal to or greater than number of columns.');\r\n        }\r\n        self.orders.columns = val;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'selectionBounds', {\r\n      get: function () {\r\n        return self.getSelectionBounds();\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'selectedRows', {\r\n      get: function () {\r\n        return self.getSelectedData(true);\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'selectedCells', {\r\n      get: function () {\r\n        return self.getSelectedData();\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'visibleSchema', {\r\n      get: function () {\r\n        return self.getVisibleSchema().map(function eachDataRow(col) {\r\n          return col;\r\n        });\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'treeGridAttributes', {\r\n      get: function () {\r\n        return self.treeGridAttributes;\r\n      },\r\n      set: function setTreeGridAttributes(value) {\r\n        self.treeGridAttributes = value;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'cellGridAttributes', {\r\n      get: function () {\r\n        return self.cellGridAttributes;\r\n      },\r\n      set: function setCellGridAttributes(value) {\r\n        self.cellGridAttributes = value;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'ctx', {\r\n      get: function () {\r\n        return self.ctx;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'schema', {\r\n      get: function schemaGetter() {\r\n        return self.getSchema();\r\n      },\r\n      set: function schemaSetter(value) {\r\n        if (value === undefined) {\r\n          // Issue #89 - allow schema to be set to initialized state\r\n          self.schema = undefined;\r\n          self.tempSchema = undefined;\r\n          self.dispatchEvent('schemachanged', { schema: undefined });\r\n          return;\r\n        }\r\n        if (!Array.isArray(value) || typeof value[0] !== 'object') {\r\n          throw new Error('Schema must be an array of objects.');\r\n        }\r\n        if (value[0].name === undefined) {\r\n          throw new Error('Expected schema to contain an object with at least a name property.');\r\n        }\r\n        self.schema = value.map(function eachSchemaColumn(column, index) {\r\n          column.width = column.width || self.style.cellWidth;\r\n          column.filter = column.filter || self.filter(column.type);\r\n          column.type = column.type || 'string';\r\n          column.index = index;\r\n          column.columnIndex = index;\r\n          column.rowIndex = -1;\r\n          return column;\r\n        });\r\n        self.tempSchema = undefined;\r\n        self.createNewRowData();\r\n        self.createColumnOrders();\r\n        self.tryLoadStoredSettings();\r\n        if (self.storedSettings && typeof self.storedSettings.visibility === 'object') {\r\n          self.schema.forEach(function hideEachSchemaColumn(column, index) {\r\n            if (self.storedSettings && self.storedSettings.visibility[column.name] !== undefined) {\r\n              column.hidden = !self.storedSettings.visibility[column.name];\r\n            }\r\n          });\r\n        }\r\n        self.resize(true);\r\n        self.dispatchEvent('schemachanged', { schema: self.schema });\r\n      }\r\n    });\r\n    /**\r\n     * Gets an array of currently registered MIME types.\r\n     * @memberof canvasDatagrid\r\n     * @name getDataTypes\r\n     * @method\r\n     */\r\n    self.intf.getTypes = function () {\r\n      return Object.keys(self.parsers);\r\n    };\r\n    self.parseInnerHtml = function (data) {\r\n      if (!data || /^ +$/.test(data)) {\r\n        return [];\r\n      }\r\n      try {\r\n        data = JSON.parse(data);\r\n      } catch (e) {\r\n        console.warn(Error('Cannot parse application/json+x-canvas-datagrid formated data. '\r\n          + e.message + '  \\nNote: canvas-datagrid.innerHTML is for string data only.  '\r\n          + 'Use the canvas-datagrid.data property to set object data.'));\r\n      }\r\n      return data;\r\n    };\r\n    self.parsers['application/json+x-canvas-datagrid'] = function (data, callback) {\r\n      self.parsers['application/x-canvas-datagrid'](self.parseInnerHtml(data), function (data, schema) {\r\n        return callback(data, schema);\r\n      });\r\n    };\r\n    self.parsers['application/x-canvas-datagrid'] = function (data, callback) {\r\n      return callback(data);\r\n    };\r\n    self.intf.parsers = self.parsers;\r\n    // send to dataType ETL function to extract from input data\r\n    // and transform into native [{}, {}] format\r\n    self.etl = function (data, callback) {\r\n      if (!self.intf.parsers[self.dataType]) {\r\n        throw new Error('Unsupported data type.');\r\n      }\r\n      self.intf.parsers[self.dataType](data, function (data, schema) {\r\n        if (Array.isArray(schema)) {\r\n          self.schema = schema;\r\n        }\r\n        // Issue #89 - allow schema to be auto-created every time data is set\r\n        if (self.attributes.autoGenerateSchema) {\r\n          self.schema = self.getSchemaFromData(data);\r\n        }\r\n        if (!self.schema) {\r\n          self.tempSchema = self.getSchemaFromData(data);\r\n        }\r\n        if (self.getSchema()) {\r\n          self.createColumnOrders();\r\n        }\r\n        // set the unfiltered/sorted data array\r\n        self.originalData = data;\r\n        // apply filter, sort, etc to incoming dataset\r\n        self.applyDataTransforms();\r\n        // empty data was set\r\n        if (!self.schema && (self.data || []).length === 0) {\r\n          self.tempSchema = [{ name: '' }];\r\n        }\r\n        self.fitColumnToValues('cornerCell', true);\r\n        if ((self.tempSchema && !self.schema) || self.attributes.autoGenerateSchema) {\r\n          self.createColumnOrders();\r\n          self.dispatchEvent('schemachanged', { schema: self.tempSchema });\r\n        }\r\n        callback();\r\n      });\r\n    };\r\n    Object.defineProperty(self.intf, 'data', {\r\n      get: function dataGetter() {\r\n        return self.data;\r\n      },\r\n      set: function dataSetter(value) {\r\n        self.etl(value, function () {\r\n          self.changes = [];\r\n          self.createNewRowData();\r\n          if (self.attributes.autoResizeColumns && self.data.length > 0\r\n            && self.storedSettings === undefined) {\r\n            self.autosize();\r\n          }\r\n          // set the header column to fit the numbers in it\r\n          self.fitColumnToValues('cornerCell', true);\r\n          self.createRowOrders();\r\n          self.tryLoadStoredSettings();\r\n          self.dispatchEvent('datachanged', { data: self.data });\r\n          self.resize(true);\r\n        });\r\n      }\r\n    });\r\n    self.initScrollBox = function () {\r\n      var sHeight = 0,\r\n        sWidth = 0,\r\n        scrollTop = 0,\r\n        scrollLeft = 0,\r\n        scrollHeight = 0,\r\n        scrollWidth = 0,\r\n        scrollBoxHeight = 20,\r\n        scrollBoxWidth = 20;\r\n      function setScrollTop(value, preventScrollEvent) {\r\n        if (isNaN(value)) {\r\n          throw new Error('ScrollTop value must be a number');\r\n        }\r\n        if (value < 0) {\r\n          value = 0;\r\n        }\r\n        if (value > scrollHeight) {\r\n          value = scrollHeight;\r\n        }\r\n        if (scrollHeight < 0) {\r\n          value = 0;\r\n        }\r\n        scrollTop = value;\r\n        if (!preventScrollEvent) {\r\n          self.scroll();\r\n        }\r\n      }\r\n      function setScrollLeft(value, preventScrollEvent) {\r\n        if (isNaN(value)) {\r\n          throw new Error('ScrollLeft value must be a number');\r\n        }\r\n        if (value < 0) {\r\n          value = 0;\r\n        }\r\n        if (value > scrollWidth) {\r\n          value = scrollWidth;\r\n        }\r\n        if (scrollWidth < 0) {\r\n          value = 0;\r\n        }\r\n        scrollLeft = value;\r\n        if (!preventScrollEvent) {\r\n          self.scroll();\r\n        }\r\n      }\r\n      self.scrollBox.toString = function () {\r\n        return '{\"width\": ' + scrollWidth.toFixed(2)\r\n          + ', \"height\": ' + scrollHeight.toFixed(2)\r\n          + ', \"left\": ' + scrollLeft.toFixed(2)\r\n          + ', \"top\": ' + scrollTop.toFixed(2)\r\n          + ', \"widthRatio\": ' + self.scrollBox.widthBoxRatio.toFixed(5)\r\n          + ', \"heightRatio\": ' + self.scrollBox.heightBoxRatio.toFixed(5) + '}';\r\n      };\r\n      self.scrollBox.scrollTo = function (x, y, supressDrawEvent) {\r\n        setScrollLeft(x, true);\r\n        setScrollTop(y, supressDrawEvent);\r\n      };\r\n      Object.defineProperty(self.scrollBox, 'scrollBoxHeight', {\r\n        get: function () {\r\n          return scrollBoxHeight;\r\n        },\r\n        set: function (value) {\r\n          scrollBoxHeight = value;\r\n        }\r\n      });\r\n      Object.defineProperty(self.scrollBox, 'scrollBoxWidth', {\r\n        get: function () {\r\n          return scrollBoxWidth;\r\n        },\r\n        set: function (value) {\r\n          scrollBoxWidth = value;\r\n        }\r\n      });\r\n      Object.defineProperty(self.scrollBox, 'height', {\r\n        get: function () {\r\n          return sHeight;\r\n        },\r\n        set: function (value) {\r\n          sHeight = value;\r\n        }\r\n      });\r\n      Object.defineProperty(self.scrollBox, 'width', {\r\n        get: function () {\r\n          return sWidth;\r\n        },\r\n        set: function (value) {\r\n          sWidth = value;\r\n        }\r\n      });\r\n      Object.defineProperty(self.scrollBox, 'scrollTop', {\r\n        get: function () {\r\n          return scrollTop;\r\n        },\r\n        set: setScrollTop\r\n      });\r\n      Object.defineProperty(self.scrollBox, 'scrollLeft', {\r\n        get: function () {\r\n          return scrollLeft;\r\n        },\r\n        set: setScrollLeft\r\n      });\r\n      Object.defineProperty(self.scrollBox, 'scrollHeight', {\r\n        get: function () {\r\n          return scrollHeight;\r\n        },\r\n        set: function (value) {\r\n          if (scrollTop > value) {\r\n            scrollTop = Math.max(value, 0);\r\n          }\r\n          scrollHeight = value;\r\n        }\r\n      });\r\n      Object.defineProperty(self.scrollBox, 'scrollWidth', {\r\n        get: function () {\r\n          return scrollWidth;\r\n        },\r\n        set: function (value) {\r\n          if (scrollLeft > value) {\r\n            scrollLeft = Math.max(value, 0);\r\n          }\r\n          scrollWidth = value;\r\n        }\r\n      });\r\n    };\r\n    return;\r\n  };\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false, Event: false*/\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\r\n    'use strict';\r\n    return function (self) {\r\n        var zIndexTop, hoverScrollTimeout, autoCompleteContext;\r\n        function applyContextItemStyle(contextItemContainer) {\r\n            self.createInlineStyle(contextItemContainer, 'canvas-datagrid-context-menu-item' + (self.mobile ? '-mobile' : ''));\r\n            contextItemContainer.addEventListener('mouseover', function () {\r\n                self.createInlineStyle(contextItemContainer, 'canvas-datagrid-context-menu-item:hover');\r\n            });\r\n            contextItemContainer.addEventListener('mouseout', function () {\r\n                self.createInlineStyle(contextItemContainer, 'canvas-datagrid-context-menu-item');\r\n            });\r\n        }\r\n        function createContextMenu(ev, pos, items, parentContextMenu) {\r\n            var container = document.createElement('div'),\r\n                upArrow = document.createElement('div'),\r\n                downArrow = document.createElement('div'),\r\n                children = [],\r\n                selectedIndex = -1,\r\n                intf = {},\r\n                rect;\r\n            if (!Array.isArray(items)) { throw new Error('createContextMenu expects an array.'); }\r\n            function createItems() {\r\n                items.forEach(function (item) {\r\n                    var contextItemContainer = document.createElement('div'),\r\n                        childMenuArrow;\r\n                    function removeChildContext(e) {\r\n                        if (e.relatedTarget === container\r\n                                || item.contextMenu.container === e.relatedTarget\r\n                                || childMenuArrow === e.relatedTarget\r\n                                || (contextItemContainer === e.relatedTarget)\r\n                                || item.contextMenu.container.contains(e.relatedTarget)\r\n                                ) { return; }\r\n                        item.contextMenu.dispose();\r\n                        children.splice(children.indexOf(item.contextMenu), 1);\r\n                        item.contextMenu = undefined;\r\n                        contextItemContainer.removeEventListener('mouseout', removeChildContext);\r\n                        container.removeEventListener('mouseout', removeChildContext);\r\n                        contextItemContainer.setAttribute('contextOpen', '0');\r\n                        contextItemContainer.setAttribute('opening', '0');\r\n                    }\r\n                    function contextAddCallback(items) {\r\n                        // check yet again if the user hasn't moved off\r\n                        if (contextItemContainer.getAttribute('opening') !== '1' ||\r\n                                contextItemContainer.getAttribute('contextOpen') === '1') {\r\n                            return;\r\n                        }\r\n                        var cPos = contextItemContainer.getBoundingClientRect();\r\n                        cPos = {\r\n                            left: cPos.left + self.style.childContextMenuMarginLeft + container.offsetWidth,\r\n                            top: cPos.top + self.style.childContextMenuMarginTop,\r\n                            bottom: cPos.bottom,\r\n                            right: cPos.right\r\n                        };\r\n                        item.contextMenu = createContextMenu(ev, cPos, items, intf);\r\n                        contextItemContainer.setAttribute('contextOpen', '1');\r\n                        contextItemContainer.addEventListener('mouseout', removeChildContext);\r\n                        container.addEventListener('mouseout', removeChildContext);\r\n                        children.push(item.contextMenu);\r\n                    }\r\n                    function createChildContext() {\r\n                        var i;\r\n                        if (contextItemContainer.getAttribute('contextOpen') === '1') {\r\n                            return;\r\n                        }\r\n                        contextItemContainer.setAttribute('opening', '1');\r\n                        if (typeof item.items === 'function') {\r\n                            i  = item.items.apply(intf, [function (items) {\r\n                                contextAddCallback(items);\r\n                            }]);\r\n                            if (i !== undefined && Array.isArray(i)) {\r\n                                contextAddCallback(i);\r\n                            }\r\n                            return;\r\n                        }\r\n                        contextAddCallback(item.items);\r\n                    }\r\n                    function addItem(item) {\r\n                        function addContent(content) {\r\n                            if (content === null) { return; }\r\n                            if (typeof content === 'function') {\r\n                                return addContent(content(ev));\r\n                            }\r\n                            if (typeof content === 'object') {\r\n                                contextItemContainer.appendChild(content);\r\n                                return;\r\n                            }\r\n                            applyContextItemStyle(contextItemContainer);\r\n                            contextItemContainer.innerHTML = content;\r\n                            return;\r\n                        }\r\n                        addContent(item.title);\r\n                        item.contextItemContainer = contextItemContainer;\r\n                        if ((item.items && item.items.length > 0) || typeof item.items === 'function') {\r\n                            childMenuArrow = document.createElement('div');\r\n                            self.createInlineStyle(childMenuArrow, 'canvas-datagrid-context-child-arrow');\r\n                            childMenuArrow.innerHTML = self.style.childContextMenuArrowHTML;\r\n                            contextItemContainer.appendChild(childMenuArrow);\r\n                            contextItemContainer.addEventListener('mouseover', createChildContext);\r\n                            contextItemContainer.addEventListener('mouseout', function () {\r\n                                contextItemContainer.setAttribute('opening', '0');\r\n                            });\r\n                        }\r\n                        if (item.click) {\r\n                            contextItemContainer.addEventListener('click', function (ev) {\r\n                                item.click.apply(self, [ev]);\r\n                            });\r\n                        }\r\n                    }\r\n                    addItem(item);\r\n                    container.appendChild(contextItemContainer);\r\n                });\r\n            }\r\n            function clickIndex(idx) {\r\n                items[idx].contextItemContainer.dispatchEvent(new Event('click'));\r\n            }\r\n            function checkArrowVisibility() {\r\n                if (container.scrollTop > 0) {\r\n                    self.parentDOMNode.appendChild(upArrow);\r\n                } else if (upArrow.parentNode) {\r\n                    upArrow.parentNode.removeChild(upArrow);\r\n                }\r\n                if (container.scrollTop >= container.scrollHeight - container.offsetHeight && downArrow.parentNode) {\r\n                    downArrow.parentNode.removeChild(downArrow);\r\n                } else if (container.scrollHeight - container.offsetHeight > 0\r\n                        && !(container.scrollTop >= container.scrollHeight - container.offsetHeight)) {\r\n                    self.parentDOMNode.appendChild(downArrow);\r\n                }\r\n            }\r\n            function startHoverScroll(type) {\r\n                return function t() {\r\n                    var a = self.attributes.contextHoverScrollAmount;\r\n                    if (type === 'up' && container.scrollTop === 0) { return; }\r\n                    if (type === 'down' && container.scrollTop === container.scrollHeight) { return; }\r\n                    container.scrollTop += (type === 'up' ? -a : a);\r\n                    hoverScrollTimeout = setTimeout(t, self.attributes.contextHoverScrollRateMs, type);\r\n                };\r\n            }\r\n            function endHoverScroll(type) {\r\n                return function () {\r\n                    clearTimeout(hoverScrollTimeout);\r\n                };\r\n            }\r\n            function init() {\r\n                var loc = {},\r\n                    s = self.scrollOffset(self.canvas);\r\n                if (zIndexTop === undefined) {\r\n                    zIndexTop = self.style.contextMenuZIndex;\r\n                }\r\n                createItems();\r\n                self.createInlineStyle(container, 'canvas-datagrid-context-menu' + (self.mobile ? '-mobile' : ''));\r\n                loc.x = pos.left - s.left;\r\n                loc.y = pos.top - s.top;\r\n                loc.height = 0;\r\n                zIndexTop += 1;\r\n                container.style.position = 'absolute';\r\n                upArrow.style.color = self.style.contextMenuArrowColor;\r\n                downArrow.style.color = self.style.contextMenuArrowColor;\r\n                [upArrow, downArrow].forEach(function (el) {\r\n                    el.style.textAlign = 'center';\r\n                    el.style.position = 'absolute';\r\n                    el.style.zIndex = zIndexTop + 1;\r\n                });\r\n                container.style.zIndex = zIndexTop;\r\n                if (parentContextMenu && parentContextMenu.inputDropdown) {\r\n                    container.style.maxHeight = window.innerHeight - loc.y - self.style.autocompleteBottomMargin + 'px';\r\n                    container.style.minWidth = pos.width + 'px';\r\n                    loc.y += pos.height;\r\n                }\r\n                if (self.mobile) {\r\n                    container.style.width = pos.width + 'px';\r\n                }\r\n                container.style.left = loc.x + 'px';\r\n                container.style.top = loc.y + 'px';\r\n                container.addEventListener('scroll', checkArrowVisibility);\r\n                container.addEventListener('wheel', function (e) {\r\n                    if (self.hasFocus) {\r\n                        container.scrollTop += e.deltaY;\r\n                        container.scrollLeft += e.deltaX;\r\n                    }\r\n                    checkArrowVisibility();\r\n                });\r\n                upArrow.innerHTML = self.style.contextMenuArrowUpHTML;\r\n                downArrow.innerHTML = self.style.contextMenuArrowDownHTML;\r\n                container.appendChild(upArrow);\r\n                document.body.appendChild(downArrow);\r\n                document.body.appendChild(container);\r\n                rect = container.getBoundingClientRect();\r\n                // TODO: fix !(parentContextMenu && parentContextMenu.inputDropdown) state (autocomplete)\r\n                if (rect.bottom > window.innerHeight) {\r\n                    if (!(parentContextMenu && parentContextMenu.inputDropdown)) {\r\n                        loc.y -= (rect.bottom + self.style.contextMenuWindowMargin) - window.innerHeight;\r\n                    }\r\n                    if (loc.y < 0) { loc.y = self.style.contextMenuWindowMargin; }\r\n                    if (container.offsetHeight > window.innerHeight - self.style.contextMenuWindowMargin) {\r\n                        container.style.height = window.innerHeight - (self.style.contextMenuWindowMargin * 2) + 'px';\r\n                    }\r\n                }\r\n                if (rect.right > window.innerWidth) {\r\n                    loc.x -= rect.right - window.innerWidth + self.style.contextMenuWindowMargin;\r\n                }\r\n                if (loc.x < 0) { loc.x = self.style.contextMenuWindowMargin; }\r\n                if (loc.y < 0) { loc.y = self.style.contextMenuWindowMargin; }\r\n                container.style.left = loc.x + 'px';\r\n                container.style.top = loc.y + 'px';\r\n                rect = container.getBoundingClientRect();\r\n                upArrow.style.top = rect.top + 'px';\r\n                downArrow.style.top = rect.top + rect.height - downArrow.offsetHeight + 'px';\r\n                upArrow.style.left = rect.left + 'px';\r\n                downArrow.style.left = rect.left + 'px';\r\n                downArrow.style.width = container.offsetWidth + 'px';\r\n                upArrow.style.width = container.offsetWidth + 'px';\r\n                downArrow.addEventListener('mouseover', startHoverScroll('down'));\r\n                downArrow.addEventListener('mouseout', endHoverScroll('down'));\r\n                upArrow.addEventListener('mouseover', startHoverScroll('up'));\r\n                upArrow.addEventListener('mouseout', endHoverScroll('up'));\r\n                checkArrowVisibility();\r\n            }\r\n            intf.parentGrid = self.intf;\r\n            intf.parentContextMenu = parentContextMenu;\r\n            intf.container = container;\r\n            init();\r\n            intf.clickIndex = clickIndex;\r\n            intf.rect = rect;\r\n            intf.items = items;\r\n            intf.upArrow = upArrow;\r\n            intf.downArrow = downArrow;\r\n            intf.dispose = function () {\r\n                clearTimeout(hoverScrollTimeout);\r\n                children.forEach(function (c) {\r\n                    c.dispose();\r\n                });\r\n                [downArrow, upArrow, container].forEach(function (el) {\r\n                    if (el.parentNode) { el.parentNode.removeChild(el); }\r\n                });\r\n            };\r\n            Object.defineProperty(intf, 'selectedIndex', {\r\n                get: function () {\r\n                    return selectedIndex;\r\n                },\r\n                set: function (value) {\r\n                    if (typeof value !== 'number' || isNaN(value || !isFinite(value))) {\r\n                        throw new Error('Context menu selected index must be a sane number.');\r\n                    }\r\n                    selectedIndex = value;\r\n                    if (selectedIndex > items.length - 1) {\r\n                        selectedIndex = items.length - 1;\r\n                    }\r\n                    if (selectedIndex < 0) {\r\n                        selectedIndex = 0;\r\n                    }\r\n                    items.forEach(function (item, index) {\r\n                        if (index === selectedIndex) {\r\n                            return self.createInlineStyle(item.contextItemContainer, 'canvas-datagrid-context-menu-item:hover');\r\n                        }\r\n                        self.createInlineStyle(item.contextItemContainer, 'canvas-datagrid-context-menu-item');\r\n                    });\r\n                }\r\n            });\r\n            return intf;\r\n        }\r\n        function createFilterContextMenuItems(e) {\r\n            var filterContainer = document.createElement('div'),\r\n                filterLabel = document.createElement('div'),\r\n                filterAutoCompleteButton = document.createElement('button'),\r\n                filterInput = document.createElement('input'),\r\n                n = e.cell && e.cell.header ? e.cell.header.title || e.cell.header.name : '',\r\n                autoCompleteItems,\r\n                iRect;\r\n            function checkRegExpErrorState() {\r\n                filterInput.style.background = self.style.contextFilterInputBackground;\r\n                filterInput.style.color = self.style.contextFilterInputColor;\r\n                if (self.invalidFilterRegEx) {\r\n                    filterInput.style.background = self.style.contextFilterInvalidRegExpBackground;\r\n                    filterInput.style.color = self.style.contextFilterInvalidRegExpColor;\r\n                }\r\n            }\r\n            function fillAutoComplete() {\r\n                var count = 0;\r\n                autoCompleteItems = {};\r\n                self.data.forEach(function (row) {\r\n                    var value = row[e.cell.header.name];\r\n                    if (autoCompleteItems[value] || count > self.attributes.maxAutoCompleteItems) { return; }\r\n                    count += 1;\r\n                    autoCompleteItems[value] = {\r\n                        title: self.formatters[e.cell.header.type || 'string']({ cell: { value: value }}),\r\n                        click: function (e) {\r\n                            filterInput.value = value;\r\n                            e.stopPropagation();\r\n                            filterInput.dispatchEvent(new Event('keyup'));\r\n                            self.disposeAutocomplete();\r\n                            return;\r\n                        }\r\n                    };\r\n                });\r\n                autoCompleteItems = Object.keys(autoCompleteItems).map(function (key) {\r\n                    return autoCompleteItems[key];\r\n                });\r\n            }\r\n            function createAutoCompleteContext(ev) {\r\n                if (ev && [40, 38, 13, 9].indexOf(ev.keyCode) !== -1) { return; }\r\n                fillAutoComplete();\r\n                iRect = filterInput.getBoundingClientRect();\r\n                if (autoCompleteContext) {\r\n                    autoCompleteContext.dispose();\r\n                    autoCompleteContext = undefined;\r\n                }\r\n                autoCompleteContext = createContextMenu(e, {\r\n                    left: iRect.left,\r\n                    top: iRect.top,\r\n                    right: iRect.right,\r\n                    bottom: iRect.bottom,\r\n                    height: iRect.height,\r\n                    width: iRect.width\r\n                }, autoCompleteItems, {inputDropdown: true});\r\n                autoCompleteContext.selectedIndex = 0;\r\n            }\r\n            self.createInlineStyle(filterLabel, 'canvas-datagrid-context-menu-label');\r\n            self.createInlineStyle(filterAutoCompleteButton, 'canvas-datagrid-context-menu-filter-button');\r\n            self.createInlineStyle(filterInput, 'canvas-datagrid-context-menu-filter-input');\r\n            checkRegExpErrorState();\r\n            filterInput.onclick = self.disposeAutocomplete;\r\n            filterInput.addEventListener('keydown', function (e) {\r\n                //down\r\n                if (e.keyCode === 40) {\r\n                    autoCompleteContext.selectedIndex += 1;\r\n                }\r\n                //up\r\n                if (e.keyCode === 38) {\r\n                    autoCompleteContext.selectedIndex -= 1;\r\n                }\r\n                //enter\r\n                if (e.keyCode === 13) {\r\n                    autoCompleteContext.clickIndex(autoCompleteContext.selectedIndex);\r\n                    self.disposeContextMenu();\r\n                }\r\n                //tab\r\n                if (e.keyCode === 9) {\r\n                    autoCompleteContext.clickIndex(autoCompleteContext.selectedIndex);\r\n                    e.preventDefault();\r\n                }\r\n                //esc\r\n                if (e.keyCode === 27) {\r\n                    self.disposeContextMenu();\r\n                }\r\n            });\r\n            filterInput.addEventListener('keyup', function () {\r\n                self.setFilter(e.cell.header.name, filterInput.value);\r\n            });\r\n            filterInput.addEventListener('keyup', createAutoCompleteContext);\r\n            ['focus', 'blur', 'keydown', 'keyup', 'change'].forEach(function (en) {\r\n                filterInput.addEventListener(en, checkRegExpErrorState);\r\n            });\r\n            filterInput.value = e.cell.header ? self.columnFilters[e.cell.header.name] || '' : '';\r\n            filterLabel.innerHTML = self.attributes.filterOptionText.replace(/%s/g, n);\r\n            filterAutoCompleteButton.onclick = function () {\r\n                if (autoCompleteContext) {\r\n                    return self.disposeAutocomplete();\r\n                }\r\n                createAutoCompleteContext();\r\n            };\r\n            filterAutoCompleteButton.innerHTML = self.style.contextFilterButtonHTML;\r\n            filterContainer.addEventListener('click', function (e) {\r\n                return e.stopPropagation();\r\n            });\r\n            filterContainer.appendChild(filterLabel);\r\n            filterContainer.appendChild(filterInput);\r\n            filterContainer.appendChild(filterAutoCompleteButton);\r\n            e.items.push({\r\n                title: filterContainer\r\n            });\r\n            if (Object.keys(self.columnFilters).length) {\r\n                Object.keys(self.columnFilters).forEach(function (cf) {\r\n                    var h = self.getHeaderByName(cf);\r\n                    e.items.push({\r\n                        title: self.attributes.removeFilterOptionText.replace(/%s/g, h.title || h.name),\r\n                        click: function removeFilterClick(e) {\r\n                            e.preventDefault();\r\n                            self.setFilter(cf, '');\r\n                            self.controlInput.focus();\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n        }\r\n        function addDefaultContextMenuItem(e) {\r\n            var isNormalCell = !(e.cell.isBackground || e.cell.isColumnHeaderCellCap\r\n                    || e.cell.isScrollBar || e.cell.isCorner || e.cell.isRowHeader)\r\n                    && e.cell.header;\r\n            if (self.attributes.showFilter && isNormalCell) {\r\n                createFilterContextMenuItems(e);\r\n            }\r\n            if (self.attributes.showCopy\r\n                    && self.selections.reduce(function (p, r) {\r\n                        return p + r.length;\r\n                    }, 0) > 0) {\r\n                e.items.push({\r\n                    title: self.attributes.copyText,\r\n                    click: function () {\r\n                        document.execCommand('copy');\r\n                        self.disposeContextMenu();\r\n                        self.controlInput.focus();\r\n                    }\r\n                });\r\n            }\r\n            if (self.attributes.showPaste && self.clipBoardData) {\r\n                e.items.push({\r\n                    title: self.attributes.pasteText,\r\n                    click: function () {\r\n                        self.paste(self.clipBoardData, e.cell.columnIndex, e.cell.rowIndex);\r\n                        self.draw();\r\n                    }\r\n                });\r\n            }\r\n            if (self.attributes.showColumnSelector) {\r\n                e.items.push({\r\n                    title: self.attributes.columnSelectorText,\r\n                    items: function () {\r\n                        var d = [];\r\n                        self.getSchema().forEach(function (column) {\r\n                            function toggleColumnVisibility(e) {\r\n                                column.hidden = !column.hidden;\r\n                                self.dispatchEvent('togglecolumn', {column: column, hidden: column.hidden});\r\n                                e.preventDefault();\r\n                                self.stopPropagation(e);\r\n                                self.disposeContextMenu();\r\n                                self.resize(true);\r\n                                self.setStorageData();\r\n                            }\r\n                            var el = document.createElement('div');\r\n                            applyContextItemStyle(el);\r\n                            el.addEventListener('touchstart', toggleColumnVisibility);\r\n                            el.addEventListener('click', toggleColumnVisibility);\r\n                            el.innerHTML = (column.hidden ? self.attributes.columnSelectorHiddenText\r\n                                    : self.attributes.columnSelectorVisibleText)\r\n                                    + (column.title || column.name);\r\n                            d.push({\r\n                                title: el\r\n                            });\r\n                        });\r\n                        return d;\r\n                    }\r\n                });\r\n                if (e.cell && e.cell.header && e.cell.columnIndex > -1) {\r\n                    e.items.push({\r\n                        title: self.attributes.hideColumnText\r\n                            .replace(/%s/ig, e.cell.header.title || e.cell.header.name),\r\n                        click: function (ev) {\r\n                            self.getSchema()[e.cell.columnIndex].hidden = true;\r\n                            ev.preventDefault();\r\n                            self.stopPropagation(ev);\r\n                            self.disposeContextMenu();\r\n                            self.setStorageData();\r\n                            setTimeout(function () { self.resize(true); }, 10);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            if (self.attributes.saveAppearance && self.attributes.showClearSettingsOption\r\n                    && (Object.keys(self.sizes.rows).length > 0\r\n                        || Object.keys(self.sizes.columns).length > 0)) {\r\n                e.items.push({\r\n                    title: self.attributes.clearSettingsOptionText,\r\n                    click: function (e) {\r\n                        e.preventDefault();\r\n                        self.sizes.rows = {};\r\n                        self.sizes.columns = {};\r\n                        self.createRowOrders();\r\n                        self.createColumnOrders();\r\n                        self.storedSettings = undefined;\r\n                        self.dispatchEvent('resizecolumn', {columnWidth: self.style.cellWidth});\r\n                        self.dispatchEvent('resizerow', {cellHeight: self.style.cellHeight});\r\n                        self.setStorageData();\r\n                        self.resize(true);\r\n                        self.disposeContextMenu();\r\n                        self.controlInput.focus();\r\n                    }\r\n                });\r\n            }\r\n            if (self.attributes.allowSorting && self.attributes.showOrderByOption && isNormalCell) {\r\n                e.items.push({\r\n                    title: self.attributes.showOrderByOptionTextAsc.replace('%s', e.cell.header.title || e.cell.header.name),\r\n                    click: function (ev) {\r\n                        ev.preventDefault();\r\n                        self.order(e.cell.header.name, 'asc');\r\n                        self.controlInput.focus();\r\n                    }\r\n                });\r\n                e.items.push({\r\n                    title: self.attributes.showOrderByOptionTextDesc.replace('%s', e.cell.header.title || e.cell.header.name),\r\n                    click: function (ev) {\r\n                        ev.preventDefault();\r\n                        self.order(e.cell.header.name, 'desc');\r\n                        self.disposeContextMenu();\r\n                        self.controlInput.focus();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        self.disposeAutocomplete = function () {\r\n            if (autoCompleteContext) {\r\n                autoCompleteContext.dispose();\r\n                autoCompleteContext = undefined;\r\n            }\r\n        };\r\n        self.disposeContextMenu = function () {\r\n            document.removeEventListener('click', self.disposeContextMenu);\r\n            zIndexTop = self.style.contextMenuZIndex;\r\n            self.disposeAutocomplete();\r\n            if (self.contextMenu) {\r\n                self.contextMenu.dispose();\r\n            }\r\n            self.contextMenu = undefined;\r\n        };\r\n        self.contextmenuEvent = function (e, overridePos) {\r\n            if (!self.hasFocus && e.target !== self.canvas) {\r\n                return;\r\n            }\r\n            function createDiposeEvent() {\r\n                requestAnimationFrame(function () {\r\n                    document.addEventListener('click', self.disposeContextMenu);\r\n                    document.removeEventListener('mouseup', createDiposeEvent);\r\n                });\r\n            }\r\n            var contextPosition,\r\n                items = [],\r\n                pos = overridePos || self.getLayerPos(e),\r\n                ev = {\r\n                    NativeEvent: e,\r\n                    cell: self.getCellAt(pos.x, pos.y),\r\n                    items: items\r\n                };\r\n            if (!ev.cell.isGrid) {\r\n                addDefaultContextMenuItem(ev);\r\n            }\r\n            if (self.dispatchEvent('contextmenu', ev)) {\r\n                return;\r\n            }\r\n            if (!ev.cell.isGrid) {\r\n                if (self.contextMenu) {\r\n                    self.disposeContextMenu();\r\n                }\r\n                contextPosition = {\r\n                    left: pos.x + pos.rect.left\r\n                        + self.style.contextMenuMarginLeft + self.canvasOffsetLeft,\r\n                    top: pos.y + pos.rect.top\r\n                        + self.style.contextMenuMarginTop + self.canvasOffsetTop,\r\n                    right: ev.cell.width + ev.cell.x + pos.rect.left,\r\n                    bottom: ev.cell.height + ev.cell.y + pos.rect.top,\r\n                    height: ev.cell.height,\r\n                    width: ev.cell.width\r\n                };\r\n                if (self.mobile) {\r\n                    contextPosition.left = self.style.mobileContextMenuMargin + 'px';\r\n                    contextPosition.width = self.width - (self.style.mobileContextMenuMargin * 2) + 'px';\r\n                }\r\n                self.contextMenu = createContextMenu(ev, contextPosition, items);\r\n                document.addEventListener('mouseup', createDiposeEvent);\r\n                e.preventDefault();\r\n            }\r\n        };\r\n        return;\r\n    };\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\r\n    'use strict';\r\n    return function (self) {\r\n        self.getClippingRect = function (ele) {\r\n            var boundingRect = self.position(self.parentNode),\r\n                eleRect = self.position(ele),\r\n                s = self.scrollOffset(self.canvas),\r\n                clipRect = {\r\n                    x: 0,\r\n                    y: 0,\r\n                    h: 0,\r\n                    w: 0\r\n                },\r\n                parentRect = {\r\n                    x: -Infinity,\r\n                    y: -Infinity,\r\n                    h: Infinity,\r\n                    w: Infinity\r\n                },\r\n                columnHeaderCellHeight = self.getColumnHeaderCellHeight(),\r\n                rowHeaderCellWidth = self.getRowHeaderCellWidth();\r\n            boundingRect.top -= s.top;\r\n            boundingRect.left -= s.left;\r\n            eleRect.top -= s.top;\r\n            eleRect.left -= s.left;\r\n            clipRect.h = boundingRect.top + boundingRect.height - ele.offsetTop - self.style.scrollBarWidth;\r\n            clipRect.w = boundingRect.left + boundingRect.width - ele.offsetLeft - self.style.scrollBarWidth;\r\n            clipRect.x = boundingRect.left + (eleRect.left * -1) + rowHeaderCellWidth;\r\n            clipRect.y = boundingRect.top + (eleRect.top * -1) + columnHeaderCellHeight;\r\n            return {\r\n                x: clipRect.x > parentRect.x ? clipRect.x : parentRect.x,\r\n                y: clipRect.y > parentRect.y ? clipRect.y : parentRect.y,\r\n                h: clipRect.h < parentRect.h ? clipRect.h : parentRect.h,\r\n                w: clipRect.w < parentRect.w ? clipRect.w : parentRect.w\r\n            };\r\n        };\r\n        self.clipElement = function (ele) {\r\n            var clipRect = self.getClippingRect(ele);\r\n            if (clipRect.w < 0) { clipRect.w = 0; }\r\n            if (clipRect.h < 0) { clipRect.h = 0; }\r\n            ele.style.clip = 'rect('\r\n                + clipRect.y + 'px,'\r\n                + clipRect.w + 'px,'\r\n                + clipRect.h + 'px,'\r\n                + clipRect.x + 'px'\r\n                + ')';\r\n            // INFO https://developer.mozilla.org/en-US/docs/Web/CSS/clip\r\n            // clip has been \"deprecated\" for clipPath.  Of course nothing but chrome\r\n            // supports clip path, so we'll keep using clip until someday clipPath becomes\r\n            // more widely support.  The code below works correctly, but setting clipPath and clip\r\n            // at the same time has undesirable results.\r\n            // ele.style.clipPath = 'polygon('\r\n            //     + clipRect.x + 'px ' + clipRect.y + 'px,'\r\n            //     + clipRect.x + 'px ' + clipRect.h + 'px,'\r\n            //     + clipRect.w + 'px ' + clipRect.h + 'px,'\r\n            //     + clipRect.w + 'px ' + clipRect.y + 'px'\r\n            //     + ')';\r\n        };\r\n        self.scrollOffset = function (e) {\r\n            var x = 0, y = 0, scrollingElement = document.scrollingElement || { scrollLeft: 0, scrollTop: 0 };\r\n            while (e.parentNode && e.nodeName !== 'CANVAS-DATAGRID' && e !== self.intf) {\r\n                if (e.nodeType !== 'canvas-datagrid-tree'\r\n                        && e.nodeType !== 'canvas-datagrid-cell') {\r\n                    x -= e.scrollLeft;\r\n                    y -= e.scrollTop;\r\n                }\r\n                e = e.parentNode;\r\n            }\r\n            return {\r\n                left: x - scrollingElement.scrollLeft,\r\n                top: y - scrollingElement.scrollTop\r\n            };\r\n        };\r\n        self.resizeEditInput = function () {\r\n            if (self.input && self.input.editCell) {\r\n                var pos = self.canvas.getBoundingClientRect(),\r\n                    s = self.scrollOffset(self.intf),\r\n                    bm = self.style.gridBorderCollapse === 'collapse' ? 1 : 2,\r\n                    borderWidth = (self.style.cellBorderWidth * bm),\r\n                    cell = self.getVisibleCellByIndex(self.input.editCell.columnIndex, self.input.editCell.rowIndex)\r\n                        || {x: -100, y: -100, height: 0, width: 0};\r\n                if (self.mobile) {\r\n                    self.input.style.left = '0';\r\n                    self.input.style.top = (self.height - self.style.mobileEditInputHeight) - borderWidth - 1 + 'px';\r\n                    self.input.style.height = self.style.mobileEditInputHeight + 'px';\r\n                    self.input.style.width = self.width - borderWidth - 1 + 'px';\r\n                    return;\r\n                }\r\n                self.input.style.left = pos.left + cell.x + self.canvasOffsetLeft - s.left + 'px';\r\n                self.input.style.top = pos.top + cell.y - self.style.cellBorderWidth + self.canvasOffsetTop - s.top + 'px';\r\n                self.input.style.height = cell.height - borderWidth + 'px';\r\n                self.input.style.width = cell.width - self.style.cellPaddingLeft + 'px';\r\n                self.clipElement(self.input);\r\n            }\r\n        };\r\n        self.position = function (e, ignoreScrollOffset) {\r\n            var x = 0, y = 0, s = e, h, w;\r\n            while (e.offsetParent && e.nodeName !== 'CANVAS-DATAGRID') {\r\n                x += e.offsetLeft;\r\n                y += e.offsetTop;\r\n                h = e.offsetHeight;\r\n                w = e.offsetWidth;\r\n                e = e.offsetParent;\r\n            }\r\n            if (ignoreScrollOffset) {\r\n                return {left: x, top: y, height: h, width: w};\r\n            }\r\n            e = s;\r\n            s = self.scrollOffset(e);\r\n            return { left: x + s.left, top: y + s.top, height: h, width: w };\r\n        };\r\n        self.getLayerPos = function (e) {\r\n            var rect = self.canvas.getBoundingClientRect(),\r\n                pos = {\r\n                    x: e.clientX - rect.left,\r\n                    y: e.clientY - rect.top\r\n                };\r\n            if (self.isChildGrid) {\r\n                pos.x -= self.canvasOffsetLeft;\r\n                pos.y -= self.canvasOffsetTop;\r\n            }\r\n            return {\r\n                x: pos.x,\r\n                y: pos.y,\r\n                rect: rect\r\n            };\r\n        };\r\n        /**\r\n         * Ends editing, optionally aborting the edit.\r\n         * @memberof canvasDatagrid\r\n         * @name endEdit\r\n         * @method\r\n         * @param {boolean} abort When true, abort the edit.\r\n         */\r\n        self.endEdit = function (abort) {\r\n            var cell = self.input.editCell,\r\n                y = cell.rowIndex;\r\n            function abortEdit() {\r\n                abort = true;\r\n            }\r\n            if (self.dispatchEvent('beforeendedit', {\r\n                    cell: cell,\r\n                    newValue: self.input.value,\r\n                    oldValue: cell.value,\r\n                    abort: abortEdit,\r\n                    input: self.input\r\n                })) { return false; }\r\n            if (self.input.value !== cell.value && !abort) {\r\n                self.changes[y] = self.changes[y] || {};\r\n                self.changes[y][cell.header.name] = self.input.value;\r\n                if (!cell.data) {\r\n                    self.data[cell.rowIndex] = {};\r\n                    cell.data = self.data[cell.rowIndex];\r\n                }\r\n                cell.data[cell.header.name] = self.input.value;\r\n                if (y === self.data.length) {\r\n                    if (self.dispatchEvent('newrow', {\r\n                            value: self.input.value,\r\n                            defaultValue: cell.value,\r\n                            aborted: abort,\r\n                            cell: cell,\r\n                            input: self.input\r\n                        })) { return false; }\r\n                    self.addRow(cell.data);\r\n                    self.createNewRowData();\r\n                }\r\n                self.draw(true);\r\n            }\r\n            if (self.input.parentNode) {\r\n                self.input.parentNode.removeChild(self.input);\r\n            }\r\n            self.intf.focus();\r\n            self.dispatchEvent('endedit', {\r\n                cell: cell,\r\n                value: self.input.value,\r\n                aborted: abort,\r\n                input: self.input\r\n            });\r\n            self.input = undefined;\r\n            return true;\r\n        };\r\n        /**\r\n         * Begins editing at cell x, row y.\r\n         * @memberof canvasDatagrid\r\n         * @name beginEditAt\r\n         * @method\r\n         * @param {number} x The column index of the cell to edit.\r\n         * @param {number} y The row index of the cell to edit.\r\n         */\r\n        self.beginEditAt = function (x, y, NativeEvent) {\r\n            if (!self.attributes.editable) { return; }\r\n            if (self.input) {\r\n                self.endEdit();\r\n            }\r\n            var cell = self.getVisibleCellByIndex(x, y),\r\n                s = self.getSchema(),\r\n                adjacentCells,\r\n                enumItems,\r\n                enu,\r\n                option,\r\n                valueInEnum;\r\n            if (!(cell && cell.header)) { return; }\r\n            //HACK for IE10, does not like literal enum\r\n            enu = cell.header['enum'];\r\n            if (self.dispatchEvent('beforebeginedit', {cell: cell, NativeEvent: NativeEvent})) { return false; }\r\n            self.scrollIntoView(x, y);\r\n            self.setActiveCell(x, y);\r\n            adjacentCells = self.getAdjacentCells();\r\n            if (enu) {\r\n                self.input = document.createElement('select');\r\n            } else {\r\n                self.input = document.createElement(self.attributes.multiLine\r\n                    ? 'textarea' : 'input');\r\n            }\r\n            cell = self.getVisibleCellByIndex(x, y);\r\n            //HACK on mobile devices sometimes edit can begin without the cell being in view, I don't know how.\r\n            if (!cell) { return; }\r\n            if (enu) {\r\n                // add enums\r\n                if (typeof enu === 'function') {\r\n                    enumItems = enu.apply(self.intf, [{cell: cell}]);\r\n                } else if (Array.isArray(enu)) {\r\n                    enumItems = enu;\r\n                }\r\n                enumItems.forEach(function (e) {\r\n                    var i = document.createElement('option'),\r\n                        val,\r\n                        title;\r\n                    if (Array.isArray(e)) {\r\n                        val = e[0];\r\n                        title = e[1];\r\n                    } else {\r\n                        val = e;\r\n                        title = e;\r\n                    }\r\n                    if (val === cell.value) { valueInEnum = true; }\r\n                    i.value = val;\r\n                    i.innerHTML = title;\r\n                    self.input.appendChild(i);\r\n                });\r\n                if (!valueInEnum) {\r\n                    option = document.createElement('option');\r\n                    option.value = cell.value;\r\n                    option.innerHTML = cell.value;\r\n                    self.input.appendChild(option);\r\n                }\r\n                self.input.addEventListener('change', function () {\r\n                    self.endEdit();\r\n                    self.draw(true);\r\n                });\r\n            }\r\n            // if the user has not prevented the default action, append to the body\r\n            if (!self.dispatchEvent('appendeditinput', {cell: cell, input:self.input})) { \r\n                document.body.appendChild(self.input);\r\n            }\r\n            self.createInlineStyle(self.input, self.mobile ? 'canvas-datagrid-edit-mobile-input' : 'canvas-datagrid-edit-input');\r\n            self.input.style.position = 'absolute';\r\n            self.input.editCell = cell;\r\n            self.resizeEditInput();\r\n            self.input.style.zIndex = self.style.editCellZIndex;\r\n            self.input.style.fontSize = (parseInt(self.style.editCellFontSize, 10) * self.scale) + 'px';\r\n            self.input.value = [null, undefined].indexOf(cell.value) !== -1 ? '' : cell.value;\r\n            self.input.focus();\r\n            self.input.addEventListener('click', self.stopPropagation);\r\n            self.input.addEventListener('dblclick', self.stopPropagation);\r\n            self.input.addEventListener('mouseup', self.stopPropagation);\r\n            self.input.addEventListener('mousedown', self.stopPropagation);\r\n            self.input.addEventListener('keydown', function (e) {\r\n                var nx = cell.columnIndex,\r\n                    ny = cell.rowIndex;\r\n                // esc\r\n                if (e.keyCode === 27) {\r\n                    self.endEdit(true);\r\n                    self.draw(true);\r\n                // enter\r\n                } else if (e.keyCode === 13\r\n                        && (!self.attributes.multiLine\r\n                            || (self.attributes.multiLine && e.shiftKey))) {\r\n                    self.endEdit();\r\n                    self.draw(true);\r\n                } else if (e.keyCode === 9) {\r\n                    e.preventDefault();\r\n                    if (!self.endEdit()) {\r\n                        return;\r\n                    }\r\n                    if (e.shiftKey) {\r\n                        nx = adjacentCells.left;\r\n                    } else {\r\n                        nx = adjacentCells.right;\r\n                    }\r\n                    if (adjacentCells.left === x && e.shiftKey) {\r\n                        nx = adjacentCells.last;\r\n                        ny -= 1;\r\n                    }\r\n                    if (adjacentCells.right === x && !e.shiftKey) {\r\n                        nx = adjacentCells.first;\r\n                        ny += 1;\r\n                    }\r\n                    if (ny < 0) {\r\n                        ny = self.data.length - 1;\r\n                    }\r\n                    if (ny > self.data.length - 1) {\r\n                        ny = 0;\r\n                    }\r\n                    self.scrollIntoView(nx, ny);\r\n                    self.beginEditAt(nx, ny, e);\r\n                }\r\n            });\r\n            self.dispatchEvent('beginedit', {cell: cell, input: self.input});\r\n        };\r\n        self.createInlineStyle = function (el, className) {\r\n            var css = {\r\n                'canvas-datagrid-context-menu-filter-input': {\r\n                    height: '19px',\r\n                    verticalAlign: 'bottom',\r\n                    marginLeft: '2px',\r\n                    padding: '0',\r\n                    background: self.style.contextFilterInputBackground,\r\n                    color: self.style.contextFilterInputColor,\r\n                    border: self.style.contextFilterInputBorder,\r\n                    borderRadius: self.style.contextFilterInputBorderRadius,\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextFilterInputFontFamily,\r\n                    fontSize: self.style.contextFilterInputFontSize\r\n                },\r\n                'canvas-datagrid-context-menu-filter-button': {\r\n                    height: '19px',\r\n                    verticalAlign: 'bottom',\r\n                    marginLeft: '2px',\r\n                    padding: '0',\r\n                    background: self.style.contextMenuBackground,\r\n                    color: self.style.contextMenuColor,\r\n                    border: self.style.contextFilterButtonBorder,\r\n                    borderRadius: self.style.contextFilterButtonBorderRadius,\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFilterButtonFontFamily,\r\n                    fontSize: self.style.contextMenuFilterButtonFontSize\r\n                },\r\n                'canvas-datagrid-context-child-arrow': {\r\n                    cssFloat: 'right',\r\n                    color: self.style.childContextMenuArrowColor,\r\n                    fontSize: self.style.contextMenuChildArrowFontSize,\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    verticalAlign: 'middle'\r\n                },\r\n                'canvas-datagrid-autocomplete': {\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize,\r\n                    background: self.style.contextMenuBackground,\r\n                    color: self.style.contextMenuColor,\r\n                    border: self.style.contextMenuBorder,\r\n                    padding: self.style.contextMenuPadding,\r\n                    borderRadius: self.style.contextMenuBorderRadius,\r\n                    opacity: self.style.contextMenuOpacity,\r\n                    position: 'absolute',\r\n                    zIndex: 9999,\r\n                    overflow: 'hidden'\r\n                },\r\n                'canvas-datagrid-autocomplete-item': {\r\n                    background: self.style.contextMenuBackground,\r\n                    color: self.style.contextMenuColor\r\n                },\r\n                'canvas-datagrid-autocomplete-item:hover': {\r\n                    background: self.style.contextMenuHoverBackground,\r\n                    color: self.style.contextMenuHoverColor\r\n                },\r\n                'canvas-datagrid-canvas': {\r\n                    position: 'absolute',\r\n                    zIndex: '-1'\r\n                },\r\n                'canvas-datagrid': {\r\n                    display: 'block'\r\n                },\r\n                'canvas-datagrid-control-input': {\r\n                    position: 'fixed',\r\n                    top: '-5px',\r\n                    left: '-5px',\r\n                    border: 'none',\r\n                    opacity: '0',\r\n                    cursor: 'pointer',\r\n                    width: '1px',\r\n                    height: '1px',\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize\r\n                },\r\n                'canvas-datagrid-edit-mobile-input': {\r\n                    boxSizing: 'content-box',\r\n                    outline: 'none',\r\n                    margin: '0',\r\n                    padding: '0 0 0 0',\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.mobileEditFontFamily,\r\n                    fontSize: self.style.mobileEditFontSize,\r\n                    border: self.style.editCellBorder,\r\n                    color: self.style.editCellColor,\r\n                    background: self.style.editCellBackgroundColor,\r\n                    appearance: 'none',\r\n                    webkitAppearance: 'none',\r\n                    mozAppearance: 'none',\r\n                    borderRadius: '0'\r\n                },\r\n                'canvas-datagrid-edit-input': {\r\n                    boxSizing: 'content-box',\r\n                    outline: 'none',\r\n                    margin: '0',\r\n                    padding: '0 0 0 ' + self.style.editCellPaddingLeft + 'px',\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.editCellFontFamily,\r\n                    fontSize: self.style.editCellFontSize,\r\n                    boxShadow: self.style.editCellBoxShadow,\r\n                    border: self.style.editCellBorder,\r\n                    color: self.style.editCellColor,\r\n                    background: self.style.editCellBackgroundColor,\r\n                    appearance: 'none',\r\n                    webkitAppearance: 'none',\r\n                    mozAppearance: 'none',\r\n                    borderRadius: '0'\r\n                },\r\n                'canvas-datagrid-context-menu-item-mobile': {\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize,\r\n                    color: 'inherit',\r\n                    background: 'inherit',\r\n                    margin: self.style.contextMenuItemMargin,\r\n                    borderRadius: self.style.contextMenuItemBorderRadius,\r\n                    verticalAlign: 'middle'\r\n                },\r\n                'canvas-datagrid-context-menu-item': {\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize,\r\n                    color: 'inherit',\r\n                    background: 'inherit',\r\n                    margin: self.style.contextMenuItemMargin,\r\n                    borderRadius: self.style.contextMenuItemBorderRadius,\r\n                    verticalAlign: 'middle'\r\n                },\r\n                'canvas-datagrid-context-menu-item:hover': {\r\n                    background: self.style.contextMenuHoverBackground,\r\n                    color: self.style.contextMenuHoverColor\r\n                },\r\n                'canvas-datagrid-context-menu-label': {\r\n                    margin: self.style.contextMenuLabelMargin,\r\n                    display: self.style.contextMenuLabelDisplay,\r\n                    minWidth: self.style.contextMenuLabelMinWidth,\r\n                    maxWidth: self.style.contextMenuLabelMaxWidth\r\n                },\r\n                'canvas-datagrid-context-menu-mobile': {\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize,\r\n                    background: self.style.contextMenuBackground,\r\n                    color: self.style.contextMenuColor,\r\n                    border: self.style.contextMenuBorder,\r\n                    padding: self.style.contextMenuPadding,\r\n                    borderRadius: self.style.contextMenuBorderRadius,\r\n                    opacity: self.style.contextMenuOpacity,\r\n                    overflow: 'hidden',\r\n                    whiteSpace: 'nowrap'\r\n                },\r\n                'canvas-datagrid-context-menu': {\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize,\r\n                    background: self.style.contextMenuBackground,\r\n                    color: self.style.contextMenuColor,\r\n                    border: self.style.contextMenuBorder,\r\n                    padding: self.style.contextMenuPadding,\r\n                    borderRadius: self.style.contextMenuBorderRadius,\r\n                    opacity: self.style.contextMenuOpacity,\r\n                    overflow: 'hidden',\r\n                    whiteSpace: 'nowrap',\r\n                    cursor: self.style.contextMenuCursor\r\n                },\r\n                'canvas-datagrid-invalid-search-regExp': {\r\n                    background: self.style.contextMenuFilterInvalidExpresion\r\n                }\r\n            };\r\n            if (css[className]) {\r\n                Object.keys(css[className]).map(function (prop) {\r\n                    el.style[prop] = css[className][prop];\r\n                });\r\n            }\r\n            return;\r\n        };\r\n        self.appendTo = function (e) {\r\n            self.parentNode = e;\r\n            self.setDom();\r\n        };\r\n        self.setDom = function () {\r\n            if (self.isChildGrid) {\r\n                self.parentGrid = self.parentNode.parentGrid;\r\n                self.ctx = self.parentGrid.context;\r\n                self.canvas = self.parentGrid.canvas;\r\n                self.controlInput = self.parentGrid.controlInput;\r\n                self.eventParent = self.canvas;\r\n            } else {\r\n                self.controlInput = self.controlInput || document.createElement('input');\r\n                self.controlInput.onblur = self.intf.blur;\r\n                self.createInlineStyle(self.controlInput, 'canvas-datagrid-control-input');\r\n                self.isChildGrid = false;\r\n                self.parentDOMNode = self.parentNode;\r\n                self.parentIsCanvas = /^canvas$/i.test(self.parentDOMNode.tagName);\r\n                if (self.parentIsCanvas) {\r\n                    self.canvas = self.parentDOMNode;\r\n                } else {\r\n                    self.canvas = document.createElement('canvas');\r\n                    self.parentDOMNode.appendChild(self.canvas);\r\n                }\r\n                document.body.appendChild(self.controlInput);\r\n                self.createInlineStyle(self.canvas, 'canvas-datagrid');\r\n                self.ctx = self.canvas.getContext('2d');\r\n                self.ctx.textBaseline = 'alphabetic';\r\n                self.eventParent = self.canvas;\r\n            }\r\n            self.parentNodeStyle = self.canvas.style;\r\n            self.controlInput.setAttribute('readonly', true);\r\n            self.controlInput.addEventListener('blur', function (e) {\r\n                if (e.target !== self.canvas) {\r\n                    self.hasFocus = false;\r\n                }\r\n            });\r\n            self.eventParent.addEventListener('scroll', self.resize, false);\r\n            self.eventParent.addEventListener('touchstart', self.touchstart, false);\r\n            self.eventParent.addEventListener('mouseup', self.mouseup, false);\r\n            self.eventParent.addEventListener('mousedown', self.mousedown, false);\r\n            self.eventParent.addEventListener('dblclick', self.dblclick, false);\r\n            self.eventParent.addEventListener('click', self.click, false);\r\n            self.eventParent.addEventListener('mousemove', self.mousemove);\r\n            self[self.isChildGrid ? 'parentGrid' : 'eventParent'].addEventListener('wheel', self.scrollWheel, false);\r\n            self.canvas.addEventListener('contextmenu', self.contextmenuEvent, false);\r\n            self.controlInput.addEventListener('copy', self.copy);\r\n            self.controlInput.addEventListener('cut', self.cut);\r\n            self.controlInput.addEventListener('paste', self.paste);\r\n            self.controlInput.addEventListener('keypress', self.keypress, false);\r\n            self.controlInput.addEventListener('keyup', self.keyup, false);\r\n            self.controlInput.addEventListener('keydown', self.keydown, false);\r\n            window.addEventListener('resize', self.resize);\r\n        };\r\n    };\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\r\n  'use strict';\r\n  return function (self) {\r\n    /**\r\n     * Converts a integer into a letter A - ZZZZZ...\r\n     * @memberof canvasDatagrid\r\n     * @name integerToAlpha\r\n     * @method\r\n     * @param {column} n The number to convert.\r\n     */\r\n    self.integerToAlpha = function (n) {\r\n      var ordA = 'a'.charCodeAt(0),\r\n        ordZ = 'z'.charCodeAt(0),\r\n        len = ordZ - ordA + 1,\r\n        s = '';\r\n      while (n >= 0) {\r\n        s = String.fromCharCode(n % len + ordA) + s;\r\n        n = Math.floor(n / len) - 1;\r\n      }\r\n      return s;\r\n    };\r\n    /**\r\n     * Inserts a new column before the specified index into the schema.\r\n     * @tutorial schema\r\n     * @memberof canvasDatagrid\r\n     * @name insertColumn\r\n     * @method\r\n     * @param {column} c The column to insert into the schema.\r\n     * @param {number} index The index of the column to insert before.\r\n     */\r\n    self.insertColumn = function (c, index) {\r\n      var s = self.getSchema();\r\n      if (s.length < index) {\r\n        throw new Error('Index is beyond the length of the schema.');\r\n      }\r\n      self.validateColumn(c, s);\r\n      s.splice(index, 0, c);\r\n      self.data.forEach(function (row) {\r\n        self.applyDefaultValue(row, c);\r\n      });\r\n      self.intf.schema = s;\r\n    };\r\n    /**\r\n     * Deletes a column from the schema at the specified index.\r\n     * @memberof canvasDatagrid\r\n     * @name deleteColumn\r\n     * @tutorial schema\r\n     * @method\r\n     * @param {number} index The index of the column to delete.\r\n     */\r\n    self.deleteColumn = function (index) {\r\n      var s = self.getSchema();\r\n      // remove data matching this column name from data\r\n      self.data.forEach(function (row) {\r\n        delete row[s[index].name];\r\n      });\r\n      s.splice(index, 1);\r\n      self.intf.schema = s;\r\n    };\r\n    /**\r\n     * Adds a new column into the schema.\r\n     * @tutorial schema\r\n     * @memberof canvasDatagrid\r\n     * @name addColumn\r\n     * @method\r\n     * @param {column} c The column to add to the schema.\r\n     */\r\n    self.addColumn = function (c) {\r\n      var s = self.getSchema();\r\n      self.validateColumn(c, s);\r\n      s.push(c);\r\n      self.data.forEach(function (row) {\r\n        self.applyDefaultValue(row, c);\r\n      });\r\n      self.intf.schema = s;\r\n    };\r\n    /**\r\n     * Deletes a row from the dataset at the specified index.\r\n     * @memberof canvasDatagrid\r\n     * @name deleteRow\r\n     * @method\r\n     * @param {number} index The index of the row to delete.\r\n     */\r\n    self.deleteRow = function (index) {\r\n      self.originalData.splice(index, 1);\r\n      self.setFilter();\r\n      self.resize(true);\r\n    };\r\n    /**\r\n     * Inserts a new row into the dataset before the specified index.\r\n     * @memberof canvasDatagrid\r\n     * @name insertRow\r\n     * @method\r\n     * @param {object} d data.\r\n     * @param {number} index The index of the row to insert before.\r\n     */\r\n    self.insertRow = function (d, index) {\r\n      if (self.originalData.length < index) {\r\n        throw new Error('Index is beyond the length of the dataset.');\r\n      }\r\n      self.originalData.splice(index, 0, d);\r\n      self.getSchema().forEach(function (c) {\r\n        if (d[c.name] === undefined) {\r\n          self.applyDefaultValue(self.originalData[index], c);\r\n        }\r\n      });\r\n      self.setFilter();\r\n      self.resize(true);\r\n    };\r\n    /**\r\n     * Adds a new row into the dataset.\r\n     * @memberof canvasDatagrid\r\n     * @name addRow\r\n     * @method\r\n     * @param {object} d data.\r\n     */\r\n    self.addRow = function (d) {\r\n      self.originalData.push(d);\r\n      self.getSchema().forEach(function (c) {\r\n        if (d[c.name] === undefined) {\r\n          self.applyDefaultValue(self.originalData[self.originalData.length - 1], c);\r\n        }\r\n      });\r\n      self.setFilter();\r\n      self.resize(true);\r\n    };\r\n    /**\r\n     * Sets the height of a given row by index number.\r\n     * @memberof canvasDatagrid\r\n     * @name setRowHeight\r\n     * @method\r\n     * @param {number} rowIndex The index of the row to set.\r\n     * @param {number} height Height to set the row to.\r\n     */\r\n    self.setRowHeight = function (rowIndex, height) {\r\n      self.sizes.rows[rowIndex] = height;\r\n      self.draw(true);\r\n    };\r\n    /**\r\n     * Sets the width of a given column by index number.\r\n     * @memberof canvasDatagrid\r\n     * @name setColumnWidth\r\n     * @method\r\n     * @param {number} colIndex The index of the column to set.\r\n     * @param {number} width Width to set the column to.\r\n     */\r\n    self.setColumnWidth = function (colIndex, width) {\r\n      self.sizes.columns[colIndex] = width;\r\n      self.draw(true);\r\n    };\r\n    /**\r\n     * Removes any changes to the width of the columns due to user or api interaction, setting them back to the schema or style default.\r\n     * @memberof canvasDatagrid\r\n     * @name resetColumnWidths\r\n     * @tutorial schema\r\n     * @method\r\n     */\r\n    self.resetColumnWidths = function () {\r\n      self.sizes.columns = {};\r\n      self.draw(true);\r\n    };\r\n    /**\r\n     * Removes any changes to the height of the rows due to user or api interaction, setting them back to the schema or style default.\r\n     * @memberof canvasDatagrid\r\n     * @name resetRowHeights\r\n     * @tutorial schema\r\n     * @method\r\n     */\r\n    self.resetRowHeights = function () {\r\n      self.sizes.rows = {};\r\n      self.draw(true);\r\n    };\r\n    /**\r\n     * Sets the value of the filter.\r\n     * @memberof canvasDatagrid\r\n     * @name setFilter\r\n     * @method\r\n     * @param {string} column Name of the column to filter.\r\n     * @param {string} value The value to filter for.\r\n     */\r\n    self.setFilter = function (column, value) {\r\n      if (column === undefined && value === undefined) {\r\n        self.columnFilters = {};\r\n      } else if (column && (value === '' || value === undefined)) {\r\n        delete self.columnFilters[column];\r\n      } else {\r\n        self.columnFilters[column] = value;\r\n      }\r\n      self.applyDataTransforms();\r\n    };\r\n    /**\r\n     * Returns the number of pixels to scroll down to line up with row rowIndex.\r\n     * @memberof canvasDatagrid\r\n     * @name findRowScrollTop\r\n     * @method\r\n     * @param {number} rowIndex The row index of the row to scroll find.\r\n     */\r\n    self.findRowScrollTop = function (rowIndex) {\r\n      if (self.scrollCache.y[rowIndex] === undefined) { throw new RangeError('Row index out of range.'); }\r\n      return self.scrollCache.y[rowIndex];\r\n    };\r\n    /**\r\n     * Returns the number of pixels to scroll to the left to line up with column columnIndex.\r\n     * @memberof canvasDatagrid\r\n     * @name findColumnScrollLeft\r\n     * @method\r\n     * @param {number} columnIndex The column index of the column to find.\r\n     */\r\n    self.findColumnScrollLeft = function (columnIndex) {\r\n      var i = Math.max(columnIndex - 1, 0);\r\n      if (self.scrollCache.x[i] === undefined) { throw new Error('Column index out of range.'); }\r\n      return self.scrollCache.x[i] - self.getColummnWidth(self.orders.columns[columnIndex]);\r\n    };\r\n    /**\r\n     * Scrolls to the cell at columnIndex x, and rowIndex y.  If you define both rowIndex and columnIndex additional calculations can be made to center the cell using the target cell's height and width.  Defining only one rowIndex or only columnIndex will result in simpler calculations.\r\n     * @memberof canvasDatagrid\r\n     * @name gotoCell\r\n     * @method\r\n     * @param {number} x The column index of the cell to scroll to.\r\n     * @param {number} y The row index of the cell to scroll to.\r\n     * @param {number} [offsetX=0] Percentage offset the cell should be from the left edge (not including headers).  The default is 0, meaning the cell will appear at the left edge. Valid values are 0 through 1. 1 = Left, 0 = Right, 0.5 = Center.\r\n     * @param {number} [offsetY=0] Percentage offset the cell should be from the top edge (not including headers).  The default is 0, meaning the cell will appear at the top edge. Valid values are 0 through 1. 1 = Bottom, 0 = Top, 0.5 = Center.\r\n     */\r\n    self.gotoCell = function (x, y, offsetX, offsetY) {\r\n      var targetX = x === undefined ? undefined : self.findColumnScrollLeft(x),\r\n        targetY = y === undefined ? undefined : self.findRowScrollTop(y),\r\n        cell,\r\n        sbw = self.scrollBox.width - (self.scrollBox.verticalBarVisible ? self.style.scrollBarWidth : 0),\r\n        sbh = self.scrollBox.height - (self.scrollBox.horizontalBarVisible ? self.style.scrollBarWidth : 0);\r\n      offsetX = offsetX === undefined ? 0 : offsetX;\r\n      offsetY = offsetY === undefined ? 0 : offsetY;\r\n      targetX -= sbw * offsetX;\r\n      targetY -= sbh * offsetY;\r\n      if (x !== undefined && y !== undefined) {\r\n        self.scrollBox.scrollTo(targetX, targetY);\r\n        requestAnimationFrame(function () {\r\n          cell = self.getVisibleCellByIndex(x, y);\r\n          // HACK: just don't offset if the target cell cannot be seen\r\n          // TODO: offset does not work on very small grids, not sure why\r\n          if (!cell) { return; }\r\n          targetX += cell.width * offsetX;\r\n          targetY += cell.height * offsetY;\r\n          self.scrollBox.scrollTo(targetX, targetY);\r\n        });\r\n      } else if (x !== undefined) {\r\n        self.scrollBox.scrollLeft = targetX;\r\n      } else if (y !== undefined) {\r\n        self.scrollBox.scrollTop = targetY;\r\n      }\r\n    };\r\n    /**\r\n     * Scrolls the row y.\r\n     * @memberof canvasDatagrid\r\n     * @name gotoRow\r\n     * @method\r\n     * @param {number} y The row index of the cell to scroll to.\r\n     */\r\n    self.gotoRow = function (y) {\r\n      self.gotoCell(0, y);\r\n    };\r\n    /**\r\n     * Scrolls the cell at cell x, row y into view if it is not already.\r\n     * @memberof canvasDatagrid\r\n     * @name scrollIntoView\r\n     * @method\r\n     * @param {number} x The column index of the cell to scroll into view.\r\n     * @param {number} y The row index of the cell to scroll into view.\r\n     * @param {number} [offsetX=0] Percentage offset the cell should be from the left edge (not including headers).  The default is 0, meaning the cell will appear at the left edge. Valid values are 0 through 1. 1 = Left, 0 = Right, 0.5 = Center.\r\n     * @param {number} [offsetY=0] Percentage offset the cell should be from the top edge (not including headers).  The default is 0, meaning the cell will appear at the top edge. Valid values are 0 through 1. 1 = Bottom, 0 = Top, 0.5 = Center.\r\n     */\r\n    self.scrollIntoView = function (x, y, offsetX, offsetY) {\r\n      if (self.visibleCells.filter(function (cell) {\r\n        return (cell.rowIndex === y || y === undefined)\r\n          && (cell.columnIndex === x || x === undefined)\r\n          && cell.x > 0\r\n          && cell.y > 0\r\n          && cell.x + cell.width < self.width\r\n          && cell.y + cell.height < self.height;\r\n      }).length === 0) {\r\n        self.gotoCell(x, y, offsetX, offsetY);\r\n      }\r\n    };\r\n    /**\r\n     * Sets the active cell. Requires redrawing.\r\n     * @memberof canvasDatagrid\r\n     * @name setActiveCell\r\n     * @method\r\n     * @param {number} x The column index of the cell to set active.\r\n     * @param {number} y The row index of the cell to set active.\r\n     */\r\n    self.setActiveCell = function (x, y) {\r\n      if (x < 0) { x = 0; }\r\n      if (y < 0) { y = 0; }\r\n      self.activeCell = {\r\n        rowIndex: y,\r\n        columnIndex: x\r\n      };\r\n    };\r\n    /**\r\n     * Removes the selection.\r\n     * @memberof canvasDatagrid\r\n     * @name selectNone\r\n     * @param {boolean} dontDraw Suppress the draw method after the selection change.\r\n     * @method\r\n     */\r\n    self.selectNone = function (dontDraw) {\r\n      self.selections = [];\r\n      self.dispatchEvent('selectionchanged', {\r\n        selectedData: self.getSelectedData(),\r\n        selections: self.selections,\r\n        selectionBounds: self.selectionBounds\r\n      });\r\n      if (dontDraw) { return; }\r\n      self.draw();\r\n    };\r\n    /**\r\n     * Selects every visible cell.\r\n     * @memberof canvasDatagrid\r\n     * @name selectAll\r\n     * @param {boolean} dontDraw Suppress the draw method after the selection change.\r\n     * @method\r\n     */\r\n    self.selectAll = function (dontDraw) {\r\n      self.selectArea({\r\n        top: 0,\r\n        left: -1,\r\n        right: self.getSchema().length - 1,\r\n        bottom: self.data.length - 1\r\n      });\r\n      if (dontDraw) { return; }\r\n      self.draw();\r\n    };\r\n    /**\r\n     * Returns true if the selected columnIndex is selected on every row.\r\n     * @memberof canvasDatagrid\r\n     * @name isColumnSelected\r\n     * @method\r\n     * @param {number} columnIndex The column index to check.\r\n     */\r\n    self.isColumnSelected = function (columnIndex) {\r\n      var colIsSelected = true;\r\n      self.data.forEach(function (row, rowIndex) {\r\n        if (!self.selections[rowIndex] || self.selections[rowIndex].indexOf(self.orders.columns[columnIndex]) === -1) {\r\n          colIsSelected = false;\r\n        }\r\n      });\r\n      return colIsSelected;\r\n    };\r\n    /**\r\n     * Runs the defined method on each selected cell.\r\n     * @memberof canvasDatagrid\r\n     * @name forEachSelectedCell\r\n     * @method\r\n     * @param {number} fn The function to execute.  The signature of the function is: (data, rowIndex, columnName).\r\n     * @param {number} expandToRow When true the data in the array is expanded to the entire row.\r\n     */\r\n    self.forEachSelectedCell = function (fn, expandToRow) {\r\n      var d = [], s = expandToRow ? self.getSchema() : self.getVisibleSchema(), l = self.data.length;\r\n      self.selections.forEach(function (row, index) {\r\n        if (index === l) { return; }\r\n        if (row.length === 0) {\r\n          d[index] = null;\r\n          return;\r\n        }\r\n        d[index] = {};\r\n        row.forEach(function (col) {\r\n          if (col === -1 || !s[col]) { return; }\r\n          fn(self.data, index, s[col].name);\r\n        });\r\n      });\r\n    };\r\n    /**\r\n     * Selects a column.\r\n     * @memberof canvasDatagrid\r\n     * @name selectColumn\r\n     * @method\r\n     * @param {number} columnIndex The column index to select.\r\n     * @param {boolean} toggleSelectMode When true, behaves as if you were holding control/command when you clicked the column.\r\n     * @param {boolean} shift When true, behaves as if you were holding shift when you clicked the column.\r\n     * @param {boolean} supressSelectionchangedEvent When true, prevents the selectionchanged event from firing.\r\n     */\r\n    self.selectColumn = function (columnIndex, ctrl, shift, supressEvent) {\r\n      var s, e, x;\r\n      function addCol(i) {\r\n        self.data.forEach(function (row, rowIndex) {\r\n          self.selections[rowIndex] = self.selections[rowIndex] || [];\r\n          if (self.selections[rowIndex].indexOf(i) === -1) {\r\n            self.selections[rowIndex].push(i);\r\n          }\r\n        });\r\n      }\r\n      function removeCol(i) {\r\n        self.data.forEach(function (row, rowIndex) {\r\n          self.selections[rowIndex] = self.selections[rowIndex] || [];\r\n          if (self.selections[rowIndex].indexOf(i) !== -1) {\r\n            self.selections[rowIndex].splice(self.selections[rowIndex].indexOf(i), 1);\r\n          }\r\n        });\r\n      }\r\n      if (shift) {\r\n        if (!self.activeCell) { return; }\r\n        s = Math.min(self.activeCell.columnIndex, columnIndex);\r\n        e = Math.max(self.activeCell.columnIndex, columnIndex);\r\n        for (x = s; e > x; x += 1) {\r\n          addCol(x);\r\n        }\r\n      }\r\n      if (!ctrl && !shift) {\r\n        self.selections = [];\r\n        self.activeCell.columnIndex = columnIndex;\r\n        self.activeCell.rowIndex = self.scrollIndexTop;\r\n      }\r\n      if (ctrl && self.isColumnSelected(columnIndex)) {\r\n        removeCol(columnIndex);\r\n      } else {\r\n        addCol(columnIndex);\r\n      }\r\n      if (supressEvent) { return; }\r\n      self.dispatchEvent('selectionchanged', {\r\n        selectedData: self.getSelectedData(),\r\n        selections: self.selections,\r\n        selectionBounds: self.getSelectionBounds()\r\n      });\r\n    };\r\n    /**\r\n     * Selects a row.\r\n     * @memberof canvasDatagrid\r\n     * @name selectRow\r\n     * @method\r\n     * @param {number} rowIndex The row index to select.\r\n     * @param {boolean} ctrl When true, behaves as if you were holding control/command when you clicked the row.\r\n     * @param {boolean} shift When true, behaves as if you were holding shift when you clicked the row.\r\n     * @param {boolean} supressSelectionchangedEvent When true, prevents the selectionchanged event from firing.\r\n     */\r\n    self.selectRow = function (rowIndex, ctrl, shift, supressEvent) {\r\n      var x, st, en, s = self.getVisibleSchema();\r\n      function de() {\r\n        if (supressEvent) { return; }\r\n        self.dispatchEvent('selectionchanged', {\r\n          selectedData: self.getSelectedData(),\r\n          selections: self.selections,\r\n          selectionBounds: self.selectionBounds\r\n        });\r\n      }\r\n      function addRow(ri) {\r\n        self.selections[ri] = [];\r\n        self.selections[ri].push(-1);\r\n        s.forEach(function (col, index) {\r\n          self.selections[ri].push(self.orders.columns.indexOf(col.index));\r\n        });\r\n      }\r\n      if (self.dragAddToSelection === false || self.dragObject === undefined) {\r\n        if (self.selections[rowIndex] && self.selections[rowIndex].length - 1 === s.length) {\r\n          if (ctrl) {\r\n            self.selections[rowIndex] = [];\r\n            de();\r\n            return;\r\n          }\r\n        }\r\n      }\r\n      if (self.dragAddToSelection === true || self.dragObject === undefined) {\r\n        if (shift && self.dragObject === undefined) {\r\n          if (!self.activeCell) { return; }\r\n          st = Math.min(self.activeCell.rowIndex, rowIndex);\r\n          en = Math.max(self.activeCell.rowIndex, rowIndex);\r\n          for (x = st; en >= x; x += 1) {\r\n            addRow(x);\r\n          }\r\n        } else {\r\n          addRow(rowIndex);\r\n        }\r\n      }\r\n      de();\r\n    };\r\n    /**\r\n     * Collapse a tree grid by row index.\r\n     * @memberof canvasDatagrid\r\n     * @name collapseTree\r\n     * @method\r\n     * @param {number} index The index of the row to collapse.\r\n     */\r\n    self.collapseTree = function (rowIndex) {\r\n      self.dispatchEvent('collapsetree', {\r\n        childGrid: self.childGrids[rowIndex],\r\n        data: self.data[rowIndex],\r\n        rowIndex: rowIndex\r\n      });\r\n      self.openChildren[rowIndex].blur();\r\n      self.openChildren[rowIndex].dispose();\r\n      delete self.openChildren[rowIndex];\r\n      delete self.sizes.trees[rowIndex];\r\n      delete self.childGrids[rowIndex];\r\n      self.dispatchEvent('resizerow', {\r\n        cellHeight: self.style.cellHeight\r\n      });\r\n      self.resize(true);\r\n      self.draw(true);\r\n    };\r\n    /**\r\n     * Expands a tree grid by row index.\r\n     * @memberof canvasDatagrid\r\n     * @name expandTree\r\n     * @method\r\n     * @param {number} index The index of the row to expand.\r\n     */\r\n    self.expandTree = function (rowIndex) {\r\n      var trArgs = self.args.treeGridAttributes || {},\r\n        columnHeaderCellHeight = self.getColumnHeaderCellHeight(),\r\n        rowHeaderCellWidth = self.sizes.columns.cornerCell || self.style.rowHeaderCellWidth,\r\n        h = self.sizes.trees[rowIndex] || self.style.treeGridHeight,\r\n        treeGrid;\r\n      if (!self.childGrids[rowIndex]) {\r\n        trArgs.debug = self.attributes.debug;\r\n        trArgs.name = self.attributes.saveAppearance ? self.attributes.name + 'tree' + rowIndex : undefined;\r\n        trArgs.style = trArgs.style || self.style;\r\n        trArgs.parentNode = {\r\n          parentGrid: self.intf,\r\n          nodeType: 'canvas-datagrid-tree',\r\n          offsetHeight: h,\r\n          offsetWidth: self.width - rowHeaderCellWidth,\r\n          header: { width: self.width - rowHeaderCellWidth },\r\n          offsetLeft: rowHeaderCellWidth,\r\n          offsetTop: columnHeaderCellHeight,\r\n          offsetParent: self.intf.parentNode,\r\n          parentNode: self.intf.parentNode,\r\n          style: 'tree',\r\n          data: self.data[rowIndex]\r\n        };\r\n        treeGrid = self.createGrid(trArgs);\r\n        self.childGrids[rowIndex] = treeGrid;\r\n      }\r\n      treeGrid = self.childGrids[rowIndex];\r\n      treeGrid.visible = true;\r\n      self.dispatchEvent('expandtree', {\r\n        treeGrid: treeGrid,\r\n        data: self.data[rowIndex],\r\n        rowIndex: rowIndex\r\n      });\r\n      self.openChildren[rowIndex] = treeGrid;\r\n      self.sizes.trees[rowIndex] = h;\r\n      self.dispatchEvent('resizerow', { height: self.style.cellHeight });\r\n      self.resize(true);\r\n    };\r\n    /**\r\n     * Toggles tree grid open and close by row index.\r\n     * @memberof canvasDatagrid\r\n     * @name toggleTree\r\n     * @method\r\n     * @param {number} index The index of the row to toggle.\r\n     */\r\n    self.toggleTree = function (rowIndex) {\r\n      var i = self.openChildren[rowIndex];\r\n      if (i) {\r\n        return self.collapseTree(rowIndex);\r\n      }\r\n      self.expandTree(rowIndex);\r\n    };\r\n    /**\r\n     * Returns a header from the schema by name.\r\n     * @memberof canvasDatagrid\r\n     * @name getHeaderByName\r\n     * @tutorial schema\r\n     * @method\r\n     * @returns {header} header with the selected name, or undefined.\r\n     * @param {string} name The name of the column to resize.\r\n     */\r\n    self.getHeaderByName = function (name) {\r\n      var x, i = self.getSchema();\r\n      for (x = 0; x < i.length; x += 1) {\r\n        if (i[x].name === name) {\r\n          return i[x];\r\n        }\r\n      }\r\n    };\r\n    /**\r\n     * Resizes a column to fit the longest value in the column. Call without a value to resize all columns.\r\n     * Warning, can be slow on very large record sets (1m records ~3-5 seconds on an i7).\r\n     * @memberof canvasDatagrid\r\n     * @name fitColumnToValues\r\n     * @method\r\n     * @param {string} name The name of the column to resize.\r\n     */\r\n    self.fitColumnToValues = function (name, internal) {\r\n      if (!self.canvas) { return; }\r\n      self.sizes.columns[name === 'cornerCell' ? -1 : self.getHeaderByName(name).index]\r\n        = Math.max(self.findColumnMaxTextLength(name), self.style.minColumnWidth);\r\n      if (!internal) {\r\n        self.resize();\r\n        self.draw(true);\r\n      }\r\n    };\r\n    /**\r\n     * Checks if a cell is currently visible.\r\n     * @memberof canvasDatagrid\r\n     * @name isCellVisible\r\n     * @overload\r\n     * @method\r\n     * @returns {boolean} when true, the cell is visible, when false the cell is not currently drawn.\r\n     * @param {number} columnIndex The column index of the cell to check.\r\n     * @param {number} rowIndex The row index of the cell to check.\r\n     */\r\n    self.isCellVisible = function (cell, rowIndex) {\r\n      // overload\r\n      if (rowIndex !== undefined) {\r\n        return self.visibleCells.filter(function (c) {\r\n          return c.columnIndex === cell && c.rowIndex === rowIndex;\r\n        }).length > 0;\r\n      }\r\n      var x, l = self.visibleCells.length;\r\n      for (x = 0; x < l; x += 1) {\r\n        if (cell.x === self.visibleCells[x].x && cell.y === self.visibleCells[x].y) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    /**\r\n     * Sets the order of the data.\r\n     * @memberof canvasDatagrid\r\n     * @name order\r\n     * @method\r\n     * @param {number} columnName Name of the column to be sorted.\r\n     * @param {string} direction `asc` for ascending or `desc` for descending.\r\n     * @param {function} [sortFunction] When defined, override the default sorting method defined in the column's schema and use this one.\r\n     * @param {bool} [dontSetStorageData] Don't store this setting for future use.\r\n     */\r\n    self.order = function (columnName, direction, sortFunction, dontSetStorageData) {\r\n      var f,\r\n        c = self.getSchema().filter(function (col) {\r\n          return col.name === columnName;\r\n        });\r\n      if (self.dispatchEvent('beforesortcolumn', { name: columnName, direction: direction })) { return; }\r\n      self.orderBy = columnName;\r\n      self.orderDirection = direction;\r\n      if (!self.data || self.data.length === 0) { return; }\r\n      if (c.length === 0) {\r\n        throw new Error('Cannot sort.  No such column name');\r\n      }\r\n      f = sortFunction || c[0].sorter || self.sorters[c[0].type];\r\n      if (!f && c[0].type !== undefined) {\r\n        console.warn('Cannot sort type \"%s\" falling back to string sort.', c[0].type);\r\n      }\r\n      self.orderings.add(columnName, direction, (typeof f === 'function' ? f : self.sorters.string));\r\n      self.orderings.sort();\r\n      self.dispatchEvent('sortcolumn', { name: columnName, direction: direction });\r\n      self.draw(true);\r\n      if (dontSetStorageData) { return; }\r\n      self.setStorageData();\r\n    };\r\n    self.isInGrid = function (e) {\r\n      if (e.x < 0\r\n        || e.x > self.width\r\n        || e.y < 0\r\n        || e.y > self.height) {\r\n        return false;\r\n      }\r\n      return true;\r\n    };\r\n    /**\r\n     * Moves the current selection relative to the its current position.  Note: this method does not move the selected data, just the selection itself.\r\n     * @memberof canvasDatagrid\r\n     * @name moveSelection\r\n     * @method\r\n     * @param {number} offsetX The number of columns to offset the selection.\r\n     * @param {number} offsetY The number of rows to offset the selection.\r\n     */\r\n    self.moveSelection = function (offsetX, offsetY) {\r\n      var sel = [];\r\n      self.selections.forEach(function (row, rowIndex) {\r\n        sel[rowIndex + offsetY] = [];\r\n        row.forEach(function (colIndex) {\r\n          sel[rowIndex + offsetY].push(colIndex + offsetX);\r\n        });\r\n      });\r\n      self.selections = sel;\r\n    };\r\n    /**\r\n     * Moves data in the provided selection to another position in the grid.  Moving data off the edge of the schema (columns/x) will truncate data.\r\n     * @memberof canvasDatagrid\r\n     * @name moveTo\r\n     * @method\r\n     * @param {array} sel 2D array representing selected rows and columns.  `canvasDatagrid.selections` is in this format and can be used here.\r\n     * @param {number} x The column index to start inserting the selection at.\r\n     * @param {number} y The row index to start inserting the selection at.\r\n     */\r\n    self.moveTo = function (sel, x, y) {\r\n      var d = self.getSelectedData(),\r\n        s = self.getVisibleSchema(),\r\n        l = sel.length,\r\n        xi,\r\n        maxRowLength = -Infinity,\r\n        minXi = Infinity,\r\n        yi = y - 1;\r\n      sel.forEach(function (row, index) {\r\n        if (index === l) { return; }\r\n        if (row.length === 0) { return; }\r\n        minXi = Math.min(self.getVisibleColumnIndexOf(x), minXi);\r\n        maxRowLength = Math.max(maxRowLength, row.length);\r\n        row.forEach(function (colIndex) {\r\n          // intentional redef of colIndex\r\n          colIndex = self.getVisibleColumnIndexOf(colIndex);\r\n          if (!s[colIndex]) { return; }\r\n          if (!self.data[index]) { self.data[index] = {}; }\r\n          self.data[index][s[colIndex].name] = null;\r\n        });\r\n      });\r\n      sel.forEach(function (row, index) {\r\n        var lastSourceIndex;\r\n        yi += 1;\r\n        xi = self.getVisibleColumnIndexOf(x);\r\n        row.forEach(function (colIndex, cidx) {\r\n          colIndex = self.getVisibleColumnIndexOf(colIndex);\r\n          if (cidx > 0) {\r\n            // this confusing bit of nonsense figures out\r\n            // if the selection has skipped cells\r\n            xi += colIndex - lastSourceIndex;\r\n          }\r\n          lastSourceIndex = colIndex;\r\n          if (colIndex === -1\r\n            || !s[xi]\r\n            || !s[colIndex]\r\n            || self.data.length - 1 < yi\r\n            || yi < 0) { return; }\r\n          if (!self.data[yi]) { self.data[yi] = {}; }\r\n          self.data[yi][s[xi].name] = d[index][s[colIndex].name];\r\n        });\r\n      });\r\n    };\r\n    /**\r\n     * Checks if a given column is visible.\r\n     * @memberof canvasDatagrid\r\n     * @name isColumnVisible\r\n     * @method\r\n     * @returns {boolean} When true, the column is visible.\r\n     * @param {number} columnIndex Column index.\r\n     */\r\n    self.isColumnVisible = function (columnIndex) {\r\n      return self.visibleCells.filter(function (c) {\r\n        return c.columnIndex === columnIndex;\r\n      }).length > 0;\r\n    };\r\n    /**\r\n     * Checks if a given row is visible.\r\n     * @memberof canvasDatagrid\r\n     * @name isRowVisible\r\n     * @method\r\n     * @returns {boolean} When true, the row is visible.\r\n     * @param {number} rowIndex Row index.\r\n     */\r\n    self.isRowVisible = function (rowIndex) {\r\n      return self.visibleCells.filter(function (c) {\r\n        return c.rowIndex === rowIndex;\r\n      }).length > 0;\r\n    };\r\n    /**\r\n     * Gets the cell at columnIndex and rowIndex.\r\n     * @memberof canvasDatagrid\r\n     * @name getVisibleCellByIndex\r\n     * @method\r\n     * @returns {cell} cell at the selected location.\r\n     * @param {number} x Column index.\r\n     * @param {number} y Row index.\r\n     */\r\n    self.getVisibleCellByIndex = function (x, y) {\r\n      return self.visibleCells.filter(function (c) {\r\n        return c.columnIndex === x && c.rowIndex === y;\r\n      })[0];\r\n    };\r\n    /**\r\n     * Gets the cell at grid pixel coordinate x and y.  Author's note.  This function ties drawing and events together.  This is a very complex function and is core to the component.\r\n     * @memberof canvasDatagrid\r\n     * @name getCellAt\r\n     * @method\r\n     * @returns {cell} cell at the selected location.\r\n     * @param {number} x Number of pixels from the left.\r\n     * @param {number} y Number of pixels from the top.\r\n     */\r\n    self.getCellAt = function (x, y, useTouchScrollZones, checkFrozenRow, mustFrozenRow) {\r\n      function getBorder(entitiy) {\r\n        if (entitiy.x + entitiy.width - (self.attributes.borderResizeZone * 0.4) < x && entitiy.x + entitiy.width + (self.attributes.borderResizeZone * 0.6) > x) {\r\n          return 'r';\r\n        }\r\n        if (entitiy.x - (self.attributes.borderResizeZone * 0.4) < x && entitiy.x + (self.attributes.borderResizeZone * 0.6) > x) {\r\n          return 'l';\r\n        }\r\n        if (entitiy.y + entitiy.height - (self.attributes.borderResizeZone * 0.4) < y && entitiy.y + entitiy.height + (self.attributes.borderResizeZone * 0.6) > y) {\r\n          return 'b';\r\n        }\r\n        if (entitiy.y - (self.attributes.borderResizeZone * 0.4) < y && entitiy.y + (self.attributes.borderResizeZone * 0.6) > y) {\r\n          return 't';\r\n        }\r\n      }\r\n      if (!self.visibleCells) { return; }\r\n      var border,\r\n        tsz = useTouchScrollZones ? self.attributes.touchScrollZone : 0,\r\n        moveMode = self.attributes.borderDragBehavior === 'move',\r\n        i,\r\n        l = self.visibleCells.length,\r\n        moveBorder,\r\n        xBorderBehavior = moveMode ? self.cursorGrab : 'ew-resize',\r\n        yBorderBehavior = moveMode ? self.cursorGrab : 'ns-resize',\r\n        cell,\r\n        entitiy;\r\n      if (!self.visibleCells || !self.visibleCells.length) { return; }\r\n      self.hasFocus = true;\r\n      if (!(y < self.height\r\n        && y > 0\r\n        && x < self.width\r\n        && x > 0)) {\r\n        self.hasFocus = false;\r\n        return {\r\n          dragContext: 'inherit',\r\n          context: 'inherit'\r\n        };\r\n      }\r\n      for (i = 0; i < l; i += 1) {\r\n        cell = self.visibleCells[i];\r\n\r\n        // interactive dimensions of the cell.  used for touch \"over size\" zones\r\n        entitiy = {\r\n          x: cell.x,\r\n          y: cell.y,\r\n          height: cell.height,\r\n          width: cell.width\r\n        };\r\n        if (useTouchScrollZones && /(vertical|horizontal)-scroll-/.test(cell.style)) {\r\n          entitiy.x -= tsz;\r\n          entitiy.y -= tsz;\r\n          entitiy.height += tsz;\r\n          entitiy.width += tsz;\r\n        }\r\n        if (entitiy.x - self.style.cellBorderWidth < x\r\n          && entitiy.x + entitiy.width + self.style.cellBorderWidth > x\r\n          && entitiy.y - self.style.cellBorderWidth < y\r\n          && entitiy.y + entitiy.height + self.style.cellBorderWidth > y) {\r\n\r\n          if (mustFrozenRow) {\r\n            if (cell == null || cell.data == null || cell.data.pinnedIndex == null) {\r\n              cell = null;\r\n              continue;\r\n            }\r\n          }\r\n\r\n          if (/frozen-row-marker/.test(cell.style)) {\r\n            cell.dragContext = cell.style;\r\n            cell.context = 'row-resize';\r\n            return cell;\r\n          }\r\n          if (/frozen-column-marker/.test(cell.style)) {\r\n            cell.dragContext = cell.style;\r\n            cell.context = 'col-resize';\r\n            return cell;\r\n          }\r\n          if (/selection-handle-/.test(cell.style)) {\r\n            cell.dragContext = cell.style;\r\n            cell.context = 'crosshair';\r\n            return cell;\r\n          }\r\n          if (/vertical-scroll-(bar|box)/.test(cell.style)) {\r\n            cell.dragContext = 'vertical-scroll-box';\r\n            cell.context = 'vertical-scroll-box';\r\n            cell.isScrollBar = true;\r\n            cell.isVerticalScrollBar = true;\r\n            if (y > self.scrollBox.box.v.y + self.scrollBox.scrollBoxHeight) {\r\n              cell.dragContext = 'vertical-scroll-bottom';\r\n              cell.context = 'vertical-scroll-bottom';\r\n            } else if (y < self.scrollBox.box.v.y) {\r\n              cell.dragContext = 'vertical-scroll-top';\r\n              cell.context = 'vertical-scroll-top';\r\n            }\r\n            self.cursor = 'default';\r\n            return cell;\r\n          }\r\n          if (/horizontal-scroll-(bar|box)/.test(cell.style)) {\r\n            cell.dragContext = 'horizontal-scroll-box';\r\n            cell.context = 'horizontal-scroll-box';\r\n            cell.isScrollBar = true;\r\n            cell.isHorizontalScrollBar = true;\r\n            if (x > self.scrollBox.box.h.x + self.scrollBox.scrollBoxWidth) {\r\n              cell.dragContext = 'horizontal-scroll-right';\r\n              cell.context = 'horizontal-scroll-right';\r\n            } else if (x < self.scrollBox.box.h.x) {\r\n              cell.dragContext = 'horizontal-scroll-left';\r\n              cell.context = 'horizontal-scroll-left';\r\n            }\r\n            self.cursor = 'default';\r\n            return cell;\r\n          }\r\n          border = getBorder(entitiy);\r\n          // check if the border of this cell is the border of the selection and if so show move cursor in move mode\r\n          moveBorder = moveMode && cell.selectionBorder && cell.selectionBorder.indexOf(border) !== -1;\r\n          if (['l', 'r'].indexOf(border) !== -1\r\n            && (self.attributes.allowColumnResize || moveBorder)\r\n            && ((self.attributes.allowColumnResizeFromCell && cell.isNormal) || !cell.isNormal || moveBorder)\r\n            && ((self.attributes.allowRowHeaderResize && (cell.isRowHeader || cell.isCorner)) || !(cell.isRowHeader && cell.isCorner))) {\r\n            if (((cell.isColumnHeader || cell.isCorner) || (self.attributes.allowColumnResizeFromCell && cell.isNormal)) && border === 'r') {\r\n              cell.context = 'ew-resize';\r\n              cell.dragContext = 'ew-resize';\r\n              return cell;\r\n            }\r\n            if (!(cell.isColumnHeader || cell.isCorner) && moveBorder) {\r\n              cell.context = xBorderBehavior;\r\n              cell.dragContext = border + '-move';\r\n              return cell;\r\n            }\r\n          }\r\n          if (['t', 'b'].indexOf(border) !== -1\r\n            && cell.rowIndex > -1\r\n            && (self.attributes.allowRowResize || moveBorder)\r\n            && ((self.attributes.allowRowResizeFromCell && cell.isNormal) || !cell.isNormal || moveBorder)\r\n            && !cell.isColumnHeader) {\r\n            if (((cell.isRowHeader || cell.isCorner) || (self.attributes.allowRowResizeFromCell && cell.isNormal)) && border === 'b') {\r\n              cell.context = 'ns-resize';\r\n              cell.dragContext = 'ns-resize';\r\n              return cell;\r\n            }\r\n            if (!(cell.isRowHeader || cell.isCorner) && moveBorder) {\r\n              cell.context = yBorderBehavior;\r\n              cell.dragContext = border + '-move';\r\n              return cell;\r\n            }\r\n          }\r\n          if (cell.style === 'columnHeaderCell') {\r\n            if (cell.header && (cell.header.name === 's' || cell.header.name === 'pinned')) {\r\n              cell.context = 'cell';\r\n            } else {\r\n              cell.context = self.cursorGrab;\r\n            }\r\n\r\n            cell.dragContext = 'column-reorder';\r\n            return cell;\r\n          }\r\n          if (cell.style === 'rowHeaderCell') {\r\n            if ((self.attributes.rowGrabZoneSize + (cell.height / 2 + cell.y - self.style.cellBorderWidth) < y)\r\n              || !self.attributes.allowRowReordering) {\r\n              cell.dragContext = 'cell';\r\n              cell.context = 'cell';\r\n            } else {\r\n              cell.context = self.cursorGrab;\r\n              cell.dragContext = 'row-reorder';\r\n            }\r\n            return cell;\r\n          }\r\n          if (cell.isGrid) {\r\n            self.hasFocus = false;\r\n            cell.dragContext = 'cell-grid';\r\n            cell.context = 'cell-grid';\r\n            return cell;\r\n          }\r\n          if (cell.style === 'tree-grid') {\r\n            self.hasFocus = false;\r\n            cell.dragContext = 'tree';\r\n            cell.context = 'tree';\r\n            return cell;\r\n          }\r\n\r\n          if (checkFrozenRow && cell) {\r\n            if (cell.data && cell.data.pinnedIndex == null) {\r\n              const frozenCell = self.getCellAt(x, y, false, false, true);\r\n              if (frozenCell && frozenCell.data && frozenCell.data.pinnedIndex != null) {\r\n                cell = frozenCell;\r\n              }\r\n            }\r\n          }\r\n\r\n          cell.dragContext = 'cell';\r\n          cell.context = 'cell';\r\n          return cell;\r\n        }\r\n      }\r\n      self.hasFocus = true;\r\n      self.cursor = 'default';\r\n      return {\r\n        dragContext: 'background',\r\n        context: 'background',\r\n        style: 'background',\r\n        isBackground: true\r\n      };\r\n    };\r\n    /**\r\n     * Gets the bounds of current selection. \r\n     * @returns {rect} selection.\r\n     * @memberof canvasDatagrid\r\n     * @name getSelectionBounds\r\n     * @method\r\n     */\r\n    self.getSelectionBounds = function () {\r\n      var low = { x: Infinity, y: Infinity },\r\n        high = { x: -Infinity, y: -Infinity };\r\n      self.selections.forEach(function (row, rowIndex) {\r\n        var maxCol, minCol;\r\n        low.y = rowIndex < low.y ? rowIndex : low.y;\r\n        high.y = rowIndex > high.y ? rowIndex : high.y;\r\n        maxCol = Math.max.apply(null, row);\r\n        minCol = Math.min.apply(null, row);\r\n        low.x = minCol < low.x ? minCol : low.x;\r\n        high.x = maxCol > high.x ? maxCol : high.x;\r\n      });\r\n      return {\r\n        top: low.y,\r\n        left: low.x,\r\n        bottom: high.y,\r\n        right: high.x\r\n      };\r\n    };\r\n    /**\r\n     * Returns an auto generated schema based on data structure.\r\n     * @memberof canvasDatagrid\r\n     * @name getSchemaFromData\r\n     * @method\r\n     * @tutorial schema\r\n     * @returns {schema} schema A schema based on the first item in the data array.\r\n     */\r\n    self.getSchemaFromData = function (d) {\r\n      d = d || self.data;\r\n      return Object.keys(d[0] || { ' ': '' }).map(function mapEachSchemaColumn(key, index) {\r\n        var type = self.getBestGuessDataType(key, d),\r\n          i = {\r\n            name: key,\r\n            title: isNaN(parseInt(key, 10)) ? key : self.integerToAlpha(key).toUpperCase(),\r\n            index: index,\r\n            columnIndex: index,\r\n            type: type,\r\n            filter: self.filter(type)\r\n          };\r\n        if (self.storedSettings\r\n          && self.storedSettings.visibility\r\n          && self.storedSettings.visibility[i.name] !== undefined) {\r\n          i.hidden = !self.storedSettings.visibility[i.name];\r\n        }\r\n        return i;\r\n      });\r\n    };\r\n    /**\r\n     * Clears the change log grid.changes that keeps track of changes to the data set.\r\n     * This does not undo changes or alter data it is simply a convince array to keep\r\n     * track of changes made to the data since last this method was called.\r\n     * @memberof canvasDatagrid\r\n     * @name clearChangeLog\r\n     * @method\r\n     */\r\n    self.clearChangeLog = function () {\r\n      self.changes = [];\r\n    };\r\n    /**\r\n     * Selects an area of the grid.\r\n     * @memberof canvasDatagrid\r\n     * @name selectArea\r\n     * @method\r\n     * @param {rect} bounds A rect object representing the selected values.\r\n     */\r\n    self.selectArea = function (bounds, ctrl) {\r\n      self.selectionBounds = bounds || self.selectionBounds;\r\n      var ev, x, y, s = self.getSchema();\r\n      if (!ctrl) {\r\n        self.selections = [];\r\n      }\r\n      if (self.selectionBounds.top < -1\r\n        || self.selectionBounds.bottom > self.data.length\r\n        || self.selectionBounds.left < -1\r\n        || self.selectionBounds.right > s.length) {\r\n        throw new Error('Impossible selection area');\r\n      }\r\n      for (x = self.selectionBounds.top; x <= self.selectionBounds.bottom; x += 1) {\r\n        self.selections[x] = [];\r\n        for (y = self.selectionBounds.left; y <= self.selectionBounds.right; y += 1) {\r\n          if (self.selections[x].indexOf(y) === -1) {\r\n            self.selections[x].push(y);\r\n          }\r\n        }\r\n      }\r\n      ev = {\r\n        selections: self.selections,\r\n        selectionBounds: self.selectionBounds\r\n      };\r\n      Object.defineProperty(ev, 'selectedData', {\r\n        get: function () {\r\n          return self.getSelectedData();\r\n        }\r\n      });\r\n      self.dispatchEvent('selectionchanged', ev);\r\n    };\r\n    /**\r\n     * Returns the maximum text width for a given column by column name.\r\n     * @memberof canvasDatagrid\r\n     * @name findColumnMaxTextLength\r\n     * @method\r\n     * @returns {number} The number of pixels wide the maximum width value in the selected column.\r\n     * @param {string} name The name of the column to calculate the value's width of.\r\n     */\r\n    self.findColumnMaxTextLength = function (name) {\r\n      var m = -Infinity;\r\n      if (name === 'cornerCell') {\r\n        self.ctx.font = self.style.rowHeaderCellFont;\r\n        return self.ctx.measureText((self.data.length + (self.attributes.showNewRow ? 1 : 0)).toString()).width\r\n          + self.style.autosizePadding + self.style.autosizeHeaderCellPadding\r\n          + self.style.rowHeaderCellPaddingRight\r\n          + self.style.rowHeaderCellPaddingLeft\r\n          + (self.attributes.tree ? self.style.treeArrowWidth\r\n            + self.style.treeArrowMarginLeft + self.style.treeArrowMarginRight : 0);\r\n      }\r\n      self.getSchema().forEach(function (col) {\r\n        if (col.name !== name) { return; }\r\n        self.ctx.font = self.style.columnHeaderCellFont;\r\n        var t = self.ctx.measureText(col.title || col.name).width\r\n          + self.style.headerCellPaddingRight\r\n          + self.style.headerCellPaddingLeft;\r\n        m = t > m ? t : m;\r\n      });\r\n      self.data.forEach(function (row) {\r\n        self.ctx.font = self.style.cellFont;\r\n        var t = self.ctx.measureText(row[name]).width\r\n          + self.style.cellPaddingRight\r\n          + self.style.cellPaddingLeft + self.style.cellAutoResizePadding;\r\n        m = t > m ? t : m;\r\n      });\r\n      return m;\r\n    };\r\n    /**\r\n     * Gets the total width of all header columns.\r\n     * @memberof canvasDatagrid\r\n     * @name getHeaderWidth\r\n     * @method\r\n     */\r\n    self.getHeaderWidth = function () {\r\n      return self.getVisibleSchema().reduce(function (total, header) {\r\n        return total + (header.width || self.style.cellWidth);\r\n      }, 0);\r\n    };\r\n    /**\r\n     * Gets the height of a row by index.\r\n     * @memberof canvasDatagrid\r\n     * @name getRowHeight\r\n     * @method\r\n     * @param {number} rowIndex The row index to lookup.\r\n     */\r\n    self.getRowHeight = function (rowIndex) {\r\n      return ((self.sizes.rows[rowIndex]\r\n        || self.style.cellHeight) * self.scale);\r\n    };\r\n    /**\r\n     * Gets the width of a column by index.\r\n     * @memberof canvasDatagrid\r\n     * @name getColummnWidth\r\n     * @method\r\n     * @param {number} columnIndex The column index to lookup.\r\n     */\r\n    self.getColummnWidth = function (columnIndex) {\r\n      return ((self.sizes.columns[columnIndex]\r\n        || self.getSchema()[columnIndex].width\r\n        || self.style.cellWidth) * self.scale);\r\n    };\r\n    self.formatters.string = function cellFormatterString(e) {\r\n      return e.cell.value !== undefined ? e.cell.value : '';\r\n    };\r\n    self.formatters.rowHeaderCell = self.formatters.string;\r\n    self.formatters.headerCell = self.formatters.string;\r\n    self.formatters.number = self.formatters.string;\r\n    self.formatters.int = self.formatters.string;\r\n    self.formatters.html = self.formatters.string;\r\n    self.sorters.string = function (columnName, direction) {\r\n      var asc = direction === 'asc';\r\n      return function (a, b) {\r\n        if (a[columnName] === undefined || a[columnName] === null) {\r\n          return 1;\r\n        }\r\n        if (b[columnName] === undefined || b[columnName] === null) {\r\n          return 0;\r\n        }\r\n        if (asc) {\r\n          if (!a[columnName].localeCompare) { return 1; }\r\n          return a[columnName].localeCompare(b[columnName]);\r\n        }\r\n        if (!b[columnName].localeCompare) { return 1; }\r\n        return b[columnName].localeCompare(a[columnName]);\r\n      };\r\n    };\r\n    self.sorters.number = function (columnName, direction) {\r\n      var asc = direction === 'asc';\r\n      return function (a, b) {\r\n        if (asc) {\r\n          return a[columnName] - b[columnName];\r\n        }\r\n        return b[columnName] - a[columnName];\r\n      };\r\n    };\r\n    self.sorters.date = function (columnName, direction) {\r\n      var asc = direction === 'asc';\r\n      return function (a, b) {\r\n        if (asc) {\r\n          return new Date(a[columnName]).getTime()\r\n            - new Date(b[columnName]).getTime();\r\n        }\r\n        return new Date(b[columnName]).getTime()\r\n          - new Date(a[columnName]).getTime();\r\n      };\r\n    };\r\n  };\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// canvas-datagrid.js","/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine([], function () {\r\n  'use strict';\r\n  return function (self) {\r\n    self.defaults = {\r\n      attributes: [\r\n        ['allowColumnReordering', true],\r\n        ['allowColumnResize', true],\r\n        ['allowColumnResizeFromCell', false],\r\n        ['allowFreezingRows', false],\r\n        ['allowFreezingColumns', false],\r\n        ['allowMovingSelection', true],\r\n        ['allowRowHeaderResize', true],\r\n        ['allowRowReordering', false],\r\n        ['allowRowResize', true],\r\n        ['allowRowResizeFromCell', false],\r\n        ['allowSorting', true],\r\n        ['autoGenerateSchema', false],\r\n        ['autoResizeColumns', false],\r\n        ['borderDragBehavior', 'none'],\r\n        ['borderResizeZone', 10],\r\n        ['clearSettingsOptionText', 'Clear saved settings'],\r\n        ['columnHeaderClickBehavior', 'sort'],\r\n        ['columnSelectorHiddenText', '&nbsp;&nbsp;&nbsp;'],\r\n        ['columnSelectorText', 'Add/Remove columns'],\r\n        ['columnSelectorVisibleText', '\\u2713'],\r\n        ['contextHoverScrollAmount', 2],\r\n        ['contextHoverScrollRateMs', 5],\r\n        ['copyHeadersOnSelectAll', true],\r\n        ['copyText', 'Copy'],\r\n        ['debug', false],\r\n        ['editable', true],\r\n        ['ellipsisText', '...'],\r\n        ['filterOptionText', 'Filter %s'],\r\n        ['filterTextPrefix', '(filtered) '],\r\n        ['globalRowResize', false],\r\n        ['hideColumnText', 'Hide %s'],\r\n        ['maxAutoCompleteItems', 200],\r\n        ['multiLine', false],\r\n        ['name', ''],\r\n        ['pageUpDownOverlap', 1],\r\n        ['pasteText', 'Paste'],\r\n        ['persistantSelectionMode', false],\r\n        ['removeFilterOptionText', 'Remove filter on %s'],\r\n        ['reorderDeadZone', 3],\r\n        ['resizeScrollZone', 20],\r\n        ['rowGrabZoneSize', 10],\r\n        ['saveAppearance', true],\r\n        ['scrollAnimationPPSThreshold', 0.75],\r\n        ['scrollPointerLock', false],\r\n        ['scrollRepeatRate', 75],\r\n        ['selectionFollowsActiveCell', false],\r\n        ['selectionHandleBehavior', 'none'],\r\n        ['selectionMode', 'cell'],\r\n        ['selectionScrollIncrement', 20],\r\n        ['selectionScrollZone', 20],\r\n        ['showClearSettingsOption', true],\r\n        ['showColumnHeaders', true],\r\n        ['showColumnSelector', true],\r\n        ['showCopy', false],\r\n        ['showFilter', true],\r\n        ['showNewRow', false],\r\n        ['showOrderByOption', true],\r\n        ['showOrderByOptionTextAsc', 'Order by %s ascending'],\r\n        ['showOrderByOptionTextDesc', 'Order by %s descending'],\r\n        ['showPaste', false],\r\n        ['showPerformance', false],\r\n        ['showRowHeaders', true],\r\n        ['showRowNumbers', true],\r\n        ['singleSelectionMode', false],\r\n        ['snapToRow', false],\r\n        ['touchContextMenuTimeMs', 800],\r\n        ['touchDeadZone', 3],\r\n        ['touchEasingMethod', 'easeOutQuad'],\r\n        ['touchReleaseAcceleration', 1000],\r\n        ['touchReleaseAnimationDurationMs', 2000],\r\n        ['touchScrollZone', 20],\r\n        ['touchSelectHandleZone', 20],\r\n        ['touchZoomSensitivity', 0.005],\r\n        ['touchZoomMin', 0.5],\r\n        ['touchZoomMax', 1.75],\r\n        ['maxPixelRatio', 2],\r\n        ['tree', false],\r\n        ['treeHorizontalScroll', false]\r\n      ],\r\n      styles: [\r\n        ['activeCellBackgroundColor', 'rgba(255, 255, 255, 1)'],\r\n        ['activeCellBorderColor', 'rgba(110, 168, 255, 1)'],\r\n        ['activeCellBorderWidth', 1],\r\n        ['activeCellColor', 'rgba(0, 0, 0, 1)'],\r\n        ['activeCellFont', '16px sans-serif'],\r\n        ['activeCellHoverBackgroundColor', 'rgba(255, 255, 255, 1)'],\r\n        ['activeCellHorizontalAlignment', 'left'],\r\n        ['activeCellHoverColor', 'rgba(0, 0, 0, 1)'],\r\n        ['activeCellOverlayBorderColor', 'rgba(66, 133, 244, 1)'],\r\n        ['activeCellOverlayBorderWidth', 1],\r\n        ['activeCellPaddingBottom', 5],\r\n        ['activeCellPaddingLeft', 5],\r\n        ['activeCellPaddingRight', 5],\r\n        ['activeCellPaddingTop', 5],\r\n        ['activeCellSelectedBackgroundColor', 'rgba(236, 243, 255, 1)'],\r\n        ['activeCellSelectedColor', 'rgba(0, 0, 0, 1)'],\r\n        ['activeCellVerticalAlignment', 'center'],\r\n        ['activeColumnHeaderCellBackgroundColor', 'rgba(225, 225, 225, 1)'],\r\n        ['activeColumnHeaderCellColor', 'rgba(0, 0, 0, 1)'],\r\n        ['activeRowHeaderCellBackgroundColor', 'rgba(225, 225, 225, 1)'],\r\n        ['activeRowHeaderCellColor', 'rgba(0, 0, 0, 1)'],\r\n        ['autocompleteBottomMargin', 60],\r\n        ['autosizeHeaderCellPadding', 8],\r\n        ['autosizePadding', 5],\r\n        ['cellAutoResizePadding', 13],\r\n        ['cellBackgroundColor', 'rgba(255, 255, 255, 1)'],\r\n        ['cellBorderColor', 'rgba(195, 199, 202, 1)'],\r\n        ['cellBorderWidth', 1],\r\n        ['cellColor', 'rgba(0, 0, 0, 1)'],\r\n        ['cellFont', '16px sans-serif'],\r\n        ['cellGridHeight', 250],\r\n        ['cellHeight', 24],\r\n        ['cellHeightWithChildGrid', 150],\r\n        ['cellHorizontalAlignment', 'left'],\r\n        ['cellHoverBackgroundColor', 'rgba(255, 255, 255, 1)'],\r\n        ['cellHoverColor', 'rgba(0, 0, 0, 1)'],\r\n        ['cellPaddingBottom', 5],\r\n        ['cellPaddingLeft', 5],\r\n        ['cellPaddingRight', 5],\r\n        ['cellPaddingTop', 5],\r\n        ['cellSelectedBackgroundColor', 'rgba(236, 243, 255, 1)'],\r\n        ['cellSelectedColor', 'rgba(0, 0, 0, 1)'],\r\n        ['cellVerticalAlignment', 'center'],\r\n        ['cellWidth', 250],\r\n        ['cellWidthWithChildGrid', 250],\r\n        ['cellWhiteSpace', 'nowrap'],\r\n        ['cellLineHeight', 1],\r\n        ['cellLineSpacing', 3],\r\n        ['childContextMenuArrowColor', 'rgba(43, 48, 43, 1)'],\r\n        ['childContextMenuArrowHTML', '&#x25BA;'],\r\n        ['childContextMenuMarginLeft', -11],\r\n        ['childContextMenuMarginTop', -6],\r\n        ['columnHeaderCellBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n        ['columnHeaderCellBorderColor', 'rgba(172, 172, 172, 1)'],\r\n        ['columnHeaderCellBorderWidth', 1],\r\n        ['columnHeaderCellCapBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n        ['columnHeaderCellCapBorderColor', 'rgba(172, 172, 172, 1)'],\r\n        ['columnHeaderCellCapBorderWidth', 1],\r\n        ['columnHeaderCellColor', 'rgba(50, 50, 50, 1)'],\r\n        ['columnHeaderCellFont', '16px sans-serif'],\r\n        ['columnHeaderCellHeight', 25],\r\n        ['columnHeaderCellHorizontalAlignment', 'left'],\r\n        ['columnHeaderCellHoverBackgroundColor', 'rgba(235, 235, 235, 1)'],\r\n        ['columnHeaderCellHoverColor', 'rgba(0, 0, 0, 1)'],\r\n        ['columnHeaderCellPaddingBottom', 5],\r\n        ['columnHeaderCellPaddingLeft', 5],\r\n        ['columnHeaderCellPaddingRight', 5],\r\n        ['columnHeaderCellPaddingTop', 5],\r\n        ['columnHeaderCellVerticalAlignment', 'center'],\r\n        ['columnHeaderOrderByArrowBorderColor', 'rgba(195, 199, 202, 1)'],\r\n        ['columnHeaderOrderByArrowBorderWidth', 1],\r\n        ['columnHeaderOrderByArrowColor', 'rgba(155, 155, 155, 1)'],\r\n        ['columnHeaderOrderByArrowHeight', 8],\r\n        ['columnHeaderOrderByArrowMarginLeft', 0],\r\n        ['columnHeaderOrderByArrowMarginRight', 5],\r\n        ['columnHeaderOrderByArrowMarginTop', 6],\r\n        ['columnHeaderOrderByArrowWidth', 13],\r\n        ['contextFilterButtonBorder', 'solid 1px rgba(158, 163, 169, 1)'],\r\n        ['contextFilterButtonBorderRadius', '3px'],\r\n        ['contextFilterButtonHTML', '&#x25BC;'],\r\n        ['contextFilterInputBackground', 'rgba(255,255,255,1)'],\r\n        ['contextFilterInputBorder', 'solid 1px rgba(158, 163, 169, 1)'],\r\n        ['contextFilterInputBorderRadius', '0'],\r\n        ['contextFilterInputColor', 'rgba(0,0,0,1)'],\r\n        ['contextFilterInputFontFamily', 'sans-serif'],\r\n        ['contextFilterInputFontSize', '14px'],\r\n        ['contextFilterInvalidRegExpBackground', 'rgba(180, 6, 1, 1)'],\r\n        ['contextFilterInvalidRegExpColor', 'rgba(255, 255, 255, 1)'],\r\n        ['contextMenuArrowColor', 'rgba(43, 48, 43, 1)'],\r\n        ['contextMenuArrowDownHTML', '&#x25BC;'],\r\n        ['contextMenuArrowUpHTML', '&#x25B2;'],\r\n        ['contextMenuBackground', 'rgba(240, 240, 240, 1)'],\r\n        ['contextMenuBorder', 'solid 1px rgba(158, 163, 169, 1)'],\r\n        ['contextMenuBorderRadius', '3px'],\r\n        ['contextMenuChildArrowFontSize', '12px'],\r\n        ['contextMenuColor', 'rgba(43, 48, 43, 1)'],\r\n        ['contextMenuCursor', 'default'],\r\n        ['contextMenuFilterButtonFontFamily', 'sans-serif'],\r\n        ['contextMenuFilterButtonFontSize', '10px'],\r\n        ['contextMenuFilterInvalidExpresion', 'rgba(237, 155, 156, 1)'],\r\n        ['contextMenuFontFamily', 'sans-serif'],\r\n        ['contextMenuFontSize', '16px'],\r\n        ['contextMenuHoverBackground', 'rgba(182, 205, 250, 1)'],\r\n        ['contextMenuHoverColor', 'rgba(43, 48, 153, 1)'],\r\n        ['contextMenuItemBorderRadius', '3px'],\r\n        ['contextMenuItemMargin', '2px'],\r\n        ['contextMenuLabelDisplay', 'inline-block'],\r\n        ['contextMenuLabelMargin', '0 3px 0 0'],\r\n        ['contextMenuLabelMaxWidth', '700px'],\r\n        ['contextMenuLabelMinWidth', '75px'],\r\n        ['contextMenuMarginLeft', 3],\r\n        ['contextMenuMarginTop', -3],\r\n        ['contextMenuOpacity', '0.98'],\r\n        ['contextMenuPadding', '2px'],\r\n        ['contextMenuWindowMargin', 30],\r\n        ['contextMenuZIndex', 10000],\r\n        ['cornerCellBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n        ['cornerCellBorderColor', 'rgba(202, 202, 202, 1)'],\r\n        ['debugBackgroundColor', 'rgba(0, 0, 0, .0)'],\r\n        ['debugColor', 'rgba(255, 15, 24, 1)'],\r\n        ['debugEntitiesColor', 'rgba(76, 231, 239, 1.00)'],\r\n        ['debugFont', '11px sans-serif'],\r\n        ['debugPerfChartBackground', 'rgba(29, 25, 26, 1.00)'],\r\n        ['debugPerfChartTextColor', 'rgba(255, 255, 255, 0.8)'],\r\n        ['debugPerformanceColor', 'rgba(252, 255, 37, 1.00)'],\r\n        ['debugScrollHeightColor', 'rgba(248, 33, 103, 1.00)'],\r\n        ['debugScrollWidthColor', 'rgba(66, 255, 27, 1.00)'],\r\n        ['debugTouchPPSXColor', 'rgba(246, 102, 24, 1.00)'],\r\n        ['debugTouchPPSYColor', 'rgba(186, 0, 255, 1.00)'],\r\n        ['display', 'inline-block'],\r\n        ['editCellBackgroundColor', 'white'],\r\n        ['editCellBorder', 'solid 1px rgba(110, 168, 255, 1)'],\r\n        ['editCellBoxShadow', '0 2px 5px rgba(0,0,0,0.4)'],\r\n        ['editCellColor', 'black'],\r\n        ['editCellFontFamily', 'sans-serif'],\r\n        ['editCellFontSize', '16px'],\r\n        ['editCellPaddingLeft', 4],\r\n        ['editCellZIndex', 10000],\r\n        ['frozenMarkerHoverColor', 'rgba(236, 243, 255, 1)'],\r\n        ['frozenMarkerHoverBorderColor', 'rgba(110, 168, 255, 1)'],\r\n        ['frozenMarkerActiveColor', 'rgba(236, 243, 255, 1)'],\r\n        ['frozenMarkerActiveBorderColor', 'rgba(110, 168, 255, 1)'],\r\n        ['frozenMarkerColor', 'rgba(222, 222, 222, 1)'],\r\n        ['frozenMarkerBorderColor', 'rgba(168, 168, 168, 1)'],\r\n        ['frozenMarkerBorderWidth', 1],\r\n        ['frozenMarkerWidth', 2],\r\n        ['gridBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n        ['gridBorderCollapse', 'collapse'],\r\n        ['gridBorderColor', 'rgba(202, 202, 202, 1)'],\r\n        ['gridBorderWidth', 1],\r\n        ['height', 'auto'],\r\n        ['maxHeight', 'inherit'],\r\n        ['maxWidth', 'inherit'],\r\n        ['minColumnWidth', 45],\r\n        ['minHeight', 'inherit'],\r\n        ['minRowHeight', 24],\r\n        ['minWidth', 'inherit'],\r\n        ['mobileContextMenuMargin', 10],\r\n        ['mobileEditInputHeight', 30],\r\n        ['mobileEditFontFamily', 'sans-serif'],\r\n        ['mobileEditFontSize', '16px'],\r\n        ['moveOverlayBorderWidth', 1],\r\n        ['moveOverlayBorderColor', 'rgba(66, 133, 244, 1)'],\r\n        ['moveOverlayBorderSegments', '12, 7'],\r\n        ['name', 'default'],\r\n        ['overflowY', 'auto'],\r\n        ['overflowX', 'auto'],\r\n        ['reorderMarkerBackgroundColor', 'rgba(0, 0, 0, 0.1)'],\r\n        ['reorderMarkerBorderColor', 'rgba(0, 0, 0, 0.2)'],\r\n        ['reorderMarkerBorderWidth', 1.25],\r\n        ['reorderMarkerIndexBorderColor', 'rgba(66, 133, 244, 1)'],\r\n        ['reorderMarkerIndexBorderWidth', 2.75],\r\n        ['rowHeaderCellBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n        ['rowHeaderCellBorderColor', 'rgba(200, 200, 200, 1)'],\r\n        ['rowHeaderCellBorderWidth', 1],\r\n        ['rowHeaderCellColor', 'rgba(50, 50, 50, 1)'],\r\n        ['rowHeaderCellFont', '16px sans-serif'],\r\n        ['rowHeaderCellHeight', 25],\r\n        ['rowHeaderCellHorizontalAlignment', 'left'],\r\n        ['rowHeaderCellHoverBackgroundColor', 'rgba(235, 235, 235, 1)'],\r\n        ['rowHeaderCellHoverColor', 'rgba(0, 0, 0, 1)'],\r\n        ['rowHeaderCellPaddingBottom', 5],\r\n        ['rowHeaderCellPaddingLeft', 5],\r\n        ['rowHeaderCellPaddingRight', 5],\r\n        ['rowHeaderCellPaddingTop', 5],\r\n        ['rowHeaderCellSelectedBackgroundColor', 'rgba(217, 217, 217, 1)'],\r\n        ['rowHeaderCellSelectedColor', 'rgba(50, 50, 50, 1)'],\r\n        ['rowHeaderCellVerticalAlignment', 'center'],\r\n        ['rowHeaderCellWidth', 57],\r\n        ['scrollBarActiveColor', 'rgba(125, 125, 125, 1)'],\r\n        ['scrollBarBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n        ['scrollBarBorderColor', 'rgba(202, 202, 202, 1)'],\r\n        ['scrollBarBorderWidth', 0.5],\r\n        ['scrollBarBoxBorderRadius', 4.125],\r\n        ['scrollBarBoxColor', 'rgba(192, 192, 192, 1)'],\r\n        ['scrollBarBoxMargin', 2],\r\n        ['scrollBarBoxMinSize', 15],\r\n        ['scrollBarBoxWidth', 8],\r\n        ['scrollBarCornerBackgroundColor', 'rgba(240, 240, 240, 1)'],\r\n        ['scrollBarCornerBorderColor', 'rgba(202, 202, 202, 1)'],\r\n        ['scrollBarWidth', 11],\r\n        ['selectionHandleBorderColor', 'rgba(255, 255, 255, 1)'],\r\n        ['selectionHandleBorderWidth', 1.5],\r\n        ['selectionHandleColor', 'rgba(66, 133, 244, 1)'],\r\n        ['selectionHandleSize', 8],\r\n        ['selectionHandleType', 'square'],\r\n        ['selectionOverlayBorderColor', 'rgba(66, 133, 244, 1)'],\r\n        ['selectionOverlayBorderWidth', 1],\r\n        ['treeArrowBorderColor', 'rgba(195, 199, 202, 1)'],\r\n        ['treeArrowBorderWidth', 1],\r\n        ['treeArrowClickRadius', 5],\r\n        ['treeArrowColor', 'rgba(155, 155, 155, 1)'],\r\n        ['treeArrowHeight', 8],\r\n        ['treeArrowMarginLeft', 0],\r\n        ['treeArrowMarginRight', 5],\r\n        ['treeArrowMarginTop', 6],\r\n        ['treeArrowWidth', 13],\r\n        ['treeGridHeight', 250],\r\n        ['width', 'auto']\r\n      ]\r\n    };\r\n  };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/defaults.js\n// module id = 0\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true, evil: true*/\r\n/*globals Reflect: false, HTMLElement: true, define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine([\r\n    './component',\r\n    './defaults',\r\n    './draw',\r\n    './events',\r\n    './touch',\r\n    './intf',\r\n    './contextMenu',\r\n    './dom',\r\n    './publicMethods'\r\n], function context(component) {\r\n    'use strict';\r\n    component = component();\r\n    var modules = Array.prototype.slice.call(arguments);\r\n    function Grid(args) {\r\n        args = args || {};\r\n        var self = {};\r\n        self.isComponent = args.component === undefined;\r\n        self.isChildGrid = args.parentNode && /canvas-datagrid-(cell|tree)/.test(args.parentNode.nodeType);\r\n        if (self.isChildGrid) {\r\n            self.intf = {};\r\n        } else {\r\n            self.intf = self.isComponent ? eval('Reflect.construct(HTMLElement, [], new.target)')\r\n                : document.createElement('canvas');\r\n        }\r\n        self.args = args;\r\n        self.intf.args = args;\r\n        self.applyComponentStyle = component.applyComponentStyle;\r\n        self.hyphenateProperty = component.hyphenateProperty;\r\n        self.dehyphenateProperty = component.dehyphenateProperty;\r\n        self.createGrid = function grid(args) {\r\n            args.component = false;\r\n            return new Grid(args);\r\n        };\r\n        modules.forEach(function (module) {\r\n            module(self);\r\n        });\r\n        if (self.isChildGrid) {\r\n            self.shadowRoot = args.parentNode.shadowRoot;\r\n            self.parentNode = args.parentNode;\r\n        } else {\r\n            self.shadowRoot = self.intf.attachShadow({mode: 'open'});\r\n            self.parentNode = self.shadowRoot;\r\n        }\r\n        self.init();\r\n        return self.intf;\r\n    }\r\n    if (window.HTMLElement) {\r\n        Grid.prototype = Object.create(window.HTMLElement.prototype);\r\n    }\r\n    // export web component\r\n    if (window.customElements) {\r\n        Grid.observedAttributes = component.getObservableAttributes();\r\n        Grid.prototype.disconnectedCallback = component.disconnectedCallback;\r\n        Grid.prototype.attributeChangedCallback = component.attributeChangedCallback;\r\n        Grid.prototype.connectedCallback = component.connectedCallback;\r\n        Grid.prototype.adoptedCallback = component.adoptedCallback;\r\n        window.customElements.define('canvas-datagrid', Grid);\r\n    }\r\n    // export global\r\n    if (window && !window.canvasDatagrid && !window.require) {\r\n        window.canvasDatagrid = function (args) { return new Grid(args); };\r\n    }\r\n    // export amd loader\r\n    module.exports = function grid(args) {\r\n        args = args || {};\r\n        var i, tKeys = ['style', 'formatters', 'sorters', 'filters',\r\n                    'treeGridAttributes', 'cellGridAttributes', 'data', 'schema'];\r\n        if (window.customElements) {\r\n            i = document.createElement('canvas-datagrid');\r\n            Object.keys(args).forEach(function (argKey) {\r\n                // set data and parentNode after everything else\r\n                if (argKey === 'data') { return; }\r\n                if (argKey === 'parentNode') { return; }\r\n                // top level keys in args\r\n                if (tKeys.indexOf(argKey) !== -1) {\r\n                    tKeys.forEach(function (tKey) {\r\n                        if (args[tKey] === undefined || tKey !== argKey) { return; }\r\n                        if (['formatters', 'sorters', 'filters'].indexOf(argKey) !== -1) {\r\n                            if (typeof args[tKey] === 'object' && args[tKey] !== null) {\r\n                                Object.keys(args[tKey]).forEach(function (sKey) {\r\n                                    i[tKey][sKey] = args[tKey][sKey];\r\n                                });\r\n                            }\r\n                        } else {\r\n                            i[tKey] = args[tKey];\r\n                        }\r\n                    });\r\n                    return;\r\n                }\r\n                // all others are attribute level keys\r\n                i.attributes[argKey] = args[argKey];\r\n            });\r\n            if (args.data) {\r\n                i.data = args.data;\r\n            }\r\n            // add to the dom very last to avoid redraws\r\n            if (args.parentNode) {\r\n                args.parentNode.appendChild(i);\r\n            }\r\n            return i;\r\n        }\r\n        args.component = false;\r\n        i = new Grid(args);\r\n        if (args.parentNode && args.parentNode.appendChild) {\r\n            args.parentNode.appendChild(i);\r\n        }\r\n        return i;\r\n    };\r\n    return module.exports;\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/main.js\n// module id = 1\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine(['./defaults'], function (defaults) {\r\n    'use strict';\r\n    return function () {\r\n        var typeMap, component = {};\r\n        component.dehyphenateProperty = function hyphenateProperty(prop) {\r\n            prop = prop.replace('--cdg-', '');\r\n            var p = '', nextLetterCap;\r\n            Array.prototype.forEach.call(prop, function (char) {\r\n                if (nextLetterCap) {\r\n                    nextLetterCap = false;\r\n                    p += char.toUpperCase();\r\n                    return;\r\n                }\r\n                if (char === '-') {\r\n                    nextLetterCap = true;\r\n                    return;\r\n                }\r\n                p += char;\r\n            });\r\n            return p;\r\n        };\r\n        component.hyphenateProperty = function hyphenateProperty(prop, cust) {\r\n            var p = '';\r\n            Array.prototype.forEach.call(prop, function (char) {\r\n                if (char === char.toUpperCase()) {\r\n                    p += '-' + char.toLowerCase();\r\n                    return;\r\n                }\r\n                p += char;\r\n            });\r\n            return (cust ? '--cdg-' : '') + p;\r\n        };\r\n        function getDefaultItem(base, item) {\r\n            var i = {},\r\n                r;\r\n            defaults(i);\r\n            r = i.defaults[base].filter(function (i) {\r\n                return i[0].toLowerCase() === item.toLowerCase()\r\n                    || component.hyphenateProperty(i[0]) === item.toLowerCase()\r\n                    || component.hyphenateProperty(i[0], true) === item.toLowerCase();\r\n            })[0];\r\n            return r;\r\n        }\r\n        component.applyComponentStyle = function (supressChangeAndDrawEvents, intf) {\r\n            if (!intf.isComponent) { return; }\r\n            var cStyle = window.getComputedStyle(intf.tagName === 'CANVAS-DATAGRID' ? intf : intf.canvas, null),\r\n                defs = {};\r\n            intf.computedStyle = cStyle;\r\n            defaults(defs);\r\n            defs = defs.defaults.styles;\r\n            defs.forEach(function (def) {\r\n                var val;\r\n                val = cStyle.getPropertyValue(component.hyphenateProperty(def[0], true));\r\n                if (val === \"\") {\r\n                    val = cStyle.getPropertyValue(component.hyphenateProperty(def[0], false));\r\n                }\r\n                if (val !== \"\" && typeof val === 'string') {\r\n                    intf.setStyleProperty(def[0], typeMap[typeof def[1]](val\r\n                        .replace(/^\\s+/, '').replace(/\\s+$/, ''), def[1]), true);\r\n                }\r\n            });\r\n            if (!supressChangeAndDrawEvents && intf.dispatchEvent) {\r\n                requestAnimationFrame(function () { intf.resize(true); });\r\n                intf.dispatchEvent('stylechanged', intf.style);\r\n            }\r\n        };\r\n        typeMap = {\r\n            data: function (strData) {\r\n                try {\r\n                    return JSON.parse(strData);\r\n                } catch (e) {\r\n                    throw new Error('Cannot read JSON data in canvas-datagrid data.');\r\n                }\r\n            },\r\n            schema: function (strSchema) {\r\n                try {\r\n                    return JSON.parse(strSchema);\r\n                } catch (e) {\r\n                    throw new Error('Cannot read JSON data in canvas-datagrid schema attribute.');\r\n                }\r\n            },\r\n            number: function (strNum, def) {\r\n                var n = parseInt(strNum, 10);\r\n                return isNaN(n) ? def : n;\r\n            },\r\n            boolean: function (strBool) {\r\n                return (/true/i).test(strBool);\r\n            },\r\n            string: function (str) {\r\n                return str;\r\n            }\r\n        };\r\n        component.getObservableAttributes = function () {\r\n            var i = {}, attrs = ['data', 'schema', 'style', 'className', 'name'];\r\n            defaults(i);\r\n            i.defaults.attributes.forEach(function (attr) {\r\n                attrs.push(attr[0].toLowerCase());\r\n            });\r\n            return attrs;\r\n        };\r\n        component.disconnectedCallback = function () {\r\n            this.connected = false;\r\n        };\r\n        component.connectedCallback = function () {\r\n            var intf = this;\r\n            intf.parentDOMNode.innerHTML = \"\";\r\n            intf.parentDOMNode.appendChild(intf.canvas);\r\n            intf.connected = true;\r\n            component.observe(intf);\r\n            component.applyComponentStyle(true, intf);\r\n            intf.resize(true);\r\n        };\r\n        component.adoptedCallback = function () {\r\n            this.resize();\r\n        };\r\n        component.attributeChangedCallback = function (attrName, oldVal, newVal) {\r\n            var tfn, intf = this, def;\r\n            if (attrName === 'style') {\r\n                component.applyComponentStyle(false, intf);\r\n                return;\r\n            }\r\n            if (attrName === 'data') {\r\n                if (intf.dataType === 'application/x-canvas-datagrid') {\r\n                    intf.dataType = 'application/json+x-canvas-datagrid';\r\n                }\r\n                intf.args.data = newVal;\r\n                return;\r\n            }\r\n            if (attrName === 'schema') {\r\n                intf.args.schema = typeMap.schema(newVal);\r\n                return;\r\n            }\r\n            if (attrName === 'name') {\r\n                intf.name = newVal;\r\n                return;\r\n            }\r\n            if (attrName === 'class' || attrName === 'className') {\r\n                return;\r\n            }\r\n            def = getDefaultItem('attributes', attrName);\r\n            if (def) {\r\n                tfn = typeMap[typeof def[1]];\r\n                intf.attributes[def[0]] = tfn(newVal);\r\n                return;\r\n            }\r\n            if (/^on/.test(attrName)) {\r\n                intf.addEventListener('on' + attrName, function (e) {\r\n                    eval(newVal);\r\n                });\r\n            }\r\n            return;\r\n        };\r\n        component.observe = function (intf) {\r\n            var observer;\r\n            if (!window.MutationObserver) { return; }\r\n            intf.applyComponentStyle = function () { component.applyComponentStyle(false, intf); intf.resize(); };\r\n            /**\r\n             * Applies the computed css styles to the grid.  In some browsers, changing directives in attached style sheets does not automatically update the styles in this component.  It is necessary to call this method to update in these cases.\r\n             * @memberof canvasDatagrid\r\n             * @name applyComponentStyle\r\n             * @method\r\n             */\r\n            observer = new window.MutationObserver(function (mutations) {\r\n                var checkInnerHTML, checkStyle;\r\n                Array.prototype.forEach.call(mutations, function (mutation) {\r\n                    if (mutation.attributeName === 'class'\r\n                            || mutation.attributeName === 'style') {\r\n                        checkStyle = true;\r\n                        return;\r\n                    }\r\n                    if (mutation.target.nodeName === 'STYLE') {\r\n                        checkStyle = true;\r\n                        return;\r\n                    }\r\n                    if (mutation.target.parentNode\r\n                            && mutation.target.parentNode.nodeName === 'STYLE') {\r\n                        checkStyle = true;\r\n                        return;\r\n                    }\r\n                    if (mutation.target === intf && (mutation.addedNodes.length > 0 || mutation.type === 'characterData')) {\r\n                        checkInnerHTML = true;\r\n                    }\r\n                });\r\n                if (checkStyle) {\r\n                    intf.applyComponentStyle(false, intf);\r\n                }\r\n                if (checkInnerHTML) {\r\n                    if (intf.dataType === 'application/x-canvas-datagrid') {\r\n                        intf.dataType = 'application/json+x-canvas-datagrid';\r\n                    }\r\n                    intf.data = intf.innerHTML;\r\n                }\r\n            });\r\n            observer.observe(intf, { characterData: true, childList: true, attributes: true, subtree: true });\r\n            Array.prototype.forEach.call(document.querySelectorAll('style'), function (el) {\r\n                observer.observe(el, { characterData: true, childList: true, attributes: true, subtree: true });\r\n            });\r\n        };\r\n        return component;\r\n    };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/component.js\n// module id = 2\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals XMLSerializer: false, define: true, Blob: false, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine([], function () {\r\n  'use strict';\r\n  return function (self) {\r\n    var perfCounters = [],\r\n      cachedImagesDrawn = false,\r\n      drawCount = 0,\r\n      perfWindowSize = 300,\r\n      entityCount = [],\r\n      hiddenFrozenColumnCount = 0,\r\n      scrollDebugCounters = [],\r\n      touchPPSCounters = [];\r\n    self.htmlImageCache = {};\r\n    // more heavyweight version than fillArray defined in intf.js\r\n    function fillArray(low, high, step, def) {\r\n      step = step || 1;\r\n      var i = [], x;\r\n      for (x = low; x <= high; x += step) {\r\n        i[x] = def === undefined ? x : (typeof def === 'function' ? def(x) : def);\r\n      }\r\n      return i;\r\n    }\r\n    function drawPerfLine(w, h, x, y, perfArr, arrIndex, max, color, useAbs) {\r\n      var i = w / perfArr.length,\r\n        r = h / max;\r\n      x += self.canvasOffsetLeft;\r\n      y += self.canvasOffsetTop;\r\n      self.ctx.beginPath();\r\n      self.ctx.moveTo(x, y + h);\r\n      perfArr.forEach(function (n) {\r\n        var val = (arrIndex === undefined ? n : n[arrIndex]),\r\n          cx,\r\n          cy;\r\n        if (useAbs) {\r\n          val = Math.abs(val);\r\n        }\r\n        cx = x + i;\r\n        cy = y + h - (val * r);\r\n        self.ctx.lineTo(cx, cy);\r\n        x += i;\r\n      });\r\n      self.ctx.moveTo(x + w, y + h);\r\n      self.ctx.strokeStyle = color;\r\n      self.ctx.stroke();\r\n    }\r\n    function drawOnAllImagesLoaded() {\r\n      var loaded = true;\r\n      Object.keys(self.htmlImageCache).forEach(function (html) {\r\n        if (!self.htmlImageCache[html].img.complete) {\r\n          loaded = false;\r\n        }\r\n      });\r\n      if (loaded && !cachedImagesDrawn) {\r\n        cachedImagesDrawn = true;\r\n        self.draw();\r\n      }\r\n    }\r\n    function drawHtml(cell) {\r\n      var img,\r\n        v = cell.innerHTML || cell.formattedValue,\r\n        cacheKey = v.toString() + cell.rowIndex.toString() + cell.columnIndex.toString(),\r\n        x = cell.x + self.canvasOffsetLeft,\r\n        y = cell.y + self.canvasOffsetTop;\r\n      if (self.htmlImageCache[cacheKey]) {\r\n        img = self.htmlImageCache[cacheKey].img;\r\n        if (self.htmlImageCache[cacheKey].height !== cell.height || self.htmlImageCache[cacheKey].width !== cell.width) {\r\n          // height and width of the cell has changed, invalidate cache\r\n          self.htmlImageCache[cacheKey] = undefined;\r\n        } else {\r\n          if (!img.complete) {\r\n            return;\r\n          }\r\n          return self.ctx.drawImage(img, x, y);\r\n        }\r\n      } else {\r\n        cachedImagesDrawn = false;\r\n      }\r\n      img = new Image(cell.width, cell.height);\r\n      self.htmlImageCache[cacheKey] = { img: img, width: cell.width, height: cell.height };\r\n      img.onload = function () {\r\n        self.ctx.drawImage(img, x, y);\r\n        drawOnAllImagesLoaded();\r\n      };\r\n      img.src = 'data:image/svg+xml;base64,' + btoa(\r\n        '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"' + cell.width + '\" height=\"' + cell.height + '\">\\n' +\r\n        '<foreignObject class=\"node\" x=\"0\" y=\"0\" width=\"100%\" height=\"100%\">\\n' +\r\n        '<body xmlns=\"http://www.w3.org/1999/xhtml\" style=\"margin:0;padding:0;\">\\n' +\r\n        v + '\\n' +\r\n        '</body>' +\r\n        '</foreignObject>\\n' +\r\n        '</svg>\\n'\r\n      );\r\n    }\r\n    function drawOrderByArrow(x, y) {\r\n      var mt = self.style.columnHeaderOrderByArrowMarginTop * self.scale,\r\n        ml = self.style.columnHeaderOrderByArrowMarginLeft * self.scale,\r\n        mr = self.style.columnHeaderOrderByArrowMarginRight * self.scale,\r\n        aw = self.style.columnHeaderOrderByArrowWidth * self.scale,\r\n        ah = self.style.columnHeaderOrderByArrowHeight * self.scale;\r\n      x += self.canvasOffsetLeft;\r\n      y += self.canvasOffsetTop;\r\n      self.ctx.fillStyle = self.style.columnHeaderOrderByArrowColor;\r\n      self.ctx.strokeStyle = self.style.columnHeaderOrderByArrowBorderColor;\r\n      self.ctx.beginPath();\r\n      x = x + ml;\r\n      y = y + mt;\r\n      if (self.orderDirection === 'asc') {\r\n        self.ctx.moveTo(x, y);\r\n        self.ctx.lineTo(x + aw, y);\r\n        self.ctx.lineTo(x + (aw * 0.5), y + ah);\r\n        self.ctx.moveTo(x, y);\r\n      } else {\r\n        self.ctx.lineTo(x, y + ah);\r\n        self.ctx.lineTo(x + aw, y + ah);\r\n        self.ctx.lineTo(x + (aw * 0.5), y);\r\n        self.ctx.lineTo(x, y + ah);\r\n      }\r\n      self.ctx.stroke();\r\n      self.ctx.fill();\r\n      return ml + aw + mr;\r\n    }\r\n    function drawTreeArrow(cell, x, y) {\r\n      var mt = self.style.treeArrowMarginTop * self.scale,\r\n        mr = self.style.treeArrowMarginRight * self.scale,\r\n        ml = self.style.treeArrowMarginLeft * self.scale,\r\n        aw = self.style.treeArrowWidth * self.scale,\r\n        ah = self.style.treeArrowHeight * self.scale;\r\n      x += self.canvasOffsetLeft;\r\n      y += self.canvasOffsetTop;\r\n      self.ctx.fillStyle = self.style.treeArrowColor;\r\n      self.ctx.strokeStyle = self.style.treeArrowBorderColor;\r\n      self.ctx.beginPath();\r\n      x = x + ml;\r\n      y = y + mt;\r\n      if (self.openChildren[cell.rowIndex]) {\r\n        self.ctx.moveTo(x, y);\r\n        self.ctx.lineTo(x + aw, y);\r\n        self.ctx.lineTo(x + (aw * 0.5), y + ah);\r\n        self.ctx.moveTo(x, y);\r\n      } else {\r\n        self.ctx.lineTo(x, y);\r\n        self.ctx.lineTo(x + ah, y + (aw * 0.5));\r\n        self.ctx.lineTo(x, y + aw);\r\n        self.ctx.lineTo(x, y);\r\n      }\r\n      self.ctx.stroke();\r\n      self.ctx.fill();\r\n      return ml + aw + mr;\r\n    }\r\n    function radiusRect(x, y, w, h, radius) {\r\n      x += self.canvasOffsetLeft;\r\n      y += self.canvasOffsetTop;\r\n      var r = x + w, b = y + h;\r\n      self.ctx.beginPath();\r\n      self.ctx.moveTo(x + radius, y);\r\n      self.ctx.lineTo(r - radius, y);\r\n      self.ctx.quadraticCurveTo(r, y, r, y + radius);\r\n      self.ctx.lineTo(r, y + h - radius);\r\n      self.ctx.quadraticCurveTo(r, b, r - radius, b);\r\n      self.ctx.lineTo(x + radius, b);\r\n      self.ctx.quadraticCurveTo(x, b, x, b - radius);\r\n      self.ctx.lineTo(x, y + radius);\r\n      self.ctx.quadraticCurveTo(x, y, x + radius, y);\r\n    }\r\n    function fillRect(x, y, w, h) {\r\n      x += self.canvasOffsetLeft;\r\n      y += self.canvasOffsetTop;\r\n      self.ctx.fillRect(x, y, w, h);\r\n    }\r\n    function strokeRect(x, y, w, h) {\r\n      x += self.canvasOffsetLeft;\r\n      y += self.canvasOffsetTop;\r\n      self.ctx.strokeRect(x, y, w, h);\r\n    }\r\n    function fillText(text, x, y) {\r\n      x += self.canvasOffsetLeft;\r\n      y += self.canvasOffsetTop;\r\n      self.ctx.fillText(text, x, y);\r\n    }\r\n    function fillCircle(x, y, r) {\r\n      x += self.canvasOffsetLeft;\r\n      y += self.canvasOffsetTop;\r\n      self.ctx.beginPath();\r\n      self.ctx.arc(x, y, r, 0, 2 * Math.PI);\r\n      self.ctx.fill();\r\n    }\r\n    function strokeCircle(x, y, r) {\r\n      x += self.canvasOffsetLeft;\r\n      y += self.canvasOffsetTop;\r\n      self.ctx.beginPath();\r\n      self.ctx.arc(x, y, r, 0, 2 * Math.PI);\r\n      self.ctx.stroke();\r\n    }\r\n    function clipFrozenArea(mode) {\r\n      // 0 both, 1 rows, 2 cols\r\n      // self.lastFrozenColumnPixel;\r\n      // self.lastFrozenRowPixel;\r\n      self.ctx.beginPath();\r\n      if (mode === 0) {\r\n        self.ctx.moveTo(self.lastFrozenColumnPixel, self.lastFrozenRowPixel);\r\n        self.ctx.lineTo(self.lastFrozenColumnPixel, self.height);\r\n        self.ctx.lineTo(self.width, self.height);\r\n        self.ctx.lineTo(self.width, self.lastFrozenRowPixel);\r\n      }\r\n      if (mode === 1) {\r\n        self.ctx.moveTo(0, self.lastFrozenRowPixel);\r\n        self.ctx.lineTo(0, self.height);\r\n        self.ctx.lineTo(self.width, self.height);\r\n        self.ctx.lineTo(self.width, self.lastFrozenRowPixel);\r\n      }\r\n      if (mode === 2) {\r\n        self.ctx.moveTo(self.lastFrozenColumnPixel, 0);\r\n        self.ctx.lineTo(self.width, 0);\r\n        self.ctx.lineTo(self.width, self.height);\r\n        self.ctx.lineTo(self.lastFrozenColumnPixel, self.height);\r\n      }\r\n      self.ctx.clip();\r\n    }\r\n    function fillHandle(x, y, r) {\r\n      if (self.style.selectionHandleType === 'circle') {\r\n        return fillCircle(x, y, r * 0.5);\r\n      }\r\n      fillRect(x - r * 0.5, y - r * 0.5, r, r);\r\n    }\r\n    function strokeHandle(x, y, r) {\r\n      if (self.style.selectionHandleType === 'circle') {\r\n        return strokeCircle(x, y, r * 0.5);\r\n      }\r\n      strokeRect(x - r * 0.5, y - r * 0.5, r, r);\r\n    }\r\n    function addselectionHandle(c, pos) {\r\n      var hw = self.style.selectionHandleSize,\r\n        p = {\r\n          tr: function () {\r\n            fillHandle(c.x + c.width, c.y, hw);\r\n            strokeHandle(c.x + c.width, c.y, hw);\r\n          },\r\n          br: function () {\r\n            fillHandle(c.x + c.width, c.y + c.height, hw);\r\n            strokeHandle(c.x + c.width, c.y + c.height, hw);\r\n          },\r\n          tl: function () {\r\n            fillHandle(c.x, c.y, hw);\r\n            strokeHandle(c.x, c.y, hw);\r\n          },\r\n          bl: function () {\r\n            fillHandle(c.x, c.y + c.height, hw);\r\n            strokeHandle(c.x, c.y + c.height, hw);\r\n          }\r\n        };\r\n      p[pos]();\r\n    }\r\n    function addBorderLine(c, pos) {\r\n      self.ctx.beginPath();\r\n      var p = {\r\n        t: function () {\r\n          self.ctx.moveTo(c.x + self.canvasOffsetLeft, c.y + self.canvasOffsetTop);\r\n          self.ctx.lineTo(c.x + self.canvasOffsetLeft + c.width, c.y + self.canvasOffsetTop);\r\n        },\r\n        r: function () {\r\n          self.ctx.moveTo(c.x + self.canvasOffsetLeft + c.width, c.y + self.canvasOffsetTop);\r\n          self.ctx.lineTo(c.x + self.canvasOffsetLeft + c.width, c.y + self.canvasOffsetTop + c.height);\r\n        },\r\n        b: function () {\r\n          self.ctx.moveTo(c.x + self.canvasOffsetLeft, c.y + self.canvasOffsetTop + c.height);\r\n          self.ctx.lineTo(c.x + self.canvasOffsetLeft + c.width, c.y + self.canvasOffsetTop + c.height);\r\n        },\r\n        l: function () {\r\n          self.ctx.moveTo(c.x + self.canvasOffsetLeft, c.y + self.canvasOffsetTop);\r\n          self.ctx.lineTo(c.x + self.canvasOffsetLeft, c.y + self.canvasOffsetTop + c.height);\r\n        }\r\n      };\r\n      p[pos]();\r\n      self.ctx.stroke();\r\n    }\r\n    function addEllipsis(text, width) {\r\n      var c, w = 0;\r\n      if (self.ellipsisCache[text] && self.ellipsisCache[text][width]) {\r\n        return self.ellipsisCache[text][width];\r\n      }\r\n      //TODO Add ellipsis back when there is a fast way to do it\r\n      w = self.ctx.measureText(text).width;\r\n      self.ellipsisCache[text] = self.ellipsisCache[text] || {};\r\n      c = { value: text, width: w };\r\n      self.ellipsisCache[text][width] = c;\r\n      return c;\r\n    }\r\n    function wrapText(cell, splitChar) {\r\n      if (!cell.formattedValue) {\r\n        return { lines: [{ width: 0, value: '' }], width: 0, height: cell.calculatedLineHeight };\r\n      }\r\n      var max = 0,\r\n        n = '\\n',\r\n        x,\r\n        word,\r\n        words = cell.formattedValue.split(splitChar),\r\n        textHeight = cell.calculatedLineHeight,\r\n        lines = [],\r\n        out = [],\r\n        wrap = self.style.cellWhiteSpace !== 'nowrap',\r\n        elWidth,\r\n        et = self.attributes.ellipsisText,\r\n        elClipLength,\r\n        plWidth,\r\n        clippedVal,\r\n        ogWordWidth,\r\n        previousLine,\r\n        line = {\r\n          width: 0,\r\n          value: ''\r\n        },\r\n        cHeight = wrap ? cell.paddedHeight : cell.calculatedLineHeight;\r\n      lines.push(line);\r\n      elWidth = self.ctx.measureText(' ' + et).width;\r\n      for (x = 0; x < words.length; x += 1) {\r\n        word = words[x];\r\n        var measure = self.ctx.measureText(word + splitChar);\r\n        if (line.width + measure.width + elWidth < cell.paddedWidth) {\r\n          line.value += word + splitChar;\r\n          line.width += measure.width;\r\n          continue;\r\n        }\r\n        // if there is a hyphenated word that is too long\r\n        // split it and add the split set to the array\r\n        // then back up and re-read new split set\r\n        // this behavior seems right, it might not be\r\n        if (/\\w-\\w/.test(word) && cell.paddedWidth < measure.width) {\r\n          words.splice(x, 1, word.split('-')[0] + '-', word.split('-')[1]);\r\n          x -= 1;\r\n          continue;\r\n        }\r\n        line = {\r\n          width: measure.width,\r\n          value: word + splitChar\r\n        };\r\n        if (x === 0) {\r\n          lines = [];\r\n          lines.push(line);\r\n        }\r\n        textHeight += cell.calculatedLineHeight;\r\n        if (textHeight > cHeight) {\r\n          if (lines.length === 0) { break; }\r\n          elClipLength = 1;\r\n          previousLine = lines[lines.length - 1];\r\n          if (previousLine.width < cell.paddedWidth && words.length === 1) { break; }\r\n          clippedVal = previousLine.value + word;\r\n          plWidth = self.ctx.measureText(clippedVal + et).width;\r\n          var originText = clippedVal;\r\n          if (plWidth > cell.paddedWidth) {\r\n            var stepLength = parseInt(clippedVal.length / 2);\r\n            var direction = -1;\r\n            while (stepLength > 0) {\r\n              clippedVal = originText.substr(0, stepLength * direction + clippedVal.length);\r\n              plWidth = self.ctx.measureText(clippedVal + et).width;\r\n              direction = plWidth > cell.paddedWidth ? -1 : 1;\r\n              stepLength = parseInt(stepLength / 2);\r\n            }\r\n          }\r\n          clippedVal = clippedVal + (originText.length != clippedVal.length ? et : '');\r\n          previousLine.value = clippedVal;\r\n          previousLine.width = plWidth;\r\n          break;\r\n        }\r\n        if (x > 0) {\r\n          lines.push(line);\r\n        }\r\n      }\r\n      return {\r\n        lines: lines,\r\n        width: max,\r\n        height: cell.calculatedLineHeight * lines.length\r\n      }\r\n    }\r\n    function drawText(cell) {\r\n      var ll = cell.text.lines.length,\r\n        h = (cell.fontHeight * cell.lineHeight),\r\n        x,\r\n        line,\r\n        wrap = self.style.cellWhiteSpace !== 'nowrap',\r\n        textHeight = 0;\r\n      for (x = 0; x < cell.text.lines.length; x += 1) {\r\n        line = cell.text.lines[x];\r\n        var vPos = Math.max((cell.height - (wrap ? cell.text.height : cell.calculatedLineHeight)) * 0.5, 0) + h,\r\n          hPos = cell.paddingLeft + cell.treeArrowWidth + cell.orderByArrowWidth;\r\n        if (cell.horizontalAlignment === 'right') {\r\n          hPos = cell.paddingLeft + cell.paddedWidth - line.width;\r\n        } else if (cell.horizontalAlignment === 'center') {\r\n          hPos = cell.paddingLeft + ((cell.paddedWidth + cell.paddingRight) / 2) - (line.width / 2);\r\n        }\r\n        if (cell.verticalAlignment === 'top') {\r\n          vPos = cell.calculatedLineHeight;\r\n        } else if (cell.verticalAlignment === 'bottom') {\r\n          vPos = cell.height - cell.paddingBottom - cell.text.height;\r\n        }\r\n        line.height = h + cell.lineSpacing;\r\n        line.offsetLeft = hPos;\r\n        line.offsetTop = vPos;\r\n        line.x = cell.x + hPos;\r\n        line.y = cell.y + textHeight + vPos;\r\n        textHeight += line.height;\r\n        fillText(line.value, line.x, line.y);\r\n      }\r\n      if (self.attributes.debug && cell.active) {\r\n        requestAnimationFrame(function () {\r\n          self.ctx.font = self.style.debugFont;\r\n          self.ctx.fillStyle = self.style.debugColor;\r\n          fillText(JSON.stringify({\r\n            x: cell.x,\r\n            y: cell.y,\r\n            h: cell.height,\r\n            w: cell.width,\r\n            pw: cell.paddedWidth,\r\n            idx: cell.columnIndex,\r\n            idx_ord: cell.sortColumnIndex\r\n          }, null, '\\t'),\r\n            cell.x + 14, cell.y + 14);\r\n          fillText(JSON.stringify(cell.text.lines.map(function (l) { return { w: l.width, v: l.value.length }; }), null, '\\t'),\r\n            cell.x + 14, cell.y + 30);\r\n        });\r\n      }\r\n    }\r\n    function getFrozenColumnsWidth() {\r\n      var w = 0,\r\n        s = self.getSchema(),\r\n        x = 0,\r\n        n = Math.min(self.frozenColumn, s.length),\r\n        column;\r\n      hiddenFrozenColumnCount = 0;\r\n      while (x < n) {\r\n        column = s[x];\r\n        if (column.hidden) {\r\n          hiddenFrozenColumnCount += 1;\r\n        } else {\r\n          w += self.getColummnWidth(x);\r\n        }\r\n        x += 1;\r\n      }\r\n      return w;\r\n    }\r\n    /**\r\n     * Redraws the grid. No matter what the change, this is the only method required to refresh everything.\r\n     * @memberof canvasDatagrid\r\n     * @name draw\r\n     * @method\r\n     */\r\n    // r = literal row index\r\n    // rd = row data array\r\n    // i = user order index\r\n    // o = literal data index\r\n    // y = y drawing cursor\r\n    // x = x drawing cursor\r\n    // s = visible schema array\r\n    // cx = current x drawing cursor sub calculation var\r\n    // cy = current y drawing cursor sub calculation var\r\n    // a = static cell (like corner cell)\r\n    // p = perf counter\r\n    // l = data length\r\n    // u = current cell\r\n    // h = current height\r\n    // w = current width\r\n    self.draw = function (internal) {\r\n      if (self.dispatchEvent('beforedraw', {})) { return; }\r\n      if (!self.isChildGrid && (!self.height || !self.width)) {\r\n        return;\r\n      }\r\n      if (self.isChildGrid && internal) {\r\n        requestAnimationFrame(self.parentGrid.draw);\r\n        return;\r\n      }\r\n      if (self.intf.visible === false) {\r\n        return;\r\n      }\r\n      // initial values\r\n      var checkScrollHeight, rowHeaderCell, p, cx, cy, treeGrid, rowOpen,\r\n        rowHeight, cornerCell, y, x, c, h, w, s, r, rd, aCell,\r\n        data = (self.data || []),\r\n        bc = self.style.gridBorderCollapse === 'collapse',\r\n        selectionBorders = [],\r\n        moveBorders = [],\r\n        selectionHandles = [],\r\n        rowHeaders = [],\r\n        l = data.length,\r\n        u = self.currentCell || {},\r\n        columnHeaderCellHeight = self.getColumnHeaderCellHeight(),\r\n        rowHeaderCellWidth = self.getRowHeaderCellWidth(),\r\n        cellHeight = self.style.cellHeight;\r\n      drawCount += 1;\r\n      p = performance.now();\r\n      self.visibleRowHeights = [];\r\n      // if data length has changed, there is no way to know\r\n      if (data.length > self.orders.rows.length) {\r\n        self.createRowOrders();\r\n      }\r\n      function drawScrollBars() {\r\n        var drawCorner,\r\n          en = self.scrollBox.entities,\r\n          m = (self.style.scrollBarBoxMargin * 2);\r\n        self.ctx.strokeStyle = self.style.scrollBarBorderColor;\r\n        self.ctx.lineWidth = self.style.scrollBarBorderWidth;\r\n        en.horizontalBox.x = rowHeaderCellWidth + self.style.scrollBarBoxMargin\r\n          + ((en.horizontalBar.width - self.scrollBox.scrollBoxWidth)\r\n            * (self.scrollBox.scrollLeft / self.scrollBox.scrollWidth));\r\n        en.verticalBox.y = columnHeaderCellHeight + self.style.scrollBarBoxMargin\r\n          + ((en.verticalBar.height - self.scrollBox.scrollBoxHeight)\r\n            * (self.scrollBox.scrollTop / self.scrollBox.scrollHeight));\r\n        if (self.scrollBox.horizontalBarVisible) {\r\n          self.ctx.fillStyle = self.style.scrollBarBackgroundColor;\r\n          fillRect(en.horizontalBar.x, en.horizontalBar.y, en.horizontalBar.width + m, en.horizontalBar.height);\r\n          strokeRect(en.horizontalBar.x, en.horizontalBar.y, en.horizontalBar.width + m, en.horizontalBar.height);\r\n          self.ctx.fillStyle = self.style.scrollBarBoxColor;\r\n          if (self.scrollBox.horizontalBoxVisible) {\r\n            if (/horizontal/.test(u.context)) {\r\n              self.ctx.fillStyle = self.style.scrollBarActiveColor;\r\n            }\r\n            radiusRect(en.horizontalBox.x, en.horizontalBox.y,\r\n              en.horizontalBox.width, en.horizontalBox.height, self.style.scrollBarBoxBorderRadius);\r\n            self.ctx.stroke();\r\n            self.ctx.fill();\r\n          }\r\n          drawCorner = true;\r\n          self.visibleCells.unshift(en.horizontalBar);\r\n          self.visibleCells.unshift(en.horizontalBox);\r\n        }\r\n        if (self.scrollBox.verticalBarVisible) {\r\n          self.ctx.fillStyle = self.style.scrollBarBackgroundColor;\r\n          fillRect(en.verticalBar.x, en.verticalBar.y, en.verticalBar.width, en.verticalBar.height + m);\r\n          strokeRect(en.verticalBar.x, en.verticalBar.y, en.verticalBar.width, en.verticalBar.height + m);\r\n          if (self.scrollBox.verticalBoxVisible) {\r\n            self.ctx.fillStyle = self.style.scrollBarBoxColor;\r\n            if (/vertical/.test(u.context)) {\r\n              self.ctx.fillStyle = self.style.scrollBarActiveColor;\r\n            }\r\n            radiusRect(en.verticalBox.x, en.verticalBox.y, en.verticalBox.width,\r\n              en.verticalBox.height, self.style.scrollBarBoxBorderRadius);\r\n            self.ctx.stroke();\r\n            self.ctx.fill();\r\n          }\r\n          drawCorner = true;\r\n          self.visibleCells.unshift(en.verticalBar);\r\n          self.visibleCells.unshift(en.verticalBox);\r\n        }\r\n        if (drawCorner) {\r\n          //corner\r\n          self.ctx.strokeStyle = self.style.scrollBarCornerBorderColor;\r\n          self.ctx.fillStyle = self.style.scrollBarCornerBackgroundColor;\r\n          radiusRect(en.corner.x, en.corner.y, en.corner.width, en.corner.height, 0);\r\n          self.ctx.stroke();\r\n          self.ctx.fill();\r\n          self.visibleCells.unshift(en.corner);\r\n        }\r\n      }\r\n      function createHandlesOverlayArray(cell) {\r\n        if (self.attributes.allowMovingSelection || self.mobile) {\r\n          if (cell.selectionBorderTop && cell.selectionBorderRight && self.mobile) {\r\n            selectionHandles.push([cell, 'tr']);\r\n            cell.selectionHandle = 'tr';\r\n          }\r\n          if (cell.selectionBorderTop && cell.selectionBorderLeft && self.mobile) {\r\n            selectionHandles.push([cell, 'tl']);\r\n            cell.selectionHandle = 'tl';\r\n          }\r\n          if (cell.selectionBorderBottom && cell.selectionBorderLeft && self.mobile) {\r\n            selectionHandles.push([cell, 'bl']);\r\n            cell.selectionHandle = 'bl';\r\n          }\r\n          if (cell.selectionBorderBottom && cell.selectionBorderRight\r\n            && (self.attributes.selectionHandleBehavior !== 'none' || self.mobile)) {\r\n            selectionHandles.push([cell, 'br']);\r\n            cell.selectionHandle = 'br';\r\n          }\r\n        }\r\n      }\r\n      function createBorderOverlayArray(cell, drawArray, propPrefix, offsetPoint) {\r\n        offsetPoint = offsetPoint || { x: 0, y: 0 };\r\n        cell.selectionBorder = '';\r\n        if (!cell.isRowHeader\r\n          && self.selections[cell.rowIndex + -offsetPoint.y]\r\n          && self.selections[cell.rowIndex + -offsetPoint.y].indexOf(cell.columnIndex + -offsetPoint.x) !== -1) {\r\n          if ((!self.selections[cell.rowIndex - 1 + -offsetPoint.y]\r\n            || self.selections[cell.rowIndex - 1 + -offsetPoint.y].indexOf(cell.columnIndex + -offsetPoint.x) === -1\r\n            || cell.rowIndex === 0)\r\n            && !cell.isHeader) {\r\n            drawArray.push([cell, 't']);\r\n            cell[propPrefix + 'BorderTop'] = true;\r\n            cell[propPrefix + 'Border'] += 't';\r\n          }\r\n          if (!self.selections[cell.rowIndex + 1 + -offsetPoint.y]\r\n            || self.selections[cell.rowIndex + 1 + -offsetPoint.y].indexOf(cell.columnIndex + -offsetPoint.x) === -1) {\r\n            drawArray.push([cell, 'b']);\r\n            cell[propPrefix + 'BorderBottom'] = true;\r\n            cell[propPrefix + 'Border'] += 'b';\r\n          }\r\n          if (!self.selections[cell.rowIndex + -offsetPoint.y] || cell.columnIndex === 0\r\n            || self.selections[cell.rowIndex + -offsetPoint.y].indexOf(cell.columnIndex - 1 + -offsetPoint.x) === -1) {\r\n            drawArray.push([cell, 'l']);\r\n            cell[propPrefix + 'BorderLeft'] = true;\r\n            cell[propPrefix + 'Border'] += 'l';\r\n          }\r\n          if (!self.selections[cell.rowIndex + -offsetPoint.y] || cell.columnIndex === s.length\r\n            || self.selections[cell.rowIndex + -offsetPoint.y].indexOf(cell.columnIndex + 1 + -offsetPoint.x) === -1) {\r\n            drawArray.push([cell, 'r']);\r\n            cell[propPrefix + 'BorderRight'] = true;\r\n            cell[propPrefix + 'Border'] += 'r';\r\n          }\r\n        }\r\n      }\r\n      function drawCell(d, rowOrderIndex, rowIndex) {\r\n        return function drawEach(header, headerIndex, columnOrderIndex) {\r\n          if (header.hidden) { return 0; }\r\n          var cellStyle = header.style || 'cell',\r\n            cellGridAttributes,\r\n            cell,\r\n            isHeader = /HeaderCell/.test(cellStyle),\r\n            isCorner = /cornerCell/.test(cellStyle),\r\n            isRowHeader = 'rowHeaderCell' === cellStyle,\r\n            isColumnHeader = 'columnHeaderCell' === cellStyle,\r\n            selected = self.selections[rowOrderIndex] && self.selections[rowOrderIndex].indexOf(columnOrderIndex) !== -1,\r\n            hovered = self.hovers.rowIndex === rowOrderIndex && self.hovers.columnIndex === columnOrderIndex,\r\n            active = self.activeCell.rowIndex === rowOrderIndex && self.activeCell.columnIndex === columnOrderIndex,\r\n            isColumnHeaderCellCap = cellStyle === 'columnHeaderCellCap',\r\n            rawValue = d ? d[header.name] : undefined,\r\n            isGrid = header.type === 'canvas-datagrid',\r\n            activeHeader = (self.orders.rows[self.activeCell.rowIndex] === rowOrderIndex\r\n              || self.orders.columns[self.activeCell.columnIndex] === headerIndex)\r\n              && (columnOrderIndex === -1 || rowOrderIndex === -1)\r\n              ? (isRowHeader ? 'activeRowHeaderCell' : 'activeColumnHeaderCell') : false,\r\n            val,\r\n            f = self.formatters[header.type || 'string'],\r\n            orderByArrowSize = 0,\r\n            treeArrowSize = 0,\r\n            cellWidth = self.sizes.columns[headerIndex] || header.width,\r\n            ev = {\r\n              value: rawValue,\r\n              row: d,\r\n              header: header\r\n            };\r\n          if (isColumnHeaderCellCap) {\r\n            cellWidth = w - x;\r\n          }\r\n          // if no data or schema are defined, a width is provided to the stub column\r\n          if (cellWidth === undefined) {\r\n            cellWidth = self.style.cellWidth;\r\n          }\r\n          cellWidth = cellWidth * self.scale;\r\n          if (x + cellWidth + self.style.cellBorderWidth < 0) {\r\n            x += cellWidth + self.style.cellBorderWidth;\r\n          }\r\n          if (active && cellStyle !== 'cornerCell') {\r\n            cellStyle = 'activeCell';\r\n          }\r\n          if (self.visibleRows.indexOf(rowIndex) === -1 && !isHeader) {\r\n            self.visibleRows.push(rowIndex);\r\n          }\r\n          val = self.dispatchEvent('formatcellvalue', ev);\r\n          cx = x;\r\n          cy = y;\r\n          if (cellStyle === 'cornerCell') {\r\n            cx = 0;\r\n            cy = 0;\r\n          } else if (isRowHeader) {\r\n            cx = 0;\r\n          } else if (isHeader) {\r\n            cy = 0;\r\n          }\r\n          cell = {\r\n            type: isGrid ? 'canvas-datagrid-cell' : header.type,\r\n            style: cellStyle,\r\n            nodeType: 'canvas-datagrid-cell',\r\n            x: cx,\r\n            y: cy,\r\n            fontHeight: (self.style[cellStyle + 'FontHeight'] || 0) * self.scale,\r\n            horizontalAlignment: self.style[cellStyle + 'HorizontalAlignment'],\r\n            verticalAlignment: self.style[cellStyle + 'VerticalAlignment'],\r\n            paddingLeft: (self.style[cellStyle + 'PaddingLeft'] || 0) * self.scale,\r\n            paddingTop: (self.style[cellStyle + 'PaddingTop'] || 0) * self.scale,\r\n            paddingRight: (self.style[cellStyle + 'PaddingRight'] || 0) * self.scale,\r\n            paddingBottom: (self.style[cellStyle + 'PaddingBottom'] || 0) * self.scale,\r\n            whiteSpace: self.style.cellWhiteSpace,\r\n            lineHeight: self.style.cellLineHeight,\r\n            lineSpacing: self.style.cellLineSpacing,\r\n            offsetTop: self.canvasOffsetTop + cy,\r\n            offsetLeft: self.canvasOffsetLeft + cx,\r\n            scrollTop: self.scrollBox.scrollTop,\r\n            scrollLeft: self.scrollBox.scrollLeft,\r\n            active: active || activeHeader,\r\n            hovered: hovered,\r\n            selected: selected,\r\n            width: cellWidth,\r\n            height: cellHeight,\r\n            offsetWidth: cellWidth,\r\n            offsetHeight: cellHeight,\r\n            parentNode: self.intf.parentNode,\r\n            offsetParent: self.intf.parentNode,\r\n            data: d,\r\n            isCorner: isCorner,\r\n            isHeader: isHeader,\r\n            isColumnHeader: isColumnHeader,\r\n            isColumnHeaderCellCap: isColumnHeaderCellCap,\r\n            isRowHeader: isRowHeader,\r\n            rowOpen: rowOpen,\r\n            header: header,\r\n            columnIndex: columnOrderIndex,\r\n            rowIndex: rowOrderIndex,\r\n            sortColumnIndex: headerIndex,\r\n            sortRowIndex: rowIndex,\r\n            isGrid: isGrid,\r\n            isNormal: !isGrid && !isCorner && !isHeader,\r\n            gridId: (self.attributes.name || '') + rowIndex + ':' + headerIndex,\r\n            parentGrid: self.intf,\r\n            innerHTML: '',\r\n            activeHeader: activeHeader,\r\n            value: isHeader && !isRowHeader ? (header.title || header.name) : rawValue\r\n          };\r\n          cell.calculatedLineHeight = (cell.fontHeight * cell.lineHeight) + cell.lineSpacing;\r\n          cell.paddedWidth = cell.width - cell.paddingRight - cell.paddingLeft;\r\n          cell.paddedHeight = cell.height - cell.paddingTop - cell.paddingBottom;\r\n          ev.cell = cell;\r\n          cell.userHeight = cell.isHeader ? self.sizes.rows[-1] : rowHeight;\r\n          cell.userWidth = cell.isHeader ? self.sizes.columns.cornerCell : self.sizes.columns[headerIndex];\r\n          self.visibleCells.unshift(cell);\r\n          if (self.dispatchEvent('beforerendercell', ev)) { return; }\r\n          self.ctx.fillStyle = self.style[cellStyle + 'BackgroundColor'];\r\n          self.ctx.strokeStyle = self.style[cellStyle + 'BorderColor'];\r\n          self.ctx.lineWidth = self.style[cellStyle + 'BorderWidth'];\r\n          if (hovered) {\r\n            self.ctx.fillStyle = self.style[cellStyle + 'HoverBackgroundColor'];\r\n            self.ctx.strokeStyle = self.style[cellStyle + 'HoverBorderColor'];\r\n          }\r\n          if (selected) {\r\n            self.ctx.fillStyle = self.style[cellStyle + 'SelectedBackgroundColor'];\r\n            self.ctx.strokeStyle = self.style[cellStyle + 'SelectedBorderColor'];\r\n          }\r\n          if (activeHeader) {\r\n            self.ctx.fillStyle = self.style[activeHeader + 'BackgroundColor'];\r\n          }\r\n          self.dispatchEvent('rendercell', ev);\r\n          if (cell.isGrid) {\r\n            if (cell.height !== rowHeight) {\r\n              cell.height = rowHeight || self.style.cellHeightWithChildGrid;\r\n              checkScrollHeight = true;\r\n            }\r\n            cell.width = self.sizes.columns[headerIndex] || self.style.cellWidthWithChildGrid;\r\n          }\r\n          if (rowOpen && !cell.isRowHeader) {\r\n            cell.height = self.sizes.rows[rowIndex] || self.style.cellHeight;\r\n          }\r\n          if (!cell.isGrid) {\r\n            fillRect(cx, cy, cell.width, cell.height);\r\n            strokeRect(cx, cy, cell.width, cell.height);\r\n          }\r\n          self.ctx.save();\r\n          radiusRect(cell.x, cell.y, cell.width, cell.height, 0);\r\n          self.ctx.clip();\r\n          self.dispatchEvent('afterrendercell', ev);\r\n          if (cell.height !== cellHeight && !(rowOpen && !cell.isRowHeader)) {\r\n            self.sizes.rows[isHeader ? -1 : rowIndex] = cell.height;\r\n            checkScrollHeight = true;\r\n          }\r\n          if (cell.width !== cellWidth) {\r\n            self.sizes.columns[headerIndex] = cell.width;\r\n            checkScrollHeight = true;\r\n          }\r\n          if (isRowHeader && self.attributes.tree) {\r\n            if (!self.dispatchEvent('rendertreearrow', ev)) {\r\n              treeArrowSize = drawTreeArrow(cell, self.style[cellStyle + 'PaddingLeft'], cy, 0);\r\n            }\r\n          }\r\n          if ((self.attributes.showRowNumbers && isRowHeader)\r\n            || !isRowHeader) {\r\n            if (cell.isGrid && !self.dispatchEvent('beforerendercellgrid', ev)) {\r\n              if (!self.childGrids[cell.gridId]) {\r\n                // HACK: this only allows setting of the child grids styles if data is set _after_\r\n                // this is less than desirable.  An interface needs to be made to effect the\r\n                // style of all cell grids.  One for individual grids already exists.\r\n                cellGridAttributes = self.cellGridAttributes;\r\n                cellGridAttributes.name = self.attributes.saveAppearance ? cell.gridId : undefined;\r\n                cellGridAttributes.component = false;\r\n                cellGridAttributes.parentNode = cell;\r\n                cellGridAttributes.data = rawValue;\r\n                ev.cellGridAttributes = cellGridAttributes;\r\n                if (self.dispatchEvent('beforecreatecellgrid', ev)) { return; }\r\n                self.childGrids[cell.gridId] = self.createGrid(cellGridAttributes);\r\n                self.sizes.rows[rowIndex]\r\n                  = self.sizes.rows[rowIndex] || self.style.cellGridHeight;\r\n                checkScrollHeight = true;\r\n              }\r\n              cell.grid = self.childGrids[cell.gridId];\r\n              cell.grid.parentNode = cell;\r\n              cell.grid.visible = true;\r\n              cell.grid.draw();\r\n              self.dispatchEvent('rendercellgrid', ev);\r\n            } else if (!cell.isGrid) {\r\n              if (self.childGrids[cell.gridId]) {\r\n                self.childGrids[cell.gridId].parentNode.offsetHeight = 0;\r\n              }\r\n              if (isHeader && self.orderBy === header.name) {\r\n                if (!self.dispatchEvent('renderorderbyarrow', ev)) {\r\n                  orderByArrowSize = drawOrderByArrow(cx + self.style[cellStyle + 'PaddingLeft'], 0);\r\n                }\r\n              }\r\n              self.ctx.fillStyle = self.style[cellStyle + 'Color'];\r\n              if (hovered) {\r\n                self.ctx.fillStyle = self.style[cellStyle + 'HoverColor'];\r\n              }\r\n              if (selected) {\r\n                self.ctx.fillStyle = self.style[cellStyle + 'SelectedColor'];\r\n              }\r\n              if (activeHeader) {\r\n                self.ctx.fillStyle = self.style[activeHeader + 'Color'];\r\n              }\r\n              cell.treeArrowWidth = treeArrowSize;\r\n              cell.orderByArrowWidth = orderByArrowSize;\r\n              // create text ref to see if height needs to expand\r\n              val = val !== undefined ? val : f\r\n                ? f(ev) : '';\r\n              if (val === undefined && !f) {\r\n                val = '';\r\n                console.warn('canvas-datagrid: Unknown format '\r\n                  + header.type + ' add a cellFormater');\r\n              }\r\n              cell.formattedValue = ((val !== undefined && val !== null) ? val : '').toString();\r\n              if (self.columnFilters && self.columnFilters[val] !== undefined && isHeader) {\r\n                cell.formattedValue = self.attributes.filterTextPrefix + val;\r\n              }\r\n              self.ctx.font = (self.style[cellStyle + 'FontHeight'] * self.scale) + 'px ' + self.style[cellStyle + 'FontName'];\r\n              if (!self.dispatchEvent('formattext', ev)) {\r\n                cell.text = wrapText(cell, ' ');\r\n              }\r\n              if (!self.dispatchEvent('rendertext', ev)) {\r\n                if (cell.innerHTML || header.type === 'html') {\r\n                  drawHtml(cell);\r\n                } else {\r\n                  drawText(cell);\r\n                }\r\n              }\r\n            }\r\n          }\r\n          if (active) {\r\n            aCell = cell;\r\n          }\r\n          createBorderOverlayArray(cell, selectionBorders, 'selection');\r\n          // createBorderOverlayArray calculates data for createHandlesOverlayArray so it must go 2nd\r\n          createHandlesOverlayArray(cell);\r\n          if (self.movingSelection) {\r\n            createBorderOverlayArray(cell, moveBorders, 'move', self.moveOffset);\r\n          }\r\n          self.ctx.restore();\r\n          x += cell.width + (bc ? 0 : self.style.cellBorderWidth);\r\n          return cell.width;\r\n        };\r\n      }\r\n      function drawRowHeader(rowData, index, rowOrderIndex) {\r\n        var a, i;\r\n        if (self.attributes.showRowHeaders) {\r\n          x = 0;\r\n          i = index + 1;\r\n          rowHeaderCell = { 'rowHeaderCell': i };\r\n          a = {\r\n            name: 'rowHeaderCell',\r\n            width: self.sizes.columns[-1] || self.style.rowHeaderCellWidth,\r\n            style: 'rowHeaderCell',\r\n            type: 'string',\r\n            data: i,\r\n            index: -1\r\n          };\r\n          rowOpen = self.openChildren[index];\r\n          drawCell(rowHeaderCell, index, rowOrderIndex)(a, -1, -1);\r\n        }\r\n      }\r\n      function drawHeaders() {\r\n        var d, g = s.length, i, o, columnHeaderCell, header, nonFrozenHeaderWidth;\r\n        function drawHeaderColumnRange(start, end) {\r\n          end = Math.min(end, g);\r\n          for (o = start; o < end; o += 1) {\r\n            i = self.orders.columns[o];\r\n            header = s[i];\r\n            if (!header.hidden) {\r\n              d = {\r\n                title: header.title,\r\n                name: header.name,\r\n                width: header.width || self.style.cellWidth,\r\n                style: 'columnHeaderCell',\r\n                type: 'string',\r\n                index: o,\r\n                order: i\r\n              };\r\n              columnHeaderCell = { 'columnHeaderCell': header.title || header.name };\r\n              x += drawCell(columnHeaderCell, -1, -1)(d, i, o);\r\n              if (x > self.width + self.scrollBox.scrollLeft) {\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n        rowHeaders.forEach(function (rArgs, rhIndex) {\r\n          y = rArgs[3];\r\n          cellHeight = rArgs[4];\r\n          if (rhIndex === self.frozenRow) {\r\n            self.ctx.save();\r\n            radiusRect(0, self.lastFrozenRowPixel, self.width, self.height - self.lastFrozenRowPixel, 0);\r\n            self.ctx.clip();\r\n          }\r\n          drawRowHeader(rArgs[0], rArgs[1], rArgs[2]);\r\n        });\r\n        self.ctx.restore();\r\n        if (self.attributes.showColumnHeaders) {\r\n          x = -self.scrollBox.scrollLeft + self.scrollPixelLeft + self.style.columnHeaderCellBorderWidth;\r\n          if (self.attributes.showRowHeaders) {\r\n            x += rowHeaderCellWidth;\r\n          }\r\n          y = 0;\r\n          // cell height might have changed during drawing\r\n          cellHeight = self.getColumnHeaderCellHeight();\r\n          drawHeaderColumnRange(self.scrollIndexLeft, g);\r\n          nonFrozenHeaderWidth = x;\r\n          x = self.style.columnHeaderCellBorderWidth;\r\n          if (self.attributes.showRowHeaders) {\r\n            x += rowHeaderCellWidth;\r\n          }\r\n          drawHeaderColumnRange(0, self.frozenColumn);\r\n          // fill in the space right of the headers\r\n          x = nonFrozenHeaderWidth;\r\n          if (x < w) {\r\n            c = {\r\n              name: '',\r\n              width: self.style.scrollBarWidth,\r\n              style: 'columnHeaderCellCap',\r\n              isColumnHeaderCell: true,\r\n              isColumnHeaderCellCap: true,\r\n              type: 'string',\r\n              index: s.length\r\n            };\r\n            drawCell({ endCap: '' }, -1, -1)(c, -1, -1);\r\n          }\r\n          // fill in the space right of the headers\r\n          if (self.attributes.showRowHeaders) {\r\n            cornerCell = { 'cornerCell': '' };\r\n            x = 0;\r\n            c = {\r\n              name: 'cornerCell',\r\n              width: self.style.rowHeaderCellWidth,\r\n              style: 'cornerCell',\r\n              type: 'string',\r\n              index: -1\r\n            };\r\n            drawCell(cornerCell, -1, -1)(c, -1, -1);\r\n          }\r\n        }\r\n      }\r\n      function drawRow(r, d) {\r\n        var i, treeHeight, rowSansTreeHeight, o, g = s.length;\r\n        if (y - (cellHeight * 2) > h) {\r\n          return false;\r\n        }\r\n        rd = data[r];\r\n        rowOpen = self.openChildren[r];\r\n        rowSansTreeHeight = (self.sizes.rows[r] || self.style.cellHeight) * self.scale;\r\n        treeHeight = (rowOpen ? self.sizes.trees[r] : 0) * self.scale;\r\n        rowHeight = (rowSansTreeHeight + treeHeight);\r\n        if (y < -rowHeight) {\r\n          return false;\r\n        }\r\n        if (self.attributes.showRowHeaders) {\r\n          x += rowHeaderCellWidth;\r\n        }\r\n        cellHeight = rowHeight;\r\n        //draw normal columns\r\n        for (o = (self.scrollIndexLeft); o < g; o += 1) {\r\n          i = self.orders.columns[o];\r\n          x += drawCell(rd, r, d)(s[i], i, o);\r\n          if (x > self.width) {\r\n            self.scrollIndexRight = o;\r\n            self.scrollPixelRight = x;\r\n            break;\r\n          }\r\n        }\r\n        //draw frozen columns\r\n        x = 0;\r\n        if (self.attributes.showRowHeaders) {\r\n          x += rowHeaderCellWidth;\r\n        }\r\n        for (o = 0; o < self.frozenColumn; o += 1) {\r\n          i = self.orders.columns[o];\r\n          x += drawCell(rd, r, d)(s[i], i, o);\r\n          if (x > self.width) {\r\n            break;\r\n          }\r\n        }\r\n        self.lastFrozenColumnPixel = x;\r\n        // cell height might have changed during drawing\r\n        cellHeight = rowHeight;\r\n        x = -self.scrollBox.scrollLeft + self.scrollPixelLeft + self.style.cellBorderWidth;\r\n        // don't draw a tree for the new row\r\n        treeGrid = self.childGrids[r];\r\n        if (r !== data.length && rowOpen) {\r\n          treeGrid.visible = true;\r\n          treeGrid.parentNode = {\r\n            offsetTop: y + rowSansTreeHeight + self.canvasOffsetTop,\r\n            offsetLeft: rowHeaderCellWidth - 1 + self.canvasOffsetLeft,\r\n            offsetHeight: treeHeight,\r\n            offsetWidth: self.width - rowHeaderCellWidth - self.style.scrollBarWidth - 1,\r\n            offsetParent: self.intf.parentNode,\r\n            parentNode: self.intf.parentNode,\r\n            style: self.style,\r\n            nodeType: 'canvas-datagrid-tree',\r\n            scrollTop: self.scrollBox.scrollTop,\r\n            scrollLeft: self.scrollBox.scrollLeft,\r\n            rowIndex: r\r\n          };\r\n          self.visibleCells.unshift({\r\n            rowIndex: r,\r\n            columnIndex: 0,\r\n            y: treeGrid.parentNode.offsetTop,\r\n            x: treeGrid.parentNode.offsetLeft,\r\n            height: treeGrid.height,\r\n            width: treeGrid.width,\r\n            style: 'tree-grid',\r\n            type: treeGrid.parentNode.nodeType\r\n          });\r\n          treeGrid.draw();\r\n        } else if (treeGrid) {\r\n          treeGrid.parentNode.offsetHeight = 0;\r\n          delete self.sizes.trees[r];\r\n        }\r\n        rowHeaders.push([rd, r, d, y, rowHeight]);\r\n        self.visibleRowHeights[r] = rowHeight;\r\n        y += cellHeight + (bc ? 0 : self.style.cellBorderWidth);\r\n        return true;\r\n      }\r\n      function initDraw() {\r\n        self.visibleRows = [];\r\n        s = self.getSchema();\r\n        self.visibleCells = [];\r\n        self.canvasOffsetTop = self.isChildGrid ? self.parentNode.offsetTop : 0;\r\n        self.canvasOffsetLeft = self.isChildGrid ? self.parentNode.offsetLeft : 0;\r\n        h = self.height;\r\n        w = self.width;\r\n      }\r\n      function drawBackground() {\r\n        radiusRect(0, 0, w, h, 0);\r\n        self.ctx.clip();\r\n        self.ctx.fillStyle = self.style.gridBackgroundColor;\r\n        fillRect(0, 0, w, h);\r\n      }\r\n      function drawFrozenRows() {\r\n        var n, ln = Math.min(data.length, self.frozenRow);\r\n        x = -self.scrollBox.scrollLeft + self.scrollPixelLeft + self.style.cellBorderWidth;\r\n        y = columnHeaderCellHeight;\r\n        for (r = 0; r < ln; r += 1) {\r\n          n = self.orders.rows[r];\r\n          if (!drawRow(n, r)) {\r\n            break;\r\n          }\r\n        }\r\n        if (self.attributes.allowFreezingRows) {\r\n          // HACK great, another stupid magic number.\r\n          // Background will appear as a 0.5px artifact behind the row freeze bar without this hack\r\n          y += self.style.frozenMarkerBorderWidth + self.style.frozenMarkerWidth - 0.4999999999;\r\n        }\r\n        self.lastFrozenRowPixel = y;\r\n      }\r\n      function drawRows() {\r\n        self.ctx.save();\r\n        if (self.frozenRow > 0) {\r\n          radiusRect(0, self.lastFrozenRowPixel, self.width, self.height - self.lastFrozenRowPixel, 0);\r\n          self.ctx.clip();\r\n        }\r\n        var o, n, i, g = s.length;\r\n        x = -self.scrollBox.scrollLeft + self.scrollPixelLeft + self.style.cellBorderWidth;\r\n        if (!self.attributes.snapToRow) {\r\n          y += -self.scrollBox.scrollTop + self.scrollPixelTop + self.style.cellBorderWidth;\r\n        }\r\n        for (r = self.frozenRow + self.scrollIndexTop; r < l; r += 1) {\r\n          n = self.orders.rows[r];\r\n          self.scrollIndexBottom = r;\r\n          self.scrollPixelBottom = y;\r\n          if (!drawRow(n, r)) {\r\n            break;\r\n          }\r\n        }\r\n        if (self.attributes.showNewRow) {\r\n          if (self.attributes.showRowHeaders) {\r\n            x += rowHeaderCellWidth;\r\n          }\r\n          rowHeight = cellHeight = self.style.cellHeight;\r\n          rowOpen = false;\r\n          for (o = self.scrollIndexLeft; o < g; o += 1) {\r\n            i = self.orders.columns[o];\r\n            x += drawCell(self.newRow, data.length, data.length)(s[i], i, o);\r\n            if (x > self.width + self.scrollBox.scrollLeft) {\r\n              break;\r\n            }\r\n          }\r\n          rowHeaders.push([self.newRow, data.length, data.length, y, rowHeight]);\r\n        }\r\n        self.ctx.restore();\r\n      }\r\n      function drawMoveMarkers() {\r\n        if (!self.movingSelection) { return; }\r\n        self.ctx.lineWidth = self.style.moveOverlayBorderWidth;\r\n        self.ctx.strokeStyle = self.style.moveOverlayBorderColor;\r\n        self.ctx.setLineDash(self.style.moveOverlayBorderSegments);\r\n        moveBorders.forEach(function (c) {\r\n          addBorderLine(c[0], c[1]);\r\n        });\r\n        self.ctx.setLineDash([]);\r\n      }\r\n      function drawReorderMarkers() {\r\n        if (!self.reorderObject) { return; }\r\n        var b = {\r\n          height: self.reorderObject.height,\r\n          width: self.reorderObject.width,\r\n          x: self.reorderObject.x + self.reorderObject.dragOffset.x,\r\n          y: self.reorderObject.y + self.reorderObject.dragOffset.y\r\n        },\r\n          m = {\r\n            width: w,\r\n            height: h,\r\n            x: 0,\r\n            y: 0\r\n          };\r\n        self.ctx.fillStyle = self.style.reorderMarkerBackgroundColor;\r\n        self.ctx.lineWidth = self.style.reorderMarkerBorderWidth;\r\n        self.ctx.strokeStyle = self.style.reorderMarkerBorderColor;\r\n        if (self.dragMode === 'row-reorder') {\r\n          b.width = w;\r\n          b.x = 0;\r\n          m.width = w;\r\n          m.height = self.currentCell.height;\r\n          m.y = self.currentCell.y;\r\n          fillRect(b.x, b.y, b.width, b.height);\r\n          strokeRect(b.x, b.y, b.width, b.height);\r\n          self.ctx.lineWidth = self.style.reorderMarkerIndexBorderWidth;\r\n          self.ctx.strokeStyle = self.style.reorderMarkerIndexBorderColor;\r\n          if (self.currentCell.rowIndex !== self.reorderObject.rowIndex\r\n            && self.currentCell.rowIndex > -1\r\n            && self.currentCell.rowIndex < l) {\r\n            addBorderLine(m, self.reorderTarget.sortRowIndex > self.reorderObject.sortRowIndex ? 'b' : 't');\r\n          }\r\n        } else if (self.dragMode === 'column-reorder' && self.reorderObject) {\r\n          b.height = h;\r\n          b.y = 0;\r\n          m.height = h;\r\n          m.width = self.currentCell.width;\r\n          m.y = 0;\r\n          m.x = self.currentCell.x;\r\n          fillRect(b.x, b.y, b.width, b.height);\r\n          strokeRect(b.x, b.y, b.width, b.height);\r\n          self.ctx.lineWidth = self.style.reorderMarkerIndexBorderWidth;\r\n          self.ctx.strokeStyle = self.style.reorderMarkerIndexBorderColor;\r\n          if (self.currentCell.sortColumnIndex !== self.reorderObject.sortColumnIndex\r\n            && self.currentCell.sortColumnIndex > -1\r\n            && self.currentCell.sortColumnIndex < s.length) {\r\n            addBorderLine(m, self.reorderTarget.columnIndex > self.reorderObject.columnIndex ? 'r' : 'l');\r\n          }\r\n        }\r\n      }\r\n      function drawBorder() {\r\n        self.ctx.lineWidth = self.style.gridBorderWidth;\r\n        self.ctx.strokeStyle = self.style.gridBorderColor;\r\n        strokeRect(0, 0, self.width, self.height);\r\n      }\r\n      function drawSelectionBorders() {\r\n        self.ctx.lineWidth = self.style.selectionOverlayBorderWidth;\r\n        self.ctx.strokeStyle = self.style.selectionOverlayBorderColor;\r\n        function dsb(c) {\r\n          addBorderLine(c[0], c[1]);\r\n        }\r\n        selectionBorders.filter(function (c) {\r\n          return c[0].rowIndex < self.frozenRow && c[0].columnIndex < self.frozenColumn;\r\n        }).forEach(dsb);\r\n        self.ctx.save();\r\n        clipFrozenArea(0);\r\n        selectionBorders.filter(function (c) {\r\n          return c[0].rowIndex >= self.frozenRow && c[0].columnIndex >= self.frozenColumn;\r\n        }).forEach(dsb);\r\n        self.ctx.restore();\r\n        self.ctx.save();\r\n        clipFrozenArea(1);\r\n        selectionBorders.filter(function (c) {\r\n          return c[0].rowIndex >= self.frozenRow && c[0].columnIndex < self.frozenColumn;\r\n        }).forEach(dsb);\r\n        self.ctx.restore();\r\n        self.ctx.save();\r\n        clipFrozenArea(2);\r\n        selectionBorders.filter(function (c) {\r\n          return c[0].rowIndex < self.frozenRow && c[0].columnIndex >= self.frozenColumn;\r\n        }).forEach(dsb);\r\n        self.ctx.restore();\r\n      }\r\n      function drawSelectionHandles() {\r\n        if (self.mobile || self.attributes.allowMovingSelection) {\r\n          self.ctx.lineWidth = self.style.selectionHandleBorderWidth;\r\n          self.ctx.strokeStyle = self.style.selectionHandleBorderColor;\r\n          self.ctx.fillStyle = self.style.selectionHandleColor;\r\n          selectionHandles.forEach(function (c) {\r\n            addselectionHandle(c[0], c[1]);\r\n            var az = self.attributes.touchSelectHandleZone / 2,\r\n              ax = c[0].x + (c[1] === 'tl' || c[1] === 'bl' ? 0 : c[0].width) - az,\r\n              ay = c[0].y + (c[1] === 'bl' || c[1] === 'br' ? c[0].height : 0) - az;\r\n            self.visibleCells.unshift({\r\n              x: ax,\r\n              y: ay,\r\n              height: self.style.selectionHandleSize + az,\r\n              width: self.style.selectionHandleSize + az,\r\n              style: 'selection-handle-' + c[1]\r\n            });\r\n          });\r\n        }\r\n      }\r\n      function drawActiveCell() {\r\n        if (!aCell) { return; }\r\n        self.ctx.save();\r\n        var cl = self.activeCell.columnIndex + 1 > self.frozenColumn || self.activeCell.rowIndex + 1 > self.frozenRow,\r\n          acx = cl ? self.lastFrozenColumnPixel : 0,\r\n          acy = cl ? self.lastFrozenRowPixel : 0,\r\n          acw = cl ? self.width - self.lastFrozenColumnPixel : self.width,\r\n          ach = cl ? self.height - self.lastFrozenRowPixel : self.height;\r\n        radiusRect(acx, acy, acw, ach, 0);\r\n        self.ctx.clip();\r\n        if (self.attributes.selectionMode === 'row') {\r\n          if (self.activeCell && self.activeCell.rowIndex === aCell.rowIndex) {\r\n            self.ctx.lineWidth = self.style.activeCellOverlayBorderWidth;\r\n            self.ctx.strokeStyle = self.style.activeCellOverlayBorderColor;\r\n            strokeRect(0, aCell.y, self.getHeaderWidth() + rowHeaderCellWidth, self.visibleRowHeights[aCell.rowIndex]);\r\n          }\r\n        } else {\r\n          self.ctx.lineWidth = self.style.activeCellOverlayBorderWidth;\r\n          self.ctx.strokeStyle = self.style.activeCellOverlayBorderColor;\r\n          strokeRect(aCell.x, aCell.y, aCell.width, aCell.height);\r\n        }\r\n        self.ctx.restore();\r\n      }\r\n      function drawFrozenMarkers() {\r\n        var my = self.lastFrozenRowPixel - self.style.frozenMarkerWidth,\r\n          mx = self.lastFrozenColumnPixel - self.style.frozenMarkerBorderWidth,\r\n          xHover = self.currentCell && self.currentCell.style === 'frozen-row-marker',\r\n          yHover = self.currentCell && self.currentCell.style === 'frozen-column-marker';\r\n        self.ctx.lineWidth = self.style.frozenMarkerBorderWidth;\r\n        if (self.attributes.allowFreezingColumns) {\r\n          self.ctx.fillStyle = yHover ? self.style.frozenMarkerHoverColor : self.style.frozenMarkerColor;\r\n          self.ctx.strokeStyle = yHover ? self.style.frozenMarkerHoverBorderColor : self.style.frozenMarkerBorderColor;\r\n          fillRect(mx, 0, self.style.frozenMarkerWidth, self.height);\r\n          strokeRect(mx, 0, self.style.frozenMarkerWidth, self.height);\r\n          self.visibleCells.unshift({\r\n            x: mx,\r\n            y: 0,\r\n            height: self.height,\r\n            width: self.style.frozenMarkerWidth + self.style.frozenMarkerBorderWidth,\r\n            style: 'frozen-column-marker'\r\n          });\r\n        }\r\n        if (self.attributes.allowFreezingRows) {\r\n          self.ctx.fillStyle = xHover ? self.style.frozenMarkerHoverColor : self.style.frozenMarkerColor;\r\n          self.ctx.strokeStyle = xHover ? self.style.frozenMarkerHoverBorderColor : self.style.frozenMarkerBorderColor;\r\n          fillRect(0, my, self.width, self.style.frozenMarkerWidth);\r\n          strokeRect(0, my, self.width, self.style.frozenMarkerWidth);\r\n          self.visibleCells.unshift({\r\n            x: 0,\r\n            y: my,\r\n            height: self.style.frozenMarkerWidth + self.style.frozenMarkerBorderWidth,\r\n            width: self.width,\r\n            style: 'frozen-row-marker'\r\n          });\r\n        }\r\n        if (self.freezeMarkerPosition) {\r\n          self.ctx.fillStyle = self.style.frozenMarkerActiveColor;\r\n          self.ctx.strokeStyle = self.style.frozenMarkerActiveBorderColor;\r\n          if (self.dragMode === 'frozen-column-marker') {\r\n            fillRect(self.freezeMarkerPosition.x, 0, self.style.frozenMarkerWidth, self.height);\r\n            strokeRect(self.freezeMarkerPosition.x, 0, self.style.frozenMarkerWidth, self.height);\r\n          } else {\r\n            fillRect(0, self.freezeMarkerPosition.y, self.width, self.style.frozenMarkerWidth);\r\n            strokeRect(0, self.freezeMarkerPosition.y, self.width, self.style.frozenMarkerWidth);\r\n          }\r\n        }\r\n      }\r\n      function drawPerfLines() {\r\n        if (!self.attributes.showPerformance) { return; }\r\n        var pw = 250,\r\n          px = self.width - pw - self.style.scrollBarWidth - (self.style.scrollBarBorderWidth * 2),\r\n          py = columnHeaderCellHeight,\r\n          ph = 100;\r\n        if (scrollDebugCounters.length === 0) { scrollDebugCounters = fillArray(0, perfWindowSize, 1, function () { return [0, 0]; }); }\r\n        if (touchPPSCounters.length === 0) { touchPPSCounters = fillArray(0, perfWindowSize, 1, function () { return [0, 0]; }); }\r\n        if (entityCount.length === 0) { entityCount = fillArray(0, perfWindowSize, 1, 0); }\r\n        self.ctx.lineWidth = 0.5;\r\n        function dpl(name, perfArr, arrIndex, max, color, useAbs, rowIndex) {\r\n          var v;\r\n          drawPerfLine(pw, ph, px, py, perfArr, arrIndex, max, color, useAbs);\r\n          self.ctx.fillStyle = color;\r\n          fillRect(3 + px, py + 9 + (rowIndex * 11), 8, 8);\r\n          self.ctx.fillStyle = self.style.debugPerfChartTextColor;\r\n          v = arrIndex !== undefined ? perfArr[0][arrIndex] : perfArr[0];\r\n          fillText(name + ' ' + (isNaN(v) ? 0 : v).toFixed(3), 14 + px, py + 16 + (rowIndex * 11));\r\n        }\r\n        self.ctx.textAlign = 'left';\r\n        self.ctx.font = self.style.debugFont;\r\n        self.ctx.fillStyle = self.style.debugPerfChartBackground;\r\n        fillRect(px, py, pw, ph);\r\n        [['Scroll Height', scrollDebugCounters, 0, self.scrollBox.scrollHeight, self.style.debugScrollHeightColor, false],\r\n        ['Scroll Width', scrollDebugCounters, 1, self.scrollBox.scrollWidth, self.style.debugScrollWidthColor, false],\r\n        ['Performance', perfCounters, undefined, 200, self.style.debugPerformanceColor, false],\r\n        ['Entities', entityCount, undefined, 1500, self.style.debugEntitiesColor, false],\r\n        ['TouchPPSX', touchPPSCounters, 0, 1000, self.style.debugTouchPPSXColor, true],\r\n        ['TouchPPSY', touchPPSCounters, 1, 1000, self.style.debugTouchPPSYColor, true]\r\n        ].forEach(function (i, index) {\r\n          i.push(index);\r\n          dpl.apply(null, i);\r\n        });\r\n        self.ctx.fillStyle = self.style.debugPerfChartBackground;\r\n        entityCount.pop();\r\n        entityCount.unshift(self.visibleCells.length);\r\n        scrollDebugCounters.pop();\r\n        scrollDebugCounters.unshift([self.scrollBox.scrollTop, self.scrollBox.scrollLeft]);\r\n        touchPPSCounters.pop();\r\n        touchPPSCounters.unshift([self.yPPS, self.xPPS]);\r\n      }\r\n      function drawDebug() {\r\n        self.ctx.save();\r\n        var d;\r\n        if (self.attributes.showPerformance || self.attributes.debug) {\r\n          if (perfCounters.length === 0) { perfCounters = fillArray(0, perfWindowSize, 1, 0); }\r\n          perfCounters.pop();\r\n          perfCounters.unshift(performance.now() - p);\r\n        }\r\n        if (!self.attributes.debug) {\r\n          self.ctx.restore();\r\n          return;\r\n        }\r\n        self.ctx.font = self.style.debugFont;\r\n        d = {};\r\n        d.perf = (perfCounters.reduce(function (a, b) {\r\n          return a + b;\r\n        }, 0) / Math.min(drawCount, perfCounters.length)).toFixed(1);\r\n        d.perfDelta = perfCounters[0].toFixed(1);\r\n        d.frozenColumnsWidth = getFrozenColumnsWidth();\r\n        d.htmlImages = Object.keys(self.htmlImageCache).length;\r\n        d.reorderObject = 'x: ' + (self.reorderObject || { columnIndex: 0 }).columnIndex + ', y: ' + (self.reorderObject || { rowIndex: 0 }).rowIndex;\r\n        d.reorderTarget = 'x: ' + (self.reorderTarget || { columnIndex: 0 }).columnIndex + ', y: ' + (self.reorderTarget || { rowIndex: 0 }).rowIndex;\r\n        d.scale = self.scale;\r\n        d.startScale = self.startScale;\r\n        d.scaleDelta = self.scaleDelta;\r\n        d.zoomDeltaStart = self.zoomDeltaStart;\r\n        d.touchLength = self.touchLength;\r\n        d.touches = 'y0: ' + (self.touchPosition || { y: 0 }).y + ' y1: ' + (self.touchPosition1 || { y: 0 }).y;\r\n        d.scrollBox = self.scrollBox.toString();\r\n        d.scrollIndex = 'x: ' + self.scrollIndexLeft + ', y: ' + self.scrollIndexTop;\r\n        d.scrollPixel = 'x: ' + self.scrollPixelLeft + ', y: ' + self.scrollPixelTop;\r\n        d.canvasOffset = 'x: ' + self.canvasOffsetLeft + ', y: ' + self.canvasOffsetTop;\r\n        d.touchDelta = 'x: ' + self.touchDelta.x + ', y: ' + self.touchDelta.y;\r\n        d.touchAnimateTo = 'x: ' + self.touchAnimateTo.x + ', y: ' + self.touchAnimateTo.y;\r\n        d.scrollAnimation = 'x: ' + self.scrollAnimation.x + ', y: ' + self.scrollAnimation.y;\r\n        d.touchPPS = 'x: ' + self.xPPS + ', y: ' + self.yPPS;\r\n        d.touchPPST = 'x: ' + self.xPPST + ', y: ' + self.yPPST;\r\n        d.touchDuration = self.touchDuration;\r\n        d.pointerLockPosition = self.pointerLockPosition ?\r\n          self.pointerLockPosition.x + ', ' + self.pointerLockPosition.y : '';\r\n        d.size = 'w: ' + self.width + ', h: ' + self.height;\r\n        d.mouse = 'x: ' + self.mouse.x + ', y: ' + self.mouse.y;\r\n        d.touch = !self.touchStart\r\n          ? '' : 'x: ' + self.touchStart.x + ', y: ' + self.touchStart.y;\r\n        d.entities = self.visibleCells.length;\r\n        d.hasFocus = self.hasFocus;\r\n        d.dragMode = self.dragMode;\r\n        if (self.currentCell) {\r\n          d.columnIndex = self.currentCell.columnIndex;\r\n          d.rowIndex = self.currentCell.rowIndex;\r\n          d.sortColumnIndex = self.currentCell.sortColumnIndex;\r\n          d.sortRowIndex = self.currentCell.sortRowIndex;\r\n          d.context = self.currentCell.context;\r\n          d.dragContext = self.currentCell.dragContext;\r\n          d.style = self.currentCell.style;\r\n          d.type = self.currentCell.type;\r\n        }\r\n        self.ctx.textAlign = 'right';\r\n        self.ctx.fillStyle = self.style.debugBackgroundColor;\r\n        fillRect(0, 0, self.width, self.height);\r\n        Object.keys(d).forEach(function (key, index) {\r\n          var m = key + ': ' + d[key],\r\n            lh = 14;\r\n          self.ctx.fillStyle = self.style.debugColor;\r\n          fillText(m, w - 20, (self.attributes.showPerformance ? 140 : 24) + (index * lh));\r\n        });\r\n        self.ctx.restore();\r\n      }\r\n      self.ctx.save();\r\n      initDraw();\r\n      drawBackground();\r\n      drawFrozenRows();\r\n      drawRows();\r\n      drawActiveCell();\r\n      drawHeaders();\r\n      drawFrozenMarkers();\r\n      drawSelectionHandles();\r\n      drawReorderMarkers();\r\n      drawMoveMarkers();\r\n      drawBorder();\r\n      drawSelectionBorders();\r\n      drawScrollBars();\r\n      if (checkScrollHeight) {\r\n        self.resize(true);\r\n      }\r\n      drawDebug();\r\n      drawPerfLines();\r\n      if (self.dispatchEvent('afterdraw', {})) { return; }\r\n      self.ctx.restore();\r\n    };\r\n  };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/draw.js\n// module id = 3\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true, plusplus: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine([], function () {\r\n  'use strict';\r\n  return function (self) {\r\n    var wheeling;\r\n    self.stopPropagation = function (e) { e.stopPropagation(); };\r\n    /**\r\n     * Adds an event listener to the given event.\r\n     * @memberof canvasDatagrid\r\n     * @name addEventListener\r\n     * @method\r\n     * @param {string} ev The name of the event to subscribe to.\r\n     * @param {function} fn The event procedure to execute when the event is raised.\r\n     */\r\n    self.addEventListener = function (ev, fn) {\r\n      self.events[ev] = self.events[ev] || [];\r\n      self.events[ev].unshift(fn);\r\n    };\r\n    /**\r\n     * Removes the given listener function from the given event.  Must be an actual reference to the function that was bound.\r\n     * @memberof canvasDatagrid\r\n     * @name removeEventListener\r\n     * @method\r\n     * @param {string} ev The name of the event to unsubscribe from.\r\n     * @param {function} fn The event procedure to execute when the event is raised.\r\n     */\r\n    self.removeEventListener = function (ev, fn) {\r\n      (self.events[ev] || []).forEach(function removeEachListener(sfn, idx) {\r\n        if (fn === sfn) {\r\n          self.events[ev].splice(idx, 1);\r\n        }\r\n      });\r\n    };\r\n    /**\r\n     * Fires the given event, padding an event object to the event subscribers.\r\n     * @memberof canvasDatagrid\r\n     * @name dispatchEvent\r\n     * @method\r\n     * @param {number} ev The name of the event to dispatch.\r\n     * @param {number} e The event object.\r\n     */\r\n    self.dispatchEvent = function (ev, e) {\r\n      e = ev.type ? ev : (e || {});\r\n      ev = ev.type || ev;\r\n      var defaultPrevented;\r\n      function preventDefault() {\r\n        defaultPrevented = true;\r\n      }\r\n      if (!self.events[ev]) { return; }\r\n      self.events[ev].forEach(function dispatchEachEvent(fn) {\r\n        e.ctx = self.ctx;\r\n        e.preventDefault = preventDefault;\r\n        fn.apply(self.intf, [e]);\r\n      });\r\n      return defaultPrevented;\r\n    };\r\n    self.getRatio = function () {\r\n      return Math.min(self.attributes.maxPixelRatio, (window.devicePixelRatio || 1) /\r\n        (self.ctx.webkitBackingStorePixelRatio ||\r\n          self.ctx.mozBackingStorePixelRatio ||\r\n          self.ctx.msBackingStorePixelRatio ||\r\n          self.ctx.oBackingStorePixelRatio ||\r\n          self.ctx.backingStorePixelRatio || 1));\r\n    };\r\n    self.resize = function (drawAfterResize) {\r\n      if (!self.canvas) { return; }\r\n      var x,\r\n        v = {\r\n          x: 0,\r\n          y: 0,\r\n          height: 0,\r\n          width: 0,\r\n          style: 'vertical-scroll-bar'\r\n        },\r\n        n = {\r\n          x: 0,\r\n          y: 0,\r\n          height: 0,\r\n          width: 0,\r\n          style: 'horizontal-scroll-bar'\r\n        },\r\n        vb = {\r\n          x: 0,\r\n          y: 0,\r\n          height: 0,\r\n          width: 0,\r\n          style: 'vertical-scroll-box'\r\n        },\r\n        nb = {\r\n          x: 0,\r\n          y: 0,\r\n          height: 0,\r\n          width: 0,\r\n          style: 'horizontal-scroll-box'\r\n        },\r\n        co = {\r\n          x: 0,\r\n          y: 0,\r\n          height: 0,\r\n          width: 0,\r\n          isCorner: true,\r\n          isScrollBoxCorner: true,\r\n          style: 'scroll-box-corner'\r\n        },\r\n        m = (self.style.scrollBarBoxMargin * 2),\r\n        b = (self.style.scrollBarBorderWidth * 2),\r\n        d = self.style.scrollBarBoxMargin * 0.5,\r\n        sbw = self.style.scrollBarWidth + (self.style.scrollBarBorderWidth * 2),\r\n        ratio = self.getRatio(),\r\n        bm = self.style.gridBorderCollapse === 'collapse' ? 1 : 2,\r\n        cellBorder = self.style.cellBorderWidth * bm,\r\n        columnHeaderCellBorder = self.style.columnHeaderCellBorderWidth * bm,\r\n        dataHeight = 0,\r\n        dataWidth = 0,\r\n        dims,\r\n        l = (self.data || []).length,\r\n        columnHeaderCellHeight = self.getColumnHeaderCellHeight(),\r\n        rowHeaderCellWidth = self.getRowHeaderCellWidth(),\r\n        ch = self.style.cellHeight,\r\n        s = self.getSchema();\r\n      // sets actual DOM canvas element\r\n      function checkScrollBoxVisibility() {\r\n        self.scrollBox.horizontalBarVisible = (self.style.width !== 'auto' && dataWidth > self.scrollBox.width && self.style.overflowX !== 'hidden')\r\n          || self.style.overflowX === 'scroll';\r\n        self.scrollBox.horizontalBoxVisible = dataWidth > self.scrollBox.width;\r\n        self.scrollBox.verticalBarVisible = (self.style.height !== 'auto' && dataHeight > self.scrollBox.height && self.style.overflowY !== 'hidden')\r\n          || self.style.overflowY === 'scroll';\r\n        self.scrollBox.verticalBoxVisible = dataHeight > self.scrollBox.height;\r\n      }\r\n      function setScrollBoxSize() {\r\n        self.scrollBox.width = self.width - rowHeaderCellWidth;\r\n        self.scrollBox.height = self.height - columnHeaderCellHeight;\r\n      }\r\n      function setCanvasSize() {\r\n        if (self.isChildGrid) {\r\n          return;\r\n        }\r\n        dims = {\r\n          // HACK +1 ? maybe it's a magic cell border?  Required to line up properly in auto height mode.\r\n          height: columnHeaderCellHeight + dataHeight + cellBorder + 1,\r\n          width: dataWidth + rowHeaderCellWidth + cellBorder\r\n        };\r\n        ['width', 'height'].forEach(function (dim) {\r\n          //TODO: support inherit\r\n          if (['auto', undefined].indexOf(self.style[dim]) !== -1\r\n            && ['auto', undefined].indexOf(self.appliedInlineStyles[dim]) !== -1) {\r\n            self.parentNodeStyle[dim] = dims[dim] + 'px';\r\n          } else {\r\n            self.parentNodeStyle[dim] = self.style[dim];\r\n            if (self.isComponet) {\r\n              self.canvas.style[dim] = self.style[dim];\r\n            }\r\n          }\r\n        });\r\n      }\r\n      self.scrollCache.x = [];\r\n      self.scrollCache.y = [];\r\n      for (x = 0; x < l; x += 1) {\r\n        self.scrollCache.y[x] = dataHeight;\r\n        dataHeight += (((self.sizes.rows[x] || ch) + (self.sizes.trees[x] || 0)) * self.scale)\r\n          // HACK? if an expanded tree row is frozen it is necessary to add the tree row's height a second time.\r\n          + (self.frozenRow > x ? (self.sizes.trees[x] || 0) : 0);\r\n      }\r\n      if (l > 1) {\r\n        self.scrollCache.y[x] = dataHeight;\r\n      }\r\n      dataWidth = s.reduce(function reduceSchema(accumulator, column, columnIndex) {\r\n        // intentional redefintion of column.  This causes scrollCache to be in the correct order\r\n        column = s[self.orders.columns[columnIndex]];\r\n        if (column.hidden) {\r\n          self.scrollCache.x[columnIndex] = accumulator;\r\n          return accumulator;\r\n        }\r\n        var va = accumulator + self.getColummnWidth(self.orders.columns[columnIndex]);\r\n        self.scrollCache.x[columnIndex] = va;\r\n        return va;\r\n      }, 0) || 0;\r\n      if (self.attributes.showNewRow) {\r\n        dataHeight += ch;\r\n      }\r\n      if (self.attributes.snapToRow) {\r\n        dataHeight += self.style.cellHeight;\r\n      }\r\n      setCanvasSize();\r\n      if (self.isChildGrid) {\r\n        self.width = self.parentNode.offsetWidth;\r\n        self.height = self.parentNode.offsetHeight;\r\n      } else if (self.height !== self.canvas.offsetHeight || self.width !== self.canvas.offsetWidth) {\r\n        self.height = self.canvas.offsetHeight;\r\n        self.width = self.canvas.offsetWidth;\r\n        self.canvasOffsetLeft = self.args.canvasOffsetLeft || 0;\r\n        self.canvasOffsetTop = self.args.canvasOffsetTop || 0;\r\n      }\r\n      /// calculate scroll bar dimensions\r\n      // non-controversial\r\n      self.scrollBox.top = columnHeaderCellHeight + columnHeaderCellBorder;\r\n      self.scrollBox.left = rowHeaderCellWidth;\r\n      // width and height of scroll box\r\n      setScrollBoxSize();\r\n      // is the data larger than the scroll box\r\n      checkScrollBoxVisibility();\r\n      // if the scroll box is visible, make room for it by expanding the size of the element\r\n      // if the other dimension is set to auto\r\n      if (self.scrollBox.horizontalBarVisible) {\r\n        if (self.style.height === 'auto' && !self.isChildGrid) {\r\n          self.height += sbw;\r\n        }\r\n        dataHeight += sbw;\r\n        setCanvasSize();\r\n        setScrollBoxSize();\r\n        checkScrollBoxVisibility();\r\n      }\r\n      if (self.scrollBox.verticalBarVisible) {\r\n        if (self.style.width === 'auto' && !self.isChildGrid) {\r\n          self.width += sbw;\r\n        }\r\n        dataWidth += sbw;\r\n        setCanvasSize();\r\n        setScrollBoxSize();\r\n        checkScrollBoxVisibility();\r\n      }\r\n      // set again after bar visibility checks\r\n      setScrollBoxSize();\r\n      self.scrollBox.scrollWidth = dataWidth - self.scrollBox.width;\r\n      self.scrollBox.scrollHeight = dataHeight - self.scrollBox.height;\r\n      self.scrollBox.widthBoxRatio = self.scrollBox.width / dataWidth;\r\n      self.scrollBox.scrollBoxWidth = self.scrollBox.width\r\n        * self.scrollBox.widthBoxRatio\r\n        - self.style.scrollBarWidth - b - d;\r\n      // TODO: This heightBoxRatio number is terribly wrong.\r\n      // They should be a result of the size of the grid/canvas?\r\n      // it being off causes the scroll bar to \"slide\" under\r\n      // the dragged mouse.\r\n      // https://github.com/TonyGermaneri/canvas-datagrid/issues/97\r\n      self.scrollBox.heightBoxRatio = (self.scrollBox.height - columnHeaderCellHeight) / dataHeight;\r\n      self.scrollBox.scrollBoxHeight = self.scrollBox.height\r\n        * self.scrollBox.heightBoxRatio\r\n        - self.style.scrollBarWidth - b - d;\r\n      self.scrollBox.scrollBoxWidth = Math.max(self.scrollBox.scrollBoxWidth, self.style.scrollBarBoxMinSize);\r\n      self.scrollBox.scrollBoxHeight = Math.max(self.scrollBox.scrollBoxHeight, self.style.scrollBarBoxMinSize);\r\n      // horizontal\r\n      n.x += rowHeaderCellWidth;\r\n      n.y += self.height - self.style.scrollBarWidth - d;\r\n      n.width = self.width - self.style.scrollBarWidth - rowHeaderCellWidth - d - m;\r\n      n.height = self.style.scrollBarWidth + self.style.scrollBarBorderWidth + d;\r\n      // horizontal box\r\n      nb.y = n.y + self.style.scrollBarBoxMargin;\r\n      nb.width = self.scrollBox.scrollBoxWidth;\r\n      nb.height = self.style.scrollBarBoxWidth;\r\n      // vertical\r\n      v.x += self.width - self.style.scrollBarWidth - self.style.scrollBarBorderWidth - d;\r\n      v.y += columnHeaderCellHeight;\r\n      v.width = self.style.scrollBarWidth + self.style.scrollBarBorderWidth + d;\r\n      v.height = self.height - columnHeaderCellHeight - self.style.scrollBarWidth - d - m;\r\n      // vertical box\r\n      vb.x = v.x + self.style.scrollBarBoxMargin;\r\n      vb.width = self.style.scrollBarBoxWidth;\r\n      vb.height = self.scrollBox.scrollBoxHeight;\r\n      // corner\r\n      co.x = n.x + n.width + m;\r\n      co.y = v.y + v.height + m;\r\n      co.width = self.style.scrollBarWidth + self.style.scrollBarBorderWidth;\r\n      co.height = self.style.scrollBarWidth + self.style.scrollBarBorderWidth;\r\n      self.scrollBox.entities = {\r\n        horizontalBar: n,\r\n        horizontalBox: nb,\r\n        verticalBar: v,\r\n        verticalBox: vb,\r\n        corner: co\r\n      };\r\n      self.scrollBox.bar = {\r\n        v: v,\r\n        h: n\r\n      };\r\n      self.scrollBox.box = {\r\n        v: vb,\r\n        h: nb\r\n      };\r\n      /// calculate page and dom elements\r\n      self.page = Math.max(1, self.visibleRows.length - 3 - self.attributes.pageUpDownOverlap);\r\n      // set canvas drawing related items\r\n      if (!self.isChildGrid) {\r\n        self.canvas.width = self.width * ratio;\r\n        self.canvas.height = self.height * ratio;\r\n        self.ctx.scale(ratio, ratio);\r\n      }\r\n      // resize any open dom elements (input/textarea)\r\n      self.resizeEditInput();\r\n      self.scroll(true);\r\n      if (drawAfterResize) {\r\n        self.draw(true);\r\n      }\r\n      self.dispatchEvent('resize', {});\r\n      return true;\r\n    };\r\n    self.scroll = function (dontDraw) {\r\n      var s = self.getSchema(),\r\n        l = (self.data || []).length,\r\n        ch = self.style.cellHeight;\r\n      // go too far in leaps, then get focused\r\n      self.scrollIndexTop = Math.floor((l * (self.scrollBox.scrollTop / self.scrollBox.scrollHeight)) - 100);\r\n      self.scrollIndexTop = Math.max(self.scrollIndexTop, 0);\r\n      self.scrollPixelTop = self.scrollCache.y[self.scrollIndexTop];\r\n      // sometimes the grid is rendered but the height is zero\r\n      if (self.scrollBox.scrollHeight === 0) {\r\n        self.scrollIndexTop = 0;\r\n      }\r\n      self.scrollPixelTop = 0;\r\n      self.scrollIndexLeft = self.frozenColumn;\r\n      self.scrollPixelLeft = 0;\r\n      while (self.scrollPixelTop < self.scrollBox.scrollTop && self.scrollIndexTop < self.data.length) {\r\n        // start on index +1 since index 0 was used in \"go too far\" section above\r\n        self.scrollIndexTop += 1;\r\n        self.scrollPixelTop = self.scrollCache.y[self.scrollIndexTop];\r\n      }\r\n      while (self.scrollPixelLeft < (self.scrollBox.scrollLeft + 1) && self.scrollIndexLeft < s.length) {\r\n        self.scrollPixelLeft = self.scrollCache.x[self.scrollIndexLeft];\r\n        self.scrollIndexLeft += 1;\r\n      }\r\n      if (s.length > 0) {\r\n        self.scrollIndexLeft = Math.max(self.scrollIndexLeft - 1, 0);\r\n        self.scrollPixelLeft -= self.getColummnWidth(self.orders.columns[self.scrollIndexLeft]);\r\n      }\r\n      if ((self.data || []).length > 0) {\r\n        self.scrollIndexTop = Math.max(self.scrollIndexTop - 1, 0);\r\n        self.scrollPixelTop = Math.max((self.scrollPixelTop\r\n          - (\r\n            self.data[self.scrollIndexTop] ? (self.sizes.rows[self.scrollIndexTop] || ch)\r\n              + (self.sizes.trees[self.scrollIndexTop] || 0)\r\n              : ch\r\n          ) * self.scale), 0);\r\n      }\r\n      self.ellipsisCache = {};\r\n      if (!dontDraw) {\r\n        self.draw(true);\r\n      }\r\n      //TODO: figure out why this has to be delayed for child grids\r\n      //BUG: wheeling event on 3rd level hierarchy fails to move input box\r\n      requestAnimationFrame(self.resizeEditInput);\r\n      self.dispatchEvent('scroll', { top: self.scrollBox.scrollTop, left: self.scrollBox.scrollLeft });\r\n    };\r\n    self.mousemove = function (e, overridePos) {\r\n      if (self.contextMenu || self.input) {\r\n        return;\r\n      }\r\n      self.mouse = overridePos || self.getLayerPos(e);\r\n      var ctrl = ((e.ctrlKey || e.metaKey || self.attributes.persistantSelectionMode) && !self.attributes.singleSelectionMode),\r\n        i,\r\n        s = self.getSchema(),\r\n        dragBounds,\r\n        sBounds,\r\n        x = self.mouse.x,\r\n        y = self.mouse.y,\r\n        o = self.getCellAt(x, y),\r\n        delta,\r\n        ev = { NativeEvent: e, cell: o, x: x, y: y },\r\n        previousCell = self.currentCell;\r\n      clearTimeout(self.scrollTimer);\r\n      if (!self.isInGrid({ x: x, y: y })) {\r\n        self.hasFocus = false;\r\n      }\r\n      if (self.dispatchEvent('mousemove', ev)) {\r\n        return;\r\n      }\r\n      if (o && self.currentCell) {\r\n        self.rowBoundaryCrossed = self.currentCell.rowIndex !== o.rowIndex;\r\n        self.columnBoundaryCrossed = self.currentCell.columnIndex !== o.columnIndex;\r\n        self.cellBoundaryCrossed = self.rowBoundaryCrossed || self.columnBoundaryCrossed;\r\n        ['row', 'column', 'cell'].forEach(function (prefix) {\r\n          if (self[prefix + 'BoundaryCrossed']) {\r\n            ev.cell = previousCell;\r\n            self.dispatchEvent(prefix + 'mouseout', ev);\r\n            ev.cell = o;\r\n            self.dispatchEvent(prefix + 'mouseover', ev);\r\n          }\r\n        });\r\n      }\r\n      self.currentCell = o;\r\n      if (!self.hasFocus) {\r\n        return;\r\n      }\r\n      self.hovers = {};\r\n      if (!self.draggingItem\r\n        && o\r\n        && self.scrollModes.indexOf(o.context) === -1) {\r\n        self.dragItem = o;\r\n        self.dragMode = o.dragContext;\r\n        self.cursor = o.context;\r\n        if (o.context === 'cell') {\r\n          self.cursor = 'default';\r\n          self.hovers = { rowIndex: o.rowIndex, columnIndex: o.columnIndex };\r\n        }\r\n        if ((self.selecting || self.reorderObject)\r\n          && o.context === 'cell') {\r\n          delta = {\r\n            x: Math.abs(self.dragStart.x - x),\r\n            y: Math.abs(self.dragStart.y - y)\r\n          };\r\n          if (self.dragStartObject.columnIndex !== -1 && e.shiftKey) {\r\n            self.dragStartObject = {\r\n              rowIndex: self.activeCell.rowIndex,\r\n              columnIndex: self.activeCell.columnIndex\r\n            };\r\n          }\r\n          dragBounds = {\r\n            top: Math.min(self.dragStartObject.rowIndex, o.rowIndex),\r\n            left: Math.min(self.dragStartObject.columnIndex, o.columnIndex),\r\n            bottom: Math.max(self.dragStartObject.rowIndex, o.rowIndex),\r\n            right: Math.max(self.dragStartObject.columnIndex, o.columnIndex)\r\n          };\r\n          if (self.dragStartObject.columnIndex === -1) {\r\n            sBounds = self.getSelectionBounds();\r\n            dragBounds.left = -1;\r\n            dragBounds.right = s.length - 1;\r\n            dragBounds.top = Math.min(sBounds.top, o.rowIndex);\r\n            dragBounds.bottom = Math.max(sBounds.bottom, o.rowIndex);\r\n          }\r\n          if (self.dragStartObject.rowIndex !== o.rowIndex\r\n            || self.dragStartObject.columnIndex !== o.columnIndex) {\r\n            self.ignoreNextClick = true;\r\n          }\r\n          if (self.cellBoundaryCrossed || (delta.x === 0 && delta.y === 0) || (self.attributes.selectionMode === 'row')) {\r\n            if (((self.attributes.selectionMode === 'row') || self.dragStartObject.columnIndex === -1)\r\n              && self.rowBoundaryCrossed) {\r\n              self.selectRow(o.rowIndex, ctrl, null, true);\r\n            } else if (self.attributes.selectionMode !== 'row') {\r\n              if (!self.dragAddToSelection && o.rowIndex !== undefined) {\r\n                if (self.selections[o.rowIndex] && self.selections[o.rowIndex].indexOf(o.columnIndex) !== -1) {\r\n                  self.selections[o.rowIndex].splice(self.selections[o.rowIndex].indexOf(o.columnIndex), 1);\r\n                }\r\n              } else {\r\n                self.selections[o.rowIndex] = self.selections[o.rowIndex] || [];\r\n                if (self.selections[o.rowIndex].indexOf(o.columnIndex) === -1) {\r\n                  self.selections[o.rowIndex].push(o.columnIndex);\r\n                }\r\n              }\r\n            }\r\n          }\r\n          if ((!self.selectionBounds || (dragBounds.top !== self.selectionBounds.top\r\n            || dragBounds.left !== self.selectionBounds.left\r\n            || dragBounds.bottom !== self.selectionBounds.bottom\r\n            || dragBounds.right !== self.selectionBounds.right)) && !ctrl) {\r\n            self.selections = [];\r\n            sBounds = dragBounds;\r\n            if (self.attributes.selectionMode === 'row') {\r\n              for (i = sBounds.top; i <= sBounds.bottom; i += 1) {\r\n                self.selectRow(i, true, null, true);\r\n              }\r\n            } else if (dragBounds.top !== -1) {\r\n              self.selectArea(sBounds, true);\r\n            }\r\n          }\r\n          self.autoScrollZone(e, x, y, ctrl);\r\n        }\r\n      }\r\n      self.cellBoundaryCrossed = false;\r\n      self.rowBoundaryCrossed = false;\r\n      self.columnBoundaryCrossed = false;\r\n      self.draw(true);\r\n    };\r\n    self.click = function (e, overridePos) {\r\n      var i,\r\n        startingBounds = JSON.stringify(self.getSelectionBounds()),\r\n        ctrl = ((e.ctrlKey || e.metaKey || self.attributes.persistantSelectionMode) && !self.attributes.singleSelectionMode),\r\n        pos = overridePos || self.getLayerPos(e);\r\n      self.currentCell = self.getCellAt(pos.x, pos.y, false, true, false);\r\n\r\n      if (self.currentCell.grid !== undefined) {\r\n        return;\r\n      }\r\n      function checkSelectionChange() {\r\n        var ev, sb = self.getSelectionBounds();\r\n        if (startingBounds === JSON.stringify(sb)) {\r\n          return;\r\n        }\r\n        ev = {\r\n          selections: self.selections,\r\n          selectionBounds: self.getSelectionBounds()\r\n        };\r\n        Object.defineProperty(ev, 'selectedData', {\r\n          get: function () {\r\n            return self.getSelectedData();\r\n          }\r\n        });\r\n        self.dispatchEvent('selectionchanged', ev);\r\n      }\r\n      if (self.input) {\r\n        self.endEdit();\r\n      }\r\n      if (self.ignoreNextClick) {\r\n        self.ignoreNextClick = false;\r\n        return;\r\n      }\r\n      i = self.currentCell;\r\n      if (self.dispatchEvent('click', { NativeEvent: e, cell: self.currentCell })) { return; }\r\n      if (!self.hasFocus) {\r\n        return;\r\n      }\r\n      if (['rowHeaderCell', 'columnHeaderCell'].indexOf(self.currentCell.style) === -1 && !ctrl) {\r\n        self.setActiveCell(i.columnIndex, i.rowIndex);\r\n      }\r\n      if (self.currentCell.context === 'cell') {\r\n        if (self.currentCell.style === 'cornerCell') {\r\n          self.selectAll();\r\n          self.draw();\r\n          checkSelectionChange();\r\n          return;\r\n        }\r\n        if (self.currentCell.style === 'columnHeaderCell') {\r\n          if (self.attributes.columnHeaderClickBehavior === 'sort') {\r\n            if (self.orderBy === i.header.name) {\r\n              self.orderDirection = self.orderDirection === 'asc' ? 'desc' : 'asc';\r\n            } else {\r\n              self.orderDirection = 'asc';\r\n            }\r\n            self.order(i.header.name, self.orderDirection);\r\n            checkSelectionChange();\r\n            return;\r\n          }\r\n          if (self.attributes.columnHeaderClickBehavior === 'select') {\r\n            self.selectColumn(i.header.index, ctrl, e.shiftKey);\r\n            self.draw();\r\n            return;\r\n          }\r\n        }\r\n        self.selections[i.rowIndex] = self.selections[i.rowIndex] || [];\r\n        if (((self.attributes.selectionMode === 'row') || self.currentCell.style === 'rowHeaderCell')) {\r\n          if (self.currentCell.style === 'rowHeaderCell'\r\n            && self.attributes.tree && pos.x > 0\r\n            && pos.x - self.currentCell.x < self.style.treeArrowWidth\r\n            + self.style.treeArrowMarginLeft\r\n            + self.style.treeArrowMarginRight + self.style.treeArrowClickRadius\r\n            && pos.y - self.currentCell.y < self.style.treeArrowHeight\r\n            + self.style.treeArrowMarginTop + self.style.treeArrowClickRadius\r\n            && pos.y > 0) {\r\n            self.toggleTree(i.rowIndex);\r\n            return;\r\n          }\r\n        }\r\n        if (e.shiftKey && !ctrl) {\r\n          self.selectionBounds = self.getSelectionBounds();\r\n          self.selectArea(undefined, false);\r\n        }\r\n      }\r\n      checkSelectionChange();\r\n      self.draw(true);\r\n    };\r\n    self.dragResizeColumn = function (e) {\r\n      var pos, x, y;\r\n      pos = self.getLayerPos(e);\r\n      x = self.resizingStartingWidth + pos.x - self.dragStart.x;\r\n      y = self.resizingStartingHeight + pos.y - self.dragStart.y;\r\n      if (x < self.style.minColumnWidth) {\r\n        x = self.style.minColumnWidth;\r\n      }\r\n      if (y < self.style.minRowHeight) {\r\n        y = self.style.minRowHeight;\r\n      }\r\n      if (self.dispatchEvent('resizecolumn', { x: x, y: y, draggingItem: self.draggingItem })) { return false; }\r\n      if (self.scrollBox.scrollLeft > self.scrollBox.scrollWidth - self.attributes.resizeScrollZone\r\n        && self.dragMode === 'ew-resize') {\r\n        self.resize(true);\r\n        self.scrollBox.scrollLeft += x;\r\n      }\r\n      if (self.dragMode === 'ew-resize') {\r\n        self.sizes.columns[self.draggingItem.header.style === 'rowHeaderCell'\r\n          ? 'cornerCell' : self.draggingItem.sortColumnIndex] = x;\r\n        if (['rowHeaderCell', 'cornerCell'].indexOf(self.draggingItem.header.style) !== -1) {\r\n          self.resize(true);\r\n        }\r\n        self.resizeChildGrids();\r\n        return;\r\n      }\r\n      if (self.dragMode === 'ns-resize') {\r\n        if (self.draggingItem.rowOpen) {\r\n          self.sizes.trees[self.draggingItem.rowIndex] = y;\r\n        } else if (self.attributes.globalRowResize) {\r\n          self.style.cellHeight = y;\r\n        } else {\r\n          self.sizes.rows[self.draggingItem.rowIndex] = y;\r\n        }\r\n        self.dispatchEvent('resizerow', { row: y });\r\n        self.resizeChildGrids();\r\n        return;\r\n      }\r\n      self.ellipsisCache = {};\r\n    };\r\n    self.stopDragResize = function () {\r\n      self.resize();\r\n      document.body.removeEventListener('mousemove', self.dragResizeColumn, false);\r\n      document.body.removeEventListener('mouseup', self.stopDragResize, false);\r\n      self.setStorageData();\r\n      self.draw(true);\r\n      self.ignoreNextClick = true;\r\n    };\r\n    self.scrollGrid = function (e) {\r\n      var pos = self.getLayerPos(e);\r\n      if (self.attributes.scrollPointerLock && self.pointerLockPosition\r\n        && ['horizontal-scroll-box', 'vertical-scroll-box'].indexOf(self.scrollStartMode) !== -1) {\r\n        self.pointerLockPosition.x += e.movementX;\r\n        self.pointerLockPosition.y += e.movementY;\r\n        self.pointerLockPosition.x = Math.min(self.width - self.style.scrollBarWidth, Math.max(0, self.pointerLockPosition.x));\r\n        self.pointerLockPosition.y = Math.min(self.height - self.style.scrollBarWidth, Math.max(0, self.pointerLockPosition.y));\r\n        pos = self.pointerLockPosition;\r\n      }\r\n      self.scrollMode = self.getCellAt(pos.x, pos.y).context;\r\n      if (self.scrollMode === 'horizontal-scroll-box' && self.scrollStartMode !== 'horizontal-scroll-box') {\r\n        self.scrollStartMode = 'horizontal-scroll-box';\r\n        self.dragStart = pos;\r\n        self.scrollStart.left = self.scrollBox.scrollLeft;\r\n        clearTimeout(self.scrollTimer);\r\n        return;\r\n      }\r\n      if (self.scrollMode === 'vertical-scroll-box' && self.scrollStartMode !== 'vertical-scroll-box') {\r\n        self.scrollStartMode = 'vertical-scroll-box';\r\n        self.dragStart = pos;\r\n        self.scrollStart.top = self.scrollBox.scrollTop;\r\n        clearTimeout(self.scrollTimer);\r\n        return;\r\n      }\r\n      if (self.scrollStartMode === 'vertical-scroll-box'\r\n        && self.scrollMode !== 'vertical-scroll-box') {\r\n        self.scrollMode = 'vertical-scroll-box';\r\n      }\r\n      if (self.scrollStartMode === 'horizontal-scroll-box'\r\n        && self.scrollMode !== 'horizontal-scroll-box') {\r\n        self.scrollMode = 'horizontal-scroll-box';\r\n      }\r\n      clearTimeout(self.scrollTimer);\r\n      if (self.scrollModes.indexOf(self.scrollMode) === -1) {\r\n        return;\r\n      }\r\n      if (self.scrollMode === 'vertical-scroll-box') {\r\n        self.scrollBox.scrollTop = self.scrollStart.top + ((pos.y - self.dragStart.y)\r\n          / self.scrollBox.heightBoxRatio);\r\n      } else if (self.scrollMode === 'vertical-scroll-top') {\r\n        self.scrollBox.scrollTop -= (self.page * self.style.cellHeight);\r\n        self.scrollTimer = setTimeout(self.scrollGrid, self.attributes.scrollRepeatRate, e);\r\n      } else if (self.scrollMode === 'vertical-scroll-bottom') {\r\n        self.scrollBox.scrollTop += (self.page * self.style.cellHeight);\r\n        self.scrollTimer = setTimeout(self.scrollGrid, self.attributes.scrollRepeatRate, e);\r\n      }\r\n      if (self.scrollMode === 'horizontal-scroll-box') {\r\n        self.scrollBox.scrollLeft = self.scrollStart.left + ((pos.x - self.dragStart.x)\r\n          / self.scrollBox.widthBoxRatio);\r\n      } else if (self.scrollMode === 'horizontal-scroll-right') {\r\n        self.scrollBox.scrollLeft += self.attributes.selectionScrollIncrement;\r\n        self.scrollTimer = setTimeout(self.scrollGrid, self.attributes.scrollRepeatRate, e);\r\n      } else if (self.scrollMode === 'horizontal-scroll-left') {\r\n        self.scrollBox.scrollLeft -= self.attributes.selectionScrollIncrement;\r\n        self.scrollTimer = setTimeout(self.scrollGrid, self.attributes.scrollRepeatRate, e);\r\n      }\r\n    };\r\n    self.stopScrollGrid = function () {\r\n      clearTimeout(self.scrollTimer);\r\n      if (document.exitPointerLock) {\r\n        document.exitPointerLock();\r\n      }\r\n      document.removeEventListener('mousemove', self.scrollGrid, false);\r\n    };\r\n    self.dragReorder = function (e) {\r\n      var pos, x, y,\r\n        columReorder = self.dragMode === 'column-reorder',\r\n        rowReorder = self.dragMode === 'row-reorder';\r\n      pos = self.getLayerPos(e);\r\n      x = pos.x - self.dragStart.x;\r\n      y = pos.y - self.dragStart.y;\r\n      if (!self.attributes.allowColumnReordering && columReorder) {\r\n        return;\r\n      }\r\n      if (!self.attributes.allowRowReordering && rowReorder) {\r\n        return;\r\n      }\r\n      if (self.dispatchEvent('reordering', {\r\n        NativeEvent: e,\r\n        source: self.dragStartObject,\r\n        target: self.currentCell,\r\n        dragMode: self.dragMode\r\n      })) {\r\n        return;\r\n      }\r\n      if (Math.abs(x) > self.attributes.reorderDeadZone || Math.abs(y) > self.attributes.reorderDeadZone) {\r\n        self.reorderObject = self.draggingItem;\r\n        self.reorderTarget = self.currentCell;\r\n        self.reorderObject.dragOffset = {\r\n          x: x,\r\n          y: y\r\n        };\r\n        self.autoScrollZone(e, columReorder ? pos.x : -1, rowReorder ? pos.y : -1, false);\r\n      }\r\n    };\r\n    self.stopDragReorder = function (e) {\r\n      var oIndex,\r\n        tIndex,\r\n        cr = {\r\n          'row-reorder': self.orders.rows,\r\n          'column-reorder': self.orders.columns\r\n        },\r\n        i = {\r\n          'row-reorder': 'rowIndex',\r\n          'column-reorder': 'sortColumnIndex'\r\n        }[self.dragMode];\r\n      document.body.removeEventListener('mousemove', self.dragReorder, false);\r\n      document.body.removeEventListener('mouseup', self.stopDragReorder, false);\r\n      if (self.reorderObject\r\n        && self.reorderTarget\r\n        && ((self.dragMode === 'column-reorder' && self.reorderTarget.sortColumnIndex > -1\r\n          && self.reorderTarget.sortColumnIndex < self.getSchema().length)\r\n          || (self.dragMode === 'row-reorder' && self.reorderTarget.rowIndex > -1\r\n            && self.reorderTarget.rowIndex < self.data.length))\r\n        && self.reorderObject[i] !== self.reorderTarget[i]\r\n        && !self.dispatchEvent('reorder', {\r\n          NativeEvent: e,\r\n          source: self.reorderObject,\r\n          target: self.reorderTarget,\r\n          dragMode: self.dragMode\r\n        })) {\r\n        self.ignoreNextClick = true;\r\n        oIndex = cr[self.dragMode].indexOf(self.reorderObject[i]);\r\n        tIndex = cr[self.dragMode].indexOf(self.reorderTarget[i]);\r\n        cr[self.dragMode].splice(oIndex, 1);\r\n        cr[self.dragMode].splice(tIndex, 0, self.reorderObject[i]);\r\n        if (self.dragMode === 'column-reorder') {\r\n          self.orders.columns = cr[self.dragMode];\r\n        } else {\r\n          self.orders.rows = cr[self.dragMode];\r\n        }\r\n        self.resize();\r\n        self.setStorageData();\r\n      }\r\n      self.reorderObject = undefined;\r\n      self.reorderTarget = undefined;\r\n      self.draw(true);\r\n    };\r\n    self.dragMove = function (e) {\r\n      if (self.dispatchEvent('moving', { NativeEvent: e, cell: self.currentCell })) { return; }\r\n      var pos = self.getLayerPos(e);\r\n      self.moveOffset = {\r\n        x: self.currentCell.columnIndex - self.dragStartObject.columnIndex,\r\n        y: self.currentCell.rowIndex - self.dragStartObject.rowIndex\r\n      };\r\n      if (Math.abs(pos.x) > self.attributes.reorderDeadZone || Math.abs(pos.y) > self.attributes.reorderDeadZone) {\r\n        setTimeout(function () {\r\n          self.autoScrollZone(e, pos.x, pos.y, false);\r\n        }, 1);\r\n      }\r\n    };\r\n    self.stopDragMove = function (e) {\r\n      document.body.removeEventListener('mousemove', self.dragMove, false);\r\n      document.body.removeEventListener('mouseup', self.stopDragMove, false);\r\n      var b = self.getSelectionBounds();\r\n      if (self.dispatchEvent('endmove', { NativeEvent: e, cell: self.currentCell })) {\r\n        self.movingSelection = undefined;\r\n        self.moveOffset = undefined;\r\n        self.draw(true);\r\n        return;\r\n      }\r\n      if (self.moveOffset) {\r\n        self.moveTo(self.movingSelection, b.left + self.moveOffset.x, b.top + self.moveOffset.y);\r\n        self.moveSelection(self.moveOffset.x, self.moveOffset.y);\r\n      }\r\n      self.movingSelection = undefined;\r\n      self.moveOffset = undefined;\r\n      self.draw(true);\r\n    };\r\n    self.freezeMove = function (e) {\r\n      if (self.dispatchEvent('freezemoving', { NativeEvent: e, cell: self.currentCell })) { return; }\r\n      var pos = self.getLayerPos(e);\r\n      self.ignoreNextClick = true;\r\n      self.freezeMarkerPosition = pos;\r\n      if (self.currentCell && self.currentCell.rowIndex !== undefined && self.dragMode === 'frozen-row-marker') {\r\n        self.scrollBox.scrollTop = 0;\r\n        self.frozenRow = self.currentCell.rowIndex + 1;\r\n      }\r\n      if (self.currentCell && self.currentCell.columnIndex !== undefined && self.dragMode === 'frozen-column-marker') {\r\n        self.scrollBox.scrollLeft = 0;\r\n        self.frozenColumn = self.currentCell.columnIndex + 1;\r\n      }\r\n      if (Math.abs(pos.x) > self.attributes.reorderDeadZone || Math.abs(pos.y) > self.attributes.reorderDeadZone) {\r\n        setTimeout(function () {\r\n          self.autoScrollZone(e, pos.x, pos.y, false);\r\n        }, 1);\r\n      }\r\n    };\r\n    self.stopFreezeMove = function (e) {\r\n      document.body.removeEventListener('mousemove', self.freezeMove, false);\r\n      document.body.removeEventListener('mouseup', self.stopFreezeMove, false);\r\n      self.freezeMarkerPosition = undefined;\r\n      if (self.dispatchEvent('endfreezemove', { NativeEvent: e, cell: self.currentCell })) {\r\n        self.frozenRow = self.startFreezeMove.x;\r\n        self.frozenColumn = self.startFreezeMove.y;\r\n        self.draw(true);\r\n        return;\r\n      }\r\n      self.draw(true);\r\n    };\r\n    self.mousedown = function (e, overridePos) {\r\n      self.lastMouseDownTarget = e.target;\r\n      if (self.dispatchEvent('mousedown', { NativeEvent: e, cell: self.currentCell })) { return; }\r\n      if (!self.hasFocus) {\r\n        return;\r\n      }\r\n      if (e.button === 2 || self.input) { return; }\r\n      var ctrl = (e.ctrlKey || e.metaKey),\r\n        move = /-move/.test(self.dragMode),\r\n        freeze = /frozen-row-marker|frozen-column-marker/.test(self.dragMode),\r\n        resize = /-resize/.test(self.dragMode);\r\n      self.dragStart = overridePos || self.getLayerPos(e);\r\n      self.scrollStart = {\r\n        left: self.scrollBox.scrollLeft,\r\n        top: self.scrollBox.scrollTop\r\n      };\r\n      self.dragStartObject = self.getCellAt(self.dragStart.x, self.dragStart.y);\r\n      self.dragAddToSelection = !self.dragStartObject.selected;\r\n      if (!ctrl && !e.shiftKey && !/(vertical|horizontal)-scroll-(bar|box)/\r\n        .test(self.dragStartObject.context)\r\n        && self.currentCell\r\n        && !self.currentCell.isColumnHeader\r\n        && !move\r\n        && !freeze\r\n        && !resize) {\r\n        self.selections = [];\r\n      }\r\n      if (self.dragStartObject.isGrid) {\r\n        return;\r\n      }\r\n      if (self.scrollModes.indexOf(self.dragStartObject.context) !== -1) {\r\n        self.scrollMode = self.dragStartObject.context;\r\n        self.scrollStartMode = self.dragStartObject.context;\r\n        self.scrollGrid(e);\r\n        if (self.attributes.scrollPointerLock\r\n          && ['horizontal-scroll-box', 'vertical-scroll-box'].indexOf(self.scrollStartMode) !== -1) {\r\n          self.pointerLockPosition = {\r\n            x: self.dragStart.x,\r\n            y: self.dragStart.y\r\n          };\r\n          self.canvas.requestPointerLock();\r\n        }\r\n        document.addEventListener('mousemove', self.scrollGrid, false);\r\n        document.addEventListener('mouseup', self.stopScrollGrid, false);\r\n        self.ignoreNextClick = true;\r\n        return;\r\n      }\r\n      if (self.dragMode === 'cell') {\r\n        self.selecting = true;\r\n        if ((self.attributes.selectionMode === 'row' || self.dragStartObject.columnIndex === -1)\r\n          && self.dragStartObject.rowIndex > -1) {\r\n          self.selectRow(self.dragStartObject.rowIndex, ctrl, null);\r\n        } else if (self.attributes.selectionMode !== 'row') {\r\n          self.mousemove(e);\r\n        }\r\n        return;\r\n      }\r\n      if (move) {\r\n        self.draggingItem = self.dragItem;\r\n        self.movingSelection = self.selections.concat([]);\r\n        self.dragging = self.dragStartObject;\r\n        if (self.dispatchEvent('beginmove', { NativeEvent: e, cell: self.currentCell })) { return; }\r\n        document.body.addEventListener('mousemove', self.dragMove, false);\r\n        document.body.addEventListener('mouseup', self.stopDragMove, false);\r\n        return self.mousemove(e);\r\n      }\r\n      if (freeze) {\r\n        self.draggingItem = self.dragItem;\r\n        self.startFreezeMove = {\r\n          x: self.frozenRow,\r\n          y: self.frozenColumn\r\n        };\r\n        if (self.dispatchEvent('beginfreezemove', { NativeEvent: e })) { return; }\r\n        document.body.addEventListener('mousemove', self.freezeMove, false);\r\n        document.body.addEventListener('mouseup', self.stopFreezeMove, false);\r\n        return self.mousemove(e);\r\n      }\r\n      if (resize) {\r\n        self.draggingItem = self.dragItem;\r\n        if (self.draggingItem.rowOpen) {\r\n          self.resizingStartingHeight = self.sizes.trees[self.draggingItem.rowIndex];\r\n        } else {\r\n          self.resizingStartingHeight = self.sizes.rows[self.draggingItem.rowIndex] || self.style.cellHeight;\r\n        }\r\n        self.resizingStartingWidth = self.sizes.columns[self.draggingItem.header.style === 'rowHeaderCell'\r\n          ? 'cornerCell' : self.draggingItem.sortColumnIndex] || self.draggingItem.width;\r\n        document.body.addEventListener('mousemove', self.dragResizeColumn, false);\r\n        document.body.addEventListener('mouseup', self.stopDragResize, false);\r\n        return;\r\n      }\r\n      if (['row-reorder', 'column-reorder'].indexOf(self.dragMode) !== -1) {\r\n        self.draggingItem = self.dragStartObject;\r\n        document.body.addEventListener('mousemove', self.dragReorder, false);\r\n        document.body.addEventListener('mouseup', self.stopDragReorder, false);\r\n        return;\r\n      }\r\n    };\r\n    self.mouseup = function (e) {\r\n      clearTimeout(self.scrollTimer);\r\n      self.cellBoundaryCrossed = true;\r\n      self.rowBoundaryCrossed = true;\r\n      self.columnBoundaryCrossed = true;\r\n      self.selecting = undefined;\r\n      self.draggingItem = undefined;\r\n      self.dragStartObject = undefined;\r\n      if (self.dispatchEvent('mouseup', { NativeEvent: e, cell: self.currentCell })) { return; }\r\n      if (!self.hasFocus && e.target !== self.canvas) {\r\n        return;\r\n      }\r\n      if (self.currentCell && self.currentCell.grid !== undefined) {\r\n        return;\r\n      }\r\n      if (self.contextMenu || self.input) { return; }\r\n      if (self.dragStart && self.isInGrid(self.dragStart)) {\r\n        self.controlInput.focus();\r\n      }\r\n      e.preventDefault();\r\n    };\r\n    // gets the horizontal adjacent cells as well as first/last based on column visibility\r\n    self.getAdjacentCells = function () {\r\n      var x,\r\n        i,\r\n        s = self.getSchema(),\r\n        o = {};\r\n      for (x = 0; x < s.length; x += 1) {\r\n        i = self.orders.columns[x];\r\n        if (!s[i].hidden) {\r\n          if (o.first === undefined) {\r\n            o.first = x;\r\n            o.left = x;\r\n          }\r\n          o.last = x;\r\n          if (x > self.activeCell.columnIndex && o.right === undefined) {\r\n            o.right = x;\r\n          }\r\n          if (x < self.activeCell.columnIndex) {\r\n            o.left = x;\r\n          }\r\n        }\r\n      }\r\n      if (o.right === undefined) {\r\n        o.right = o.last;\r\n      }\r\n      return o;\r\n    };\r\n    self.keydown = function (e) {\r\n      var i,\r\n        ev,\r\n        adjacentCells = self.getAdjacentCells(),\r\n        x = self.activeCell.columnIndex,\r\n        y = self.activeCell.rowIndex,\r\n        ctrl = (e.ctrlKey || e.metaKey),\r\n        last = self.data.length - 1,\r\n        s = self.getSchema(),\r\n        cols = s.length - 1;\r\n      if (self.dispatchEvent('keydown', { NativeEvent: e, cell: self.currentCell })) { return; }\r\n      if (!self.hasFocus) {\r\n        return;\r\n      }\r\n      if (self.attributes.showNewRow) {\r\n        last += 1;\r\n      }\r\n      if (e.keyCode === 9) {\r\n        e.preventDefault();\r\n      }\r\n      // esc\r\n      if (e.keyCode === 27) {\r\n        self.selections = [];\r\n        self.draw(true);\r\n        // ctrl + a\r\n      } else if (ctrl && e.keyCode === 65) {\r\n        self.selectAll();\r\n        //ArrowDown\r\n      } else if (e.keyCode === 40) {\r\n        y += 1;\r\n        //ArrowUp\r\n      } else if (e.keyCode === 38) {\r\n        y -= 1;\r\n        //ArrowLeft Tab\r\n      } else if (e.keyCode === 37 || (e.shiftKey && e.keyCode === 9)) {\r\n        x = adjacentCells.left;\r\n        //ArrowRight Tab\r\n      } else if (e.keyCode === 39 || (!e.shiftKey && e.keyCode === 9)) {\r\n        x = adjacentCells.right;\r\n        //PageUp\r\n      } else if (e.keyCode === 33) {\r\n        y -= self.page;\r\n        e.preventDefault();\r\n        //PageDown\r\n      } else if (e.keyCode === 34) {\r\n        y += self.page;\r\n        e.preventDefault();\r\n        //Home ArrowUp\r\n      } else if (e.keyCode === 36 || (ctrl && e.keyCode === 38)) {\r\n        y = 0;\r\n        //End ArrowDown\r\n      } else if (e.keyCode === 35 || (ctrl && e.keyCode === 40)) {\r\n        y = self.data.length - 1;\r\n        //ArrowRight\r\n      } else if (ctrl && e.keyCode === 39) {\r\n        x = adjacentCells.last;\r\n        //ArrowLeft\r\n      } else if (ctrl && e.keyCode === 37) {\r\n        x = adjacentCells.first;\r\n      }\r\n      //Enter\r\n      if (e.keyCode === 13) {\r\n        return self.beginEditAt(x, y, e);\r\n      }\r\n      //Space\r\n      if (e.keyCode === 32) {\r\n        self.selections = [];\r\n        self.selections[Math.max(y, 0)] = [];\r\n        self.selections[Math.max(y, 0)].push(x);\r\n        self.selectionBounds = self.getSelectionBounds();\r\n        if (self.attributes.selectionMode === 'row') {\r\n          for (i = self.selectionBounds.top; i <= self.selectionBounds.bottom; i += 1) {\r\n            self.selectRow(i, ctrl, null, true);\r\n          }\r\n        } else {\r\n          self.selectArea(undefined, ctrl);\r\n        }\r\n        e.preventDefault();\r\n        self.draw(true);\r\n        return;\r\n      }\r\n      if (x < 0 || Number.isNaN(x)) {\r\n        x = adjacentCells.first;\r\n      }\r\n      if (y > last) {\r\n        y = last;\r\n      }\r\n      if (y < 0 || Number.isNaN(y)) {\r\n        y = 0;\r\n      }\r\n      if (x > cols) {\r\n        x = adjacentCells.last;\r\n      }\r\n      // TODO - most likley some column order related bugs in key based selection\r\n      // Arrows\r\n      if (e.shiftKey && [37, 38, 39, 40].indexOf(e.keyCode) !== -1) {\r\n        self.selections[Math.max(y, 0)] = self.selections[Math.max(y, 0)] || [];\r\n        self.selections[Math.max(y, 0)].push(x);\r\n        self.selectionBounds = self.getSelectionBounds();\r\n        self.selectArea(undefined, ctrl);\r\n        self.draw(true);\r\n      }\r\n      if (x !== self.activeCell.columnIndex || y !== self.activeCell.rowIndex) {\r\n        self.scrollIntoView(\r\n          x !== self.activeCell.columnIndex ? x : undefined,\r\n          y !== self.activeCell.rowIndex && !Number.isNaN(y) ? y : undefined\r\n        );\r\n\r\n        self.setActiveCell(x, y);\r\n        if (!e.shiftKey && self.attributes.selectionFollowsActiveCell) {\r\n          if (!ctrl) {\r\n            self.selections = [];\r\n          }\r\n          self.selections[y] = self.selections[y] || [];\r\n          self.selections[y].push(x);\r\n          ev = {\r\n            selectedData: self.getSelectedData(),\r\n            selections: self.selections,\r\n            selectionBounds: self.getSelectionBounds()\r\n          };\r\n          Object.defineProperty(ev, 'selectedData', {\r\n            get: function () {\r\n              return self.getSelectedData();\r\n            }\r\n          });\r\n          self.dispatchEvent('selectionchanged', ev);\r\n        }\r\n        self.draw(true);\r\n      }\r\n    };\r\n    self.keyup = function (e) {\r\n      if (self.dispatchEvent('keyup', { NativeEvent: e, cell: self.currentCell })) { return; }\r\n      if (!self.hasFocus) {\r\n        return;\r\n      }\r\n    };\r\n    self.keypress = function (e) {\r\n      if (!self.hasFocus) {\r\n        return;\r\n      }\r\n      if (self.dispatchEvent('keypress', { NativeEvent: e, cell: self.currentCell })) { return; }\r\n    };\r\n    self.dblclick = function (e) {\r\n      if (self.dispatchEvent('dblclick', { NativeEvent: e, cell: self.currentCell })) { return; }\r\n      if (!self.hasFocus) {\r\n        return;\r\n      }\r\n      if (self.currentCell.context === 'ew-resize'\r\n        && self.currentCell.style === 'columnHeaderCell') {\r\n        self.fitColumnToValues(self.currentCell.header.name);\r\n      } else if (self.currentCell.context === 'ew-resize'\r\n        && self.currentCell.style === 'cornerCell') {\r\n        self.autosize();\r\n      } else if (['cell', 'activeCell'].indexOf(self.currentCell.style) !== -1) {\r\n        self.beginEditAt(self.currentCell.columnIndex, self.currentCell.rowIndex);\r\n      }\r\n    };\r\n    self.scrollWheel = function (e) {\r\n      var l,\r\n        t,\r\n        ev = e,\r\n        deltaX = e.deltaX === undefined ? e.NativeEvent.deltaX : e.deltaX,\r\n        deltaY = e.deltaY === undefined ? e.NativeEvent.deltaY : e.deltaY,\r\n        deltaMode = e.deltaMode === undefined ? e.NativeEvent.deltaMode : e.deltaMode;\r\n      if (wheeling) {\r\n        return;\r\n      }\r\n      if (self.dispatchEvent('wheel', { NativeEvent: e })) {\r\n        return;\r\n      }\r\n      var e = e.NativeEvent || e;\r\n      self.touchHaltAnimation = true;\r\n      l = self.scrollBox.scrollLeft;\r\n      t = self.scrollBox.scrollTop;\r\n      if (self.hasFocus) {\r\n        //BUG Issue 42: https://github.com/TonyGermaneri/canvas-datagrid/issues/42\r\n        //https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\r\n        if (deltaMode === 1) {\r\n          // line mode = 17 pixels per line\r\n          deltaY = deltaY * 17;\r\n        }\r\n        if ((self.scrollBox.scrollTop < self.scrollBox.scrollHeight && deltaY > 0)\r\n          || (self.scrollBox.scrollLeft < self.scrollBox.scrollWidth && deltaX > 0)\r\n          || (self.scrollBox.scrollTop > 0 && deltaY < 0)\r\n          || (self.scrollBox.scrollLeft > 0 && deltaX < 0)) {\r\n          ev.preventDefault(e);\r\n        }\r\n        wheeling = setTimeout(function () {\r\n          wheeling = undefined;\r\n          self.scrollBox.scrollTo(deltaX + l, deltaY + t);\r\n        }, 1);\r\n      }\r\n    };\r\n    self.pasteItem = function (clipData, x, y, mimeType) {\r\n      var l, s = self.getVisibleSchema(), yi = y - 1, sel = [];\r\n      function normalizeRowData(importingRow, existingRow, offsetX, schema, mimeType, rowIndex) {\r\n        var r = existingRow;\r\n        if (!Array.isArray(importingRow) && importingRow !== null && typeof importingRow === 'object') {\r\n          importingRow = Object.keys(importingRow).map(function (colKey) {\r\n            return importingRow[colKey];\r\n          });\r\n        }\r\n        if (/^text\\/html/.test(mimeType)) {\r\n          importingRow = importingRow.substring(4, importingRow.length - 5).split('</td><td>');\r\n        }\r\n        if (typeof importingRow === 'string') {\r\n          importingRow = [importingRow];\r\n        }\r\n        sel[rowIndex] = [];\r\n        importingRow.forEach(function (cellData, colIndex) {\r\n          var cName = schema[colIndex + offsetX].name;\r\n          if (importingRow[colIndex] === undefined || importingRow[colIndex] === null) {\r\n            r[cName] = existingRow[cName];\r\n            return;\r\n          }\r\n          sel[rowIndex].push(colIndex + offsetX);\r\n          r[cName] = importingRow[colIndex];\r\n        });\r\n        return r;\r\n      }\r\n      if (/^text\\/html/.test(mimeType)) {\r\n        if (!/^(<meta[^>]+>)?<table>/.test(clipData.substring(0, 29))) {\r\n          console.warn('Unrecognized HTML format.  HTML must be a simple table, e.g.: <table><tr><td>data</td></tr></table>.  Data with the mime type text/html not in this format will not be imported as row data.');\r\n          return;\r\n        }\r\n        // strip table beginning and ending off, then split at rows\r\n        clipData = clipData.substring(clipData.indexOf('<table><tr>') + 11, clipData.length - 13).split('</tr><tr>');\r\n        // ditch any headers on the table\r\n        clipData = clipData.filter(function (row) {\r\n          return !/^<th>|^<thead>/.test(row);\r\n        });\r\n      } else {\r\n        clipData = clipData.split('\\n');\r\n      }\r\n      l = clipData.length;\r\n      clipData.forEach(function (rowData) {\r\n        yi += 1;\r\n        var i = self.orders.rows[yi];\r\n        self.data[i] = normalizeRowData(rowData, self.data[i], x, s, mimeType, i);\r\n      });\r\n      self.selections = sel;\r\n      return l;\r\n    };\r\n    self.getNextVisibleColumnIndex = function (visibleColumnIndex) {\r\n      var x, s = self.getVisibleSchema();\r\n      for (x = 0; x < s.length; x += 1) {\r\n        if (s[x].columnIndex === visibleColumnIndex) {\r\n          return s[x + 1].columnIndex;\r\n        }\r\n      }\r\n      return -1;\r\n    };\r\n    self.getVisibleColumnIndexOf = function (columnIndex) {\r\n      var x, s = self.getVisibleSchema();\r\n      for (x = 0; x < s.length; x += 1) {\r\n        if (s[x].columnIndex === columnIndex) {\r\n          return x;\r\n        }\r\n      }\r\n      return -1;\r\n    };\r\n    self.paste = function (e) {\r\n      var d;\r\n      function getItem(dti) {\r\n        var type = dti.type;\r\n        dti.getAsString(function (s) {\r\n          self.pasteItem(s, self.getVisibleColumnIndexOf(self.activeCell.columnIndex), self.activeCell.rowIndex, type);\r\n          self.draw();\r\n        });\r\n      }\r\n      d = Array.prototype.filter.call(e.clipboardData.items, function (dti) {\r\n        return dti.type === 'text/html';\r\n      })[0] || Array.prototype.filter(function (dti) {\r\n        return dti.type === 'text/csv';\r\n      })[0] || Array.prototype.filter(function (dti) {\r\n        return dti.type === 'text/plain';\r\n      })[0];\r\n      if (!d) {\r\n        console.warn('Cannot find supported clipboard data type.  Supported types are text/html, text/csv, text/plain.');\r\n        return;\r\n      }\r\n      getItem(d);\r\n    };\r\n    self.cut = function (e) {\r\n      self.copy(e);\r\n      self.forEachSelectedCell(function (data, index, colName) {\r\n        data[index][colName] = '';\r\n      });\r\n    };\r\n    self.copy = function (e) {\r\n      if (self.dispatchEvent('copy', { NativeEvent: e })) { return; }\r\n      if (!self.hasFocus || !e.clipboardData) { return; }\r\n      var t,\r\n        d,\r\n        data = (self.data || []),\r\n        tableRows = [],\r\n        textRows = [],\r\n        outputHeaders = {},\r\n        outputHeaderKeys,\r\n        sData = self.getSelectedData(),\r\n        s = self.getSchema();\r\n      function htmlSafe(v) {\r\n        return v.replace(/</g, '&lt;').replace(/>/g, '&gt;');\r\n      }\r\n      function fCopyCell(v) {\r\n        v = v === null || v === undefined ? '' : v;\r\n        return '<td>' + (typeof v === 'string' ? htmlSafe(v) : v) + '</td>';\r\n      }\r\n      function addHeaders(headers, useHtml) {\r\n        if (!s.length || headers.length < 2) { return ''; }\r\n        var h = [];\r\n        if (useHtml) {\r\n          h.push('<tr>');\r\n        }\r\n        s.forEach(function (column, columnIndex) {\r\n          // intentional redefinition of column\r\n          column = s[self.orders.columns[columnIndex]];\r\n          if (!column.hidden && headers.indexOf(column.name) !== -1) {\r\n            var ev = { NativeEvent: e, column: column };\r\n            if (self.dispatchEvent('copyonschema', ev)) {\r\n              column = ev.column;\r\n            }\r\n\r\n            var hVal = (column.name || column.title) || '';\r\n            if (useHtml) {\r\n              h.push('<th>' + htmlSafe(hVal) + '</th>');\r\n            } else {\r\n              h.push('\"' + hVal.replace(/\"/g, '\"\"') + '\"');\r\n            }\r\n          }\r\n        });\r\n        h.push(useHtml ? '</tr>' : '\\n');\r\n        return h.join(useHtml ? '' : ',');\r\n      }\r\n      function addCellValue(val, trRow, textRow, column) {\r\n        // escape strings\r\n        if (val !== null\r\n          && val !== false\r\n          && val !== undefined\r\n          && val.replace) {\r\n          trRow.push(fCopyCell(val));\r\n          textRow.push('\"' + val.replace(/\"/g, '\"\"') + '\"');\r\n          return;\r\n        }\r\n        if (val !== undefined) {\r\n          textRow.push(val);\r\n          trRow.push(fCopyCell(val));\r\n          return;\r\n        }\r\n        // issue #66\r\n        textRow.push('');\r\n        trRow.push('<td>&nbsp;</td>');\r\n      }\r\n      if (sData.length > 0) {\r\n        sData.forEach(function (row) {\r\n          var rowKeys = Object.keys(row);\r\n          if (row) {\r\n            var trRow = [],\r\n              textRow = [],\r\n              sSorted = [];\r\n            // HACK: https://github.com/TonyGermaneri/canvas-datagrid/issues/181\r\n            // I can't use sort here or O(1), so hacks\r\n            s.forEach(function (column, columnIndex) {\r\n              sSorted.push(s[self.orders.columns[columnIndex]]);\r\n            });\r\n            sSorted.forEach(function (column, columnIndex) {\r\n              if (rowKeys.indexOf(column.name) !== -1) {\r\n                outputHeaders[column.name] = true;\r\n                // escape strings\r\n                addCellValue(row[column.name], trRow, textRow, column);\r\n              }\r\n            });\r\n            tableRows.push(trRow.join(''));\r\n            textRows.push(textRow.join(','));\r\n          }\r\n        });\r\n        outputHeaderKeys = Object.keys(outputHeaders);\r\n        t = addHeaders(outputHeaderKeys) + textRows.join('\\n');\r\n        d = '<table>' + addHeaders(outputHeaderKeys, true) + '<tr>' + tableRows.join('</tr><tr>') + '</tr></table>';\r\n        if (outputHeaderKeys.length === 1) {\r\n          // if there was only one cell selected, remove the quotes from the string\r\n          t = t.substring(1, t.length - 1);\r\n        }\r\n        e.clipboardData.setData('text/html', d);\r\n        e.clipboardData.setData('text/plain', t);\r\n        e.clipboardData.setData('text/csv', t);\r\n        e.clipboardData.setData('application/json', JSON.stringify(sData));\r\n        e.preventDefault();\r\n      }\r\n    };\r\n    return;\r\n  };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/events.js\n// module id = 4\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true, plusplus: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine([], function () {\r\n    'use strict';\r\n    return function (self) {\r\n        var touchTimerMs = 50,\r\n            debounceTouchMove,\r\n            touchMoving,\r\n            touchScrollTimeout;\r\n        self.scrollAnimation = {};\r\n        self.touchDelta = {};\r\n        self.touchAnimateTo = {};\r\n        self.animationFrames = 0;\r\n        self.getTouchPos = function (e, touchIndex) {\r\n            var t = touchIndex ? e.touches[touchIndex] : e.touches[0],\r\n                rect = self.canvas.getBoundingClientRect(),\r\n                pos;\r\n            if (!t) { return; }\r\n            pos = {\r\n                x: t.clientX - rect.left,\r\n                y: t.clientY - rect.top\r\n            };\r\n            if (self.isChildGrid) {\r\n                pos.x -= self.canvasOffsetLeft;\r\n                pos.y -= self.canvasOffsetTop;\r\n            }\r\n            return {\r\n                x: pos.x,\r\n                y: pos.y,\r\n                rect: rect\r\n            };\r\n        };\r\n        // shamelessly stolen from from https://gist.github.com/gre/1650294\r\n        self.easingFunctions = {\r\n            linear: function (t) { return t; },\r\n            easeInQuad: function (t) { return t * t; },\r\n            easeOutQuad: function (t) { return t * (2 - t); },\r\n            easeInOutQuad: function (t) { return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t; },\r\n            easeInCubic: function (t) { return t * t * t; },\r\n            easeOutCubic: function (t) { return (--t) * t * t + 1; },\r\n            easeInOutCubic: function (t) { return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1; },\r\n            easeInQuart: function (t) { return t * t * t * t; },\r\n            easeOutQuart: function (t) { return 1 - (--t) * t * t * t; },\r\n            easeInOutQuart: function (t) { return t < 0.5 ? 8 * t  * t  * t * t : 1 - 8 * (--t) * t * t * t; },\r\n            easeInQuint: function (t) { return t * t * t * t * t; },\r\n            easeOutQuint: function (t) { return 1 + (--t) * t *  t * t * t; },\r\n            easeInOutQuint: function (t) { return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t; }\r\n        };\r\n        self.easing = function (t, b, c, d) {\r\n            return c * self.easingFunctions[self.attributes.touchEasingMethod](t / d) + b;\r\n        };\r\n        self.calculatePPSTimed = function () {\r\n            self.xPPST = -((self.touchDelta.x - self.touchSigmaTimed.x) / (self.touchDelta.t - self.touchSigmaTimed.t));\r\n            self.yPPST = -((self.touchDelta.y - self.touchSigmaTimed.y) / (self.touchDelta.t - self.touchSigmaTimed.t));\r\n            self.touchSigmaTimed = {\r\n                x: self.touchDelta.x,\r\n                y: self.touchDelta.y,\r\n                t: performance.now()\r\n            };\r\n        };\r\n        self.calculatePPS = function () {\r\n            self.xPPS = -((self.touchDelta.x - self.touchSigma.x) / (self.touchDelta.t - self.touchSigma.t));\r\n            self.yPPS = -((self.touchDelta.y - self.touchSigma.y) / (self.touchDelta.t - self.touchSigma.t));\r\n            self.touchSigma = {\r\n                x: self.touchDelta.x,\r\n                y: self.touchDelta.y,\r\n                t: performance.now()\r\n            };\r\n        };\r\n        self.touchEndAnimation = function () {\r\n            if (!self.canvas || !self.scrollBox.scrollTo) { return requestAnimationFrame(self.touchEndAnimation); }\r\n            var n = performance.now(),\r\n                d = self.attributes.touchReleaseAnimationDurationMs,\r\n                t;\r\n            t = n - self.touchDelta.t;\r\n            self.animationFrames += 1;\r\n            self.scrollAnimation.x = self.easing(t, self.touchDelta.scrollLeft, self.touchAnimateTo.x, d);\r\n            self.scrollAnimation.y = self.easing(t, self.touchDelta.scrollTop, self.touchAnimateTo.y, d);\r\n            if (t > d || (self.scrollAnimation.y === self.scrollBox.scrollTop\r\n                    && self.scrollAnimation.x === self.scrollBox.scrollLeft) || self.stopAnimation) {\r\n                return;\r\n            }\r\n            self.scrollBox.scrollTo(self.scrollAnimation.x, self.scrollAnimation.y);\r\n            requestAnimationFrame(self.touchEndAnimation);\r\n        };\r\n        self.touchEditCell = function (cell) {\r\n            self.beginEditAt(cell.columnIndex, cell.rowIndex);\r\n        };\r\n        self.touchCell = function (e) {\r\n            return function () {\r\n                clearInterval(self.calculatePPSTimer);\r\n                var i, pos = self.getTouchPos(e);\r\n                if (Math.abs(self.touchDelta.x) + Math.abs(self.touchDelta.y) < self.attributes.touchDeadZone) {\r\n                    i = self.getCellAt(pos.x, pos.y);\r\n                    if (!i) { return; }\r\n                    if (self.touchingCell && self.touchingCell.rowIndex === i.rowIndex\r\n                            && self.touchingCell.columnIndex === i.columnIndex) {\r\n                        self.touchEditCell(i);\r\n                        return;\r\n                    }\r\n                    if (self.input && self.input.editCell) {\r\n                        self.endEdit();\r\n                    }\r\n                    self.touchingCell = i;\r\n                    self.selectArea({\r\n                        top: i.rowIndex,\r\n                        bottom: i.rowIndex,\r\n                        left: i.columnIndex,\r\n                        right: i.columnIndex\r\n                    });\r\n                    self.draw(true);\r\n                }\r\n            };\r\n        };\r\n        self.touchstart = function (e) {\r\n            if (e.changedTouches[0]) {\r\n                self.touchStart = self.getTouchPos(e);\r\n                self.startingCell = self.getCellAt(self.touchStart.x, self.touchStart.y, true);\r\n            }\r\n            if (self.dispatchEvent('touchstart', {NativeEvent: e, cell: self.startingCell})) { return; }\r\n            self.disposeContextMenu();\r\n            clearInterval(self.calculatePPSTimer);\r\n            clearTimeout(self.touchContextTimeout);\r\n            self.touchStartEvent = e;\r\n            self.stopAnimation = true;\r\n            self.animationFrames = 0;\r\n            self.stopPropagation(e);\r\n            e.preventDefault();\r\n            if (e.touches.length === 1 && e.changedTouches[0] && !self.zoomAltered) {\r\n                self.touchLength = 1;\r\n                self.touchStart = self.touchStart || self.touchStart1;\r\n                self.touchScrollStart = {\r\n                    x: self.scrollBox.scrollLeft,\r\n                    y: self.scrollBox.scrollTop,\r\n                    t: performance.now()\r\n                };\r\n                self.touchDelta = {\r\n                    x: 0,\r\n                    y: 0,\r\n                    scrollLeft: self.scrollBox.scrollLeft,\r\n                    scrollTop: self.scrollBox.scrollTop,\r\n                    t: self.touchScrollStart.t\r\n                };\r\n                self.touchSigma = {\r\n                    x: self.touchDelta.x,\r\n                    y: self.touchDelta.y,\r\n                    t: self.touchDelta.t\r\n                };\r\n                self.touchSigmaTimed = {\r\n                    x: self.touchDelta.x,\r\n                    y: self.touchDelta.y,\r\n                    t: self.touchDelta.t\r\n                };\r\n                self.touchContextTimeout = setTimeout(function () {\r\n                    self.contextmenuEvent(e, self.touchStart);\r\n                }, self.attributes.touchContextMenuTimeMs);\r\n                self.calculatePPSTimer = setInterval(self.calculatePPSTimed, touchTimerMs);\r\n                if (self.startingCell && (self.startingCell.isGrid || ['tree', 'inherit'].indexOf(self.startingCell.context) !== -1)) {\r\n                    self.hasFocus = false;\r\n                    return;\r\n                }\r\n                self.hasFocus = true;\r\n                if (self.startingCell.isHeader) {\r\n                    if (self.startingCell.isRowHeader) {\r\n                        self.selectArea({\r\n                            top: self.startingCell.rowIndex,\r\n                            bottom: self.startingCell.rowIndex,\r\n                            left: 0,\r\n                            right: self.getVisibleSchema().length - 1,\r\n                        });\r\n                        self.draw(true);\r\n                    } else if (self.startingCell.isColumnHeader) {\r\n                        if (self.attributes.columnHeaderClickBehavior === 'sort') {\r\n                            if (self.orderBy === self.startingCell.header.name) {\r\n                                self.orderDirection = self.orderDirection === 'asc' ? 'desc' : 'asc';\r\n                            } else {\r\n                                self.orderDirection = 'asc';\r\n                            }\r\n                            self.order(self.startingCell.header.name, self.orderDirection);\r\n                        }\r\n                        if (self.attributes.columnHeaderClickBehavior === 'select') {\r\n                            self.selectArea({\r\n                                top: 0,\r\n                                bottom: self.data.length - 1,\r\n                                left: self.startingCell.columnIndex,\r\n                                right: self.startingCell.columnIndex,\r\n                            });\r\n                            self.draw(true);\r\n                        }\r\n                    }\r\n                    self.touchEndEvents(e);\r\n                    return;\r\n                }\r\n            }\r\n            if (self.zoomAltered) { return; }\r\n            document.body.addEventListener('touchmove', self.touchmove, {passive: false});\r\n            document.body.addEventListener('touchend', self.touchend, false);\r\n            document.body.addEventListener('touchcancel', self.touchcancel, false);\r\n            self.draw(true);\r\n        };\r\n        self.touchSelect = function (cell, handleType) {\r\n            if (cell.rowIndex === undefined || cell.columnIndex === undefined) { return; }\r\n            self.touchSelecting = true;\r\n            var bounds = self.getSelectionBounds();\r\n            if (handleType === 'selection-handle-bl'\r\n                    && cell.rowIndex >= bounds.top\r\n                    && cell.columnIndex <= bounds.right) {\r\n                bounds.bottom = cell.rowIndex;\r\n                bounds.left = cell.columnIndex;\r\n            } else if (handleType === 'selection-handle-tl'\r\n                    && cell.rowIndex <= bounds.bottom\r\n                    && cell.columnIndex <= bounds.right) {\r\n                bounds.top = cell.rowIndex;\r\n                bounds.left = cell.columnIndex;\r\n            } else if (handleType === 'selection-handle-tr'\r\n                    && cell.rowIndex <= bounds.bottom\r\n                    && cell.columnIndex >= bounds.left) {\r\n                bounds.top = cell.rowIndex;\r\n                bounds.right = cell.columnIndex;\r\n            } else if (handleType === 'selection-handle-br'\r\n                    && cell.rowIndex >= bounds.top\r\n                    && cell.columnIndex >= bounds.left) {\r\n                bounds.bottom = cell.rowIndex;\r\n                bounds.right = cell.columnIndex;\r\n            }\r\n            if (self.attributes.selectionMode === 'row' || cell.rowIndex === -1) {\r\n                bounds.left = 0;\r\n                bounds.right = self.getSchema().length - 1;\r\n            } else {\r\n                bounds.left = Math.max(0, bounds.left);\r\n            }\r\n            self.selectArea(bounds);\r\n            self.draw(true);\r\n        };\r\n        function touchMove(e) {\r\n            var ch, rw, rScrollZone, lScrollZone, bScrollZone, tScrollZone, sbw, t1, t2;\r\n            if (self.dispatchEvent('beforetouchmove', {NativeEvent: e})) { return; }\r\n            clearTimeout(touchScrollTimeout);\r\n            if (e.changedTouches[0]) {\r\n                self.touchPosition = self.getTouchPos(e);\r\n            }\r\n            if (e.changedTouches[1]) {\r\n                self.touchPosition1 = self.getTouchPos(e, 1);\r\n            }\r\n            if (Math.abs(self.touchDelta.x) + Math.abs(self.touchDelta.y) > self.attributes.touchDeadZone) {\r\n                clearTimeout(self.touchContextTimeout);\r\n            }\r\n            if (e.touches.length === 2 && self.touchPosition && self.touchPosition1) {\r\n                t1 = self.touchPosition.y;\r\n                t2 = self.touchPosition1.y;\r\n                if (!self.zoomDeltaStart) {\r\n                    self.zoomDeltaStart = Math.abs(t1 - t2);\r\n                    self.startScale = self.scale;\r\n                }\r\n                self.touchLength = 2;\r\n                self.scaleDelta = self.zoomDeltaStart - Math.abs(t1 - t2);\r\n                self.scale = self.startScale - (self.scaleDelta * self.attributes.touchZoomSensitivity);\r\n                self.scale = Math.min(Math.max(self.scale, self.attributes.touchZoomMin), self.attributes.touchZoomMax);\r\n                self.zoomAltered = true;\r\n                self.resize(true);\r\n                self.resizeChildGrids();\r\n                return;\r\n            }\r\n            if (self.zoomAltered) { return; }\r\n            self.touchLength = 1;\r\n            self.touchPosition = self.touchPosition || self.touchPosition1;\r\n            ch = self.getColumnHeaderCellHeight();\r\n            rw = self.getRowHeaderCellWidth();\r\n            rScrollZone = self.width - self.style.scrollBarWidth - self.touchPosition.x < self.attributes.selectionScrollZone;\r\n            lScrollZone = self.touchPosition.x - rw < self.attributes.selectionScrollZone;\r\n            bScrollZone = self.height - self.style.scrollBarWidth - self.touchPosition.y < self.attributes.selectionScrollZone;\r\n            tScrollZone = self.touchPosition.y - ch < self.attributes.selectionScrollZone;\r\n            sbw = self.style.scrollBarWidth;\r\n            function touchScroll() {\r\n                var x = self.scrollBox.scrollLeft,\r\n                    y = self.scrollBox.scrollTop;\r\n                x += (rScrollZone ? self.attributes.selectionScrollIncrement : 0);\r\n                y += (bScrollZone ? self.attributes.selectionScrollIncrement : 0);\r\n                y -= (tScrollZone ? self.attributes.selectionScrollIncrement : 0);\r\n                x -= (lScrollZone ? self.attributes.selectionScrollIncrement : 0);\r\n                self.scrollBox.scrollTo(x, y);\r\n                touchScrollTimeout = setTimeout(touchScroll, self.attributes.scrollRepeatRate);\r\n            }\r\n            e.stopPropagation();\r\n            self.touchDelta = {\r\n                x: self.touchPosition.x - self.touchStart.x,\r\n                y: self.touchPosition.y - self.touchStart.y,\r\n                scrollLeft: self.scrollBox.scrollLeft,\r\n                scrollTop: self.scrollBox.scrollTop,\r\n                t: performance.now()\r\n            };\r\n            self.currentCell = self.getCellAt(self.touchPosition.x, self.touchPosition.y);\r\n            self.dispatchEvent('touchmove', {NativeEvent: e, cell: self.currentCell});\r\n            self.calculatePPS();\r\n            self.touchDuration = performance.now() - self.touchScrollStart.t;\r\n            self.stopAnimation = true;\r\n            self.animationFrames = 0;\r\n            if (self.touchSelecting && (rScrollZone || lScrollZone || tScrollZone || bScrollZone)) {\r\n                touchScroll();\r\n            }\r\n            if (/vertical-scroll-/.test(self.startingCell.style)) {\r\n                self.scrollBox.scrollTop = self.scrollBox.scrollHeight\r\n                    * ((self.touchPosition.y - ch - sbw) / (self.scrollBox.height - sbw - ch));\r\n                return;\r\n            }\r\n            if (/horizontal-scroll-/.test(self.startingCell.style)) {\r\n                self.scrollBox.scrollLeft = self.scrollBox.scrollWidth\r\n                    * ((self.touchPosition.x - rw - sbw) / (self.scrollBox.width - sbw - rw));\r\n                return;\r\n            }\r\n            if (/selection-handle-/.test(self.startingCell.style)) {\r\n                self.touchSelect(self.currentCell, self.startingCell.style);\r\n                return;\r\n            }\r\n            self.scrollBox.scrollTo(self.touchScrollStart.x - self.touchDelta.x,\r\n                self.touchScrollStart.y - self.touchDelta.y);\r\n        };\r\n        self.touchmove = function (e) {\r\n            if (touchMoving) {\r\n                return;\r\n            }\r\n            requestAnimationFrame(function () {\r\n                touchMoving = true;\r\n                touchMove(e);\r\n                touchMoving = false;\r\n            });\r\n        };\r\n        self.touchEndEvents = function (e) {\r\n            self.zoomDeltaStart = undefined;\r\n            self.touchSelecting = false;\r\n            clearInterval(self.touchScrollTimeout);\r\n            clearInterval(self.touchContextTimeout);\r\n            clearInterval(self.calculatePPSTimer);\r\n            e.stopPropagation();\r\n            document.body.removeEventListener('touchmove', self.touchmove, {passive: false});\r\n            document.body.removeEventListener('touchend', self.touchend, false);\r\n            document.body.removeEventListener('touchcancel', self.touchcancel, false);\r\n        };\r\n        self.touchend = function (e) {\r\n            if (self.dispatchEvent('touchend', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            self.zoomDeltaStart = undefined;\r\n            if (e.changedTouches[0]) {\r\n                self.touchPosition = undefined;\r\n            }\r\n            if (e.changedTouches[1]) {\r\n                self.touchPosition1 = undefined;\r\n            }\r\n            if (self.zoomAltered) {\r\n                if (e.touches.length === 0) {\r\n                    self.zoomAltered = false;\r\n                }\r\n                return;\r\n            }\r\n            var dz = Math.abs(self.touchDelta.x) + Math.abs(self.touchDelta.y) < self.attributes.touchDeadZone;\r\n            if (isNaN(self.xPPS)) {\r\n                self.xPPS = 0;\r\n            }\r\n            if (isNaN(self.yPPS)) {\r\n                self.yPPS = 0;\r\n            }\r\n            if (isNaN(self.xPPST)) {\r\n                self.xPPST = 0;\r\n            }\r\n            if (isNaN(self.yPPST)) {\r\n                self.yPPST = 0;\r\n            }\r\n            self.touchAnimateTo.x = self.xPPS * self.attributes.touchReleaseAcceleration;\r\n            self.touchAnimateTo.y = self.yPPS * self.attributes.touchReleaseAcceleration;\r\n            self.calculatePPSTimed();\r\n            if (dz && !self.contextMenu) {\r\n                self.touchCell(self.touchStartEvent)();\r\n            } else if (self.animationFrames === 0\r\n                    && (Math.abs(self.xPPST) > self.attributes.scrollAnimationPPSThreshold\r\n                        || Math.abs(self.yPPST) > self.attributes.scrollAnimationPPSThreshold)\r\n                    && !/-scroll-/.test(self.startingCell.style)\r\n                    && !dz) {\r\n                self.stopAnimation = false;\r\n                self.touchEndAnimation();\r\n            }\r\n            self.touchEndEvents(e);\r\n        };\r\n        self.touchcancel = function (e) {\r\n            if (self.dispatchEvent('touchcancel', {NativeEvent: e, cell: self.currentCell})) { return; }\r\n            self.touchEndEvents(e);\r\n        };\r\n    };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/touch.js\n// module id = 5\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals HTMLElement: false, Reflect: false, define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine([], function () {\r\n  'use strict';\r\n  return function (self, ctor) {\r\n    self.scale = 1;\r\n    self.orders = {\r\n      rows: [],\r\n      columns: []\r\n    };\r\n    self.appliedInlineStyles = {};\r\n    self.cellGridAttributes = {};\r\n    self.treeGridAttributes = {};\r\n    self.visibleRowHeights = [];\r\n    self.hasFocus = false;\r\n    self.activeCell = {\r\n      columnIndex: 0,\r\n      rowIndex: 0\r\n    };\r\n    self.innerHTML = '';\r\n    self.storageName = 'canvasDataGrid';\r\n    self.invalidSearchExpClass = 'canvas-datagrid-invalid-search-regExp';\r\n    self.localStyleLibraryStorageKey = 'canvas-datagrid-user-style-library';\r\n    self.dataType = 'application/x-canvas-datagrid';\r\n    self.orderBy = null;\r\n    self.orderDirection = 'asc';\r\n    self.orderings = {\r\n      columns: [],\r\n      add: function (orderBy, orderDirection, sortFunction) {\r\n        self.orderings.columns = self.orderings.columns.filter(function (col) {\r\n          return col.orderBy !== orderBy;\r\n        });\r\n        self.orderings.columns.push({\r\n          orderBy: orderBy,\r\n          orderDirection: orderDirection,\r\n          sortFunction: sortFunction\r\n        });\r\n      },\r\n      sort: function () {\r\n        self.orderings.columns.forEach(function (col) {\r\n          self.data.sort(col.sortFunction(col.orderBy, col.orderDirection));\r\n        });\r\n      }\r\n    };\r\n    self.columnFilters = {};\r\n    self.filters = {};\r\n    self.frozenRow = 0;\r\n    self.frozenColumn = 0;\r\n    self.ellipsisCache = {};\r\n    self.scrollCache = { x: [], y: [] };\r\n    self.scrollBox = {};\r\n    self.visibleRows = [];\r\n    self.visibleCells = [];\r\n    self.sizes = {\r\n      rows: {},\r\n      columns: {},\r\n      trees: {}\r\n    };\r\n    self.currentFilter = function () {\r\n      return true;\r\n    };\r\n    self.selections = [];\r\n    self.hovers = {};\r\n    self.attributes = {};\r\n    self.style = {};\r\n    self.formatters = {};\r\n    self.sorters = {};\r\n    self.parsers = {};\r\n    self.schemaHashes = {};\r\n    self.events = {};\r\n    self.changes = [];\r\n    self.scrollIndexTop = 0;\r\n    self.scrollPixelTop = 0;\r\n    self.scrollIndexLeft = 0;\r\n    self.scrollPixelLeft = 0;\r\n    self.childGrids = {};\r\n    self.openChildren = {};\r\n    self.scrollModes = [\r\n      'vertical-scroll-box',\r\n      'vertical-scroll-top',\r\n      'vertical-scroll-bottom',\r\n      'horizontal-scroll-box',\r\n      'horizontal-scroll-right',\r\n      'horizontal-scroll-left'\r\n    ];\r\n    self.componentL1Events = {};\r\n    self.eventNames = ['afterdraw', 'afterrendercell', 'attributechanged', 'beforebeginedit',\r\n      'beforecreatecellgrid', 'beforedraw', 'beforeendedit', 'beforerendercell', 'beforerendercellgrid',\r\n      'beginedit', 'cellmouseout', 'cellmouseover', 'click', 'collapsetree', 'contextmenu', 'copy',\r\n      'datachanged', 'dblclick', 'endedit', 'expandtree', 'formatcellvalue', 'keydown', 'keypress',\r\n      'keyup', 'mousedown', 'mousemove', 'mouseup', 'newrow', 'ordercolumn', 'rendercell', 'rendercellgrid',\r\n      'renderorderbyarrow', 'rendertext', 'rendertreearrow', 'reorder', 'reordering', 'resize',\r\n      'resizecolumn', 'resizerow', 'schemachanged', 'scroll', 'selectionchanged', 'stylechanged',\r\n      'touchcancel', 'touchend', 'touchmove', 'touchstart', 'wheel'];\r\n    self.mouse = { x: 0, y: 0 };\r\n    self.getSelectedData = function (expandToRow) {\r\n      var d = [], s = self.getSchema(), l = self.data.length;\r\n      if (l === 0) { return []; }\r\n      self.selections.forEach(function (row, index) {\r\n        if (!row) { return; }\r\n        if (index === l) { return; }\r\n        if (row.length === 0) {\r\n          d[index] = null;\r\n          return;\r\n        }\r\n        d[index] = {};\r\n        row.forEach(function (col) {\r\n          var orderedIndex;\r\n          if (col === -1 || !s[col]) { return; }\r\n          orderedIndex = self.orders.columns[col];\r\n          if (!expandToRow && s[orderedIndex].hidden) { return; }\r\n          if (self.data[index]) {\r\n            d[index][s[orderedIndex].name] = self.data[index][s[orderedIndex].name];\r\n          }\r\n        });\r\n      });\r\n      return d;\r\n    };\r\n    self.getColumnHeaderCellHeight = function () {\r\n      if (!self.attributes.showColumnHeaders) { return 0; }\r\n      return ((self.sizes.rows[-1] || self.style.columnHeaderCellHeight) * self.scale);\r\n    };\r\n    self.getRowHeaderCellWidth = function () {\r\n      if (!self.attributes.showRowHeaders) { return 0; }\r\n      return (self.sizes.columns[-1] || self.style.rowHeaderCellWidth) * self.scale;\r\n    };\r\n    self.setStorageData = function () {\r\n      if (!self.attributes.saveAppearance || !self.attributes.name) { return; }\r\n      var visibility = {};\r\n      self.getSchema().forEach(function (column) {\r\n        visibility[column.name] = !column.hidden;\r\n      });\r\n      localStorage.setItem(self.storageName + '-' + self.attributes.name, JSON.stringify({\r\n        sizes: {\r\n          rows: self.sizes.rows,\r\n          columns: self.sizes.columns\r\n        },\r\n        orders: {\r\n          rows: self.orders.rows,\r\n          columns: self.orders.columns\r\n        },\r\n        orderBy: self.orderBy,\r\n        orderDirection: self.orderDirection,\r\n        visibility: visibility\r\n      }));\r\n    };\r\n    self.getSchema = function () {\r\n      return self.schema || self.tempSchema || [];\r\n    };\r\n    function fillArray(low, high) {\r\n      var i = [], x;\r\n      for (x = low; x <= high; x += 1) {\r\n        i[x] = x;\r\n      }\r\n      return i;\r\n    }\r\n    self.createColumnOrders = function () {\r\n      var s = self.getSchema();\r\n      self.orders.columns = fillArray(0, s.length - 1);\r\n    };\r\n    self.createRowOrders = function () {\r\n      self.orders.rows = fillArray(0, self.data.length - 1);\r\n    };\r\n    self.getVisibleSchema = function () {\r\n      return self.getSchema().filter(function (col) {\r\n        return !col.hidden;\r\n      });\r\n    };\r\n    self.applyDefaultValue = function (row, header) {\r\n      var d = header.defaultValue || '';\r\n      if (typeof d === 'function') {\r\n        d = d.apply(self.intf, [header]);\r\n      }\r\n      row[header.name] = d;\r\n    };\r\n    self.createNewRowData = function () {\r\n      self.newRow = {};\r\n      self.getSchema().forEach(function forEachHeader(header) {\r\n        self.applyDefaultValue(self.newRow, header);\r\n      });\r\n    };\r\n    self.getSchemaNameHash = function (key) {\r\n      var n = 0;\r\n      while (self.schemaHashes[key]) {\r\n        n += 1;\r\n        key = key + n;\r\n      }\r\n      return key;\r\n    };\r\n    self.filter = function (type) {\r\n      var f = self.filters[type];\r\n      if (!f && type !== undefined) {\r\n        console.warn('Cannot find filter for type %s, falling back to substring match.', type);\r\n        f = self.filters.string;\r\n      }\r\n      return f;\r\n    };\r\n    self.applyFilter = function () {\r\n      self.refreshFromOrigialData();\r\n      Object.keys(self.columnFilters).forEach(function (filter) {\r\n        var header = self.getHeaderByName(filter);\r\n        if (!header) {\r\n          return;\r\n        }\r\n        self.currentFilter = header.filter || self.filter(header.type || 'string');\r\n        self.data = self.data.filter(function (row) {\r\n          return self.currentFilter(row[filter], self.columnFilters[filter]);\r\n        });\r\n      });\r\n      self.resize();\r\n      self.draw(true);\r\n    };\r\n    self.applyDataTransforms = function () {\r\n      self.applyFilter();\r\n      self.orderings.sort();\r\n    }\r\n    self.getBestGuessDataType = function (columnName, data) {\r\n      var t, x, l = data.length;\r\n      for (x = 0; x < l; x += 1) {\r\n        if (data[x] !== undefined && data[x] !== null && [null, undefined].indexOf(data[x][columnName]) !== -1) {\r\n          t = typeof data[x];\r\n          return t === 'object' ? 'string' : t;\r\n        }\r\n      }\r\n      return 'string';\r\n    };\r\n    self.drawChildGrids = function () {\r\n      Object.keys(self.childGrids).forEach(function (gridKey) {\r\n        self.childGrids[gridKey].draw();\r\n      });\r\n    };\r\n    self.resizeChildGrids = function () {\r\n      Object.keys(self.childGrids).forEach(function (gridKey) {\r\n        self.childGrids[gridKey].resize();\r\n      });\r\n    };\r\n    self.autoScrollZone = function (e, x, y, ctrl) {\r\n      var setTimer,\r\n        rowHeaderCellWidth = self.getRowHeaderCellWidth(),\r\n        columnHeaderCellHeight = self.getColumnHeaderCellHeight();\r\n      if (y !== -1) {\r\n        if (x > self.width - self.attributes.selectionScrollZone && x < self.width) {\r\n          self.scrollBox.scrollLeft += self.attributes.selectionScrollIncrement;\r\n          setTimer = true;\r\n        }\r\n        if (x - self.attributes.selectionScrollZone - rowHeaderCellWidth < 0) {\r\n          self.scrollBox.scrollLeft -= self.attributes.selectionScrollIncrement;\r\n          setTimer = true;\r\n        }\r\n      }\r\n      if (y !== -1) {\r\n        if (y > self.height - self.attributes.selectionScrollZone && y < self.height) {\r\n          self.scrollBox.scrollTop += self.attributes.selectionScrollIncrement;\r\n          setTimer = true;\r\n        }\r\n        if (y - self.attributes.selectionScrollZone - columnHeaderCellHeight < 0) {\r\n          self.scrollBox.scrollTop -= self.attributes.selectionScrollIncrement;\r\n          setTimer = true;\r\n        }\r\n      }\r\n      if (setTimer && !ctrl && self.currentCell && self.currentCell.columnIndex !== -1) {\r\n        self.scrollTimer = setTimeout(self.mousemove, self.attributes.scrollRepeatRate, e);\r\n      }\r\n    };\r\n    self.refreshFromOrigialData = function () {\r\n      self.data = self.originalData.filter(function (row) {\r\n        return true;\r\n      });\r\n    };\r\n    self.validateColumn = function (c, s) {\r\n      if (!c.name) {\r\n        throw new Error('A column must contain at least a name.');\r\n      }\r\n      if (s.filter(function (i) { return i.name === c.name; }).length > 0) {\r\n        throw new Error('A column with the name '\r\n          + c.name + ' already exists and cannot be added again.');\r\n      }\r\n      return true;\r\n    };\r\n    self.setDefaults = function (obj1, obj2, key, def) {\r\n      obj1[key] = obj2[key] === undefined ? def : obj2[key];\r\n    };\r\n    self.setAttributes = function () {\r\n      self.defaults.attributes.forEach(function eachAttribute(i) {\r\n        self.setDefaults(self.attributes, self.args, i[0], i[1]);\r\n      });\r\n    };\r\n    self.setStyle = function () {\r\n      self.defaults.styles.forEach(function eachStyle(i) {\r\n        self.setDefaults(self.style, self.args.style || {}, i[0], i[1]);\r\n      });\r\n    };\r\n    self.autosize = function (colName) {\r\n      self.getVisibleSchema().forEach(function (col, colIndex) {\r\n        if (col.name === colName || colName === undefined) {\r\n          self.sizes.columns[colIndex]\r\n            = Math.max(self.findColumnMaxTextLength(col.name), self.style.minColumnWidth);\r\n        }\r\n      });\r\n      self.sizes.columns[-1] = self.findColumnMaxTextLength('cornerCell');\r\n    };\r\n    self.dispose = function () {\r\n      if (!self.isChildGrid && self.canvas && self.canvas.parentNode) {\r\n        self.canvas.parentNode.removeChild(self.canvas);\r\n      }\r\n      if (!self.isChildGrid) {\r\n        document.body.removeChild(self.controlInput)\r\n      }\r\n      self.eventParent.removeEventListener('mouseup', self.mouseup, false);\r\n      self.eventParent.removeEventListener('mousedown', self.mousedown, false);\r\n      self.eventParent.removeEventListener('dblclick', self.dblclick, false);\r\n      self.eventParent.removeEventListener('click', self.click, false);\r\n      self.eventParent.removeEventListener('mousemove', self.mousemove);\r\n      self.eventParent.removeEventListener('wheel', self.scrollWheel, false);\r\n      self.canvas.removeEventListener('contextmenu', self.contextmenu, false);\r\n      self.canvas.removeEventListener('copy', self.copy);\r\n      self.controlInput.removeEventListener('copy', self.copy);\r\n      self.controlInput.removeEventListener('cut', self.cut);\r\n      self.controlInput.removeEventListener('paste', self.paste);\r\n      self.controlInput.removeEventListener('keypress', self.keypress, false);\r\n      self.controlInput.removeEventListener('keyup', self.keyup, false);\r\n      self.controlInput.removeEventListener('keydown', self.keydown, false);\r\n      window.removeEventListener('resize', self.resize);\r\n      if (self.observer && self.observer.disconnect) {\r\n        self.observer.disconnect();\r\n      }\r\n    };\r\n    self.tryLoadStoredSettings = function () {\r\n      var s;\r\n      self.reloadStoredValues();\r\n      if (self.storedSettings\r\n        && typeof self.storedSettings.orders === 'object'\r\n        && self.storedSettings.orders !== null) {\r\n        if (self.storedSettings.orders.rows.length >= (self.data || []).length) {\r\n          self.orders.rows = self.storedSettings.orders.rows;\r\n        }\r\n        s = self.getSchema();\r\n        if (self.storedSettings.orders.columns.length === s.length) {\r\n          self.orders.columns = self.storedSettings.orders.columns;\r\n        }\r\n        self.orderBy = self.storedSettings.orderBy === undefined\r\n          ? s[0].name : self.storedSettings.orderBy;\r\n        self.orderDirection = self.storedSettings.orderDirection === undefined\r\n          ? 'asc' : self.storedSettings.orderDirection;\r\n        if (self.storedSettings.orderBy !== undefined && self.getHeaderByName(self.orderBy) && self.orderDirection) {\r\n          self.order(self.orderBy, self.orderDirection);\r\n        }\r\n      }\r\n    };\r\n    self.getDomRoot = function () {\r\n      return self.shadowRoot ? self.shadowRoot.host : self.parentNode;\r\n    };\r\n    self.getFontName = function (fontStyle) {\r\n      return fontStyle.replace(/\\d+\\.?\\d*px/, '');\r\n    };\r\n    self.getFontHeight = function (fontStyle) {\r\n      return parseFloat(fontStyle, 10);\r\n    };\r\n    self.parseStyleValue = function (key) {\r\n      if (/Font/.test(key)) {\r\n        self.style[key + 'Height'] = self.getFontHeight(self.style[key]);\r\n        self.style[key + 'Name'] = self.getFontName(self.style[key]);\r\n        return;\r\n      }\r\n      // when inheriting styles from already instantiated grids, don't parse already parsed values.\r\n      if (key === 'moveOverlayBorderSegments' && typeof self.style[key] === 'string') {\r\n        self.style[key] = self.style[key].split(',')\r\n          .map(function (i) { return parseInt(i, 10); });\r\n      }\r\n    };\r\n    self.initProp = function (propName) {\r\n      if (!self.args[propName]) { return; }\r\n      Object.keys(self.args[propName]).forEach(function (key) {\r\n        self[propName][key] = self.args[propName][key];\r\n      });\r\n    };\r\n    self.getStyleProperty = function (key) {\r\n      if (self.styleKeys.indexOf(key) === -1) {\r\n        return self.parentNodeStyle[key];\r\n      }\r\n      return self.style[key];\r\n    };\r\n    self.setStyleProperty = function (key, value, supressDrawAndEvent) {\r\n      var isDim = ['height', 'width', 'minHeight', 'minWidth', 'maxHeight', 'maxWidth'].indexOf(key) !== -1;\r\n      if (self.styleKeys.indexOf(key) === -1) {\r\n        self.parentNodeStyle[key] = value;\r\n      } else {\r\n        if (/-/.test(key)) {\r\n          key = self.dehyphenateProperty(key);\r\n        }\r\n        self.style[key] = value;\r\n        self.parseStyleValue(key);\r\n      }\r\n      if (isDim) {\r\n        self.resize();\r\n      }\r\n      if (!supressDrawAndEvent) {\r\n        self.draw(true);\r\n        self.dispatchEvent('stylechanged', { name: 'style', value: value });\r\n      }\r\n    };\r\n    self.reloadStoredValues = function () {\r\n      if (self.attributes.name && self.attributes.saveAppearance) {\r\n        try {\r\n          self.storedSettings = localStorage.getItem(self.storageName + '-' + self.attributes.name);\r\n        } catch (e) {\r\n          console.warn(\"Error loading stored values. \" + e.message);\r\n          self.storedSettings = undefined;\r\n        }\r\n        if (self.storedSettings) {\r\n          try {\r\n            self.storedSettings = JSON.parse(self.storedSettings);\r\n          } catch (e) {\r\n            console.warn('could not read settings from localStore', e);\r\n            self.storedSettings = undefined;\r\n          }\r\n        }\r\n        if (self.storedSettings) {\r\n          if (typeof self.storedSettings.sizes === 'object'\r\n            && self.storedSettings.sizes !== null) {\r\n            self.sizes.rows = self.storedSettings.sizes.rows;\r\n            self.sizes.columns = self.storedSettings.sizes.columns;\r\n            ['trees', 'columns', 'rows'].forEach(function (i) {\r\n              if (!self.sizes[i]) {\r\n                self.sizes[i] = {};\r\n              }\r\n            });\r\n          }\r\n          if (typeof self.storedSettings.visibility === 'object') {\r\n            self.getSchema().forEach(function (column) {\r\n              if (self.storedSettings.visibility && self.storedSettings.visibility[column.name] !== undefined) {\r\n                column.hidden = !self.storedSettings.visibility[column.name];\r\n              }\r\n            });\r\n          }\r\n        }\r\n      }\r\n    };\r\n    self.init = function () {\r\n      if (self.initialized) { return; }\r\n      function addStyleKeyIfNoneExists(key) {\r\n        if (self.styleKeys.indexOf(key) === -1) {\r\n          self.styleKeys.push(key);\r\n        }\r\n      }\r\n      var publicStyleKeyIntf = {};\r\n      self.setAttributes();\r\n      self.setStyle();\r\n      self.initScrollBox();\r\n      self.setDom();\r\n      self.nodeType = 'canvas-datagrid';\r\n      self.ie = /Trident/.test(window.navigator.userAgent);\r\n      self.edge = /Edge/.test(window.navigator.userAgent);\r\n      self.webKit = /WebKit/.test(window.navigator.userAgent);\r\n      self.moz = /Gecko/.test(window.navigator.userAgent);\r\n      self.mobile = /Mobile/i.test(window.navigator.userAgent);\r\n      self.cursorGrab = 'move';\r\n      self.cursorGrabing = 'move';\r\n      self.cursorGrab = self.webKit ? 'move' : self.cursorGrab;\r\n      self.cursorGrabing = self.moz ? 'move' : self.cursorGrabbing;\r\n      self.pointerLockPosition = { x: 0, y: 0 };\r\n      Object.keys(self.style).forEach(self.parseStyleValue);\r\n      self.intf.moveSelection = self.moveSelection;\r\n      self.intf.moveTo = self.moveTo;\r\n      self.intf.addEventListener = self.addEventListener;\r\n      self.intf.removeEventListener = self.removeEventListener;\r\n      self.intf.dispatchEvent = self.dispatchEvent;\r\n      /**\r\n       * Releases grid resources and removes grid elements.\r\n       * @memberof canvasDatagrid\r\n       * @name dispose\r\n       * @method\r\n       */\r\n      self.intf.dispose = self.dispose;\r\n      /**\r\n       * Appends the grid to another element later.  Not implemented.\r\n       * @memberof canvasDatagrid\r\n       * @name appendTo\r\n       * @method\r\n       * @param {number} el The element to append the grid to.\r\n       */\r\n      self.intf.appendTo = self.appendTo;\r\n      self.intf.getVisibleCellByIndex = self.getVisibleCellByIndex;\r\n      self.intf.filters = self.filters;\r\n      self.intf.sorters = self.sorters;\r\n      self.intf.autosize = self.autosize;\r\n      self.intf.beginEditAt = self.beginEditAt;\r\n      self.intf.endEdit = self.endEdit;\r\n      self.intf.setActiveCell = self.setActiveCell;\r\n      self.intf.forEachSelectedCell = self.forEachSelectedCell;\r\n      self.intf.scrollIntoView = self.scrollIntoView;\r\n      self.intf.clearChangeLog = self.clearChangeLog;\r\n      self.intf.gotoCell = self.gotoCell;\r\n      self.intf.gotoRow = self.gotoRow;\r\n      self.intf.getHeaderByName = self.getHeaderByName;\r\n      self.intf.findColumnScrollLeft = self.findColumnScrollLeft;\r\n      self.intf.findRowScrollTop = self.findRowScrollTop;\r\n      self.intf.fitColumnToValues = self.fitColumnToValues;\r\n      self.intf.findColumnMaxTextLength = self.findColumnMaxTextLength;\r\n      self.intf.disposeContextMenu = self.disposeContextMenu;\r\n      self.intf.getCellAt = self.getCellAt;\r\n      self.intf.isCellVisible = self.isCellVisible;\r\n      self.intf.isRowVisible = self.isRowVisible;\r\n      self.intf.isColumnVisible = self.isColumnVisible;\r\n      self.intf.order = self.order;\r\n      self.intf.draw = self.draw;\r\n      self.intf.isComponent = self.isComponent;\r\n      self.intf.selectArea = self.selectArea;\r\n      self.intf.clipElement = self.clipElement;\r\n      self.intf.getSchemaFromData = self.getSchemaFromData;\r\n      self.intf.setFilter = self.setFilter;\r\n      self.intf.selectRow = self.selectRow;\r\n      self.intf.parentGrid = self.parentGrid;\r\n      self.intf.toggleTree = self.toggleTree;\r\n      self.intf.expandTree = self.expandTree;\r\n      self.intf.collapseTree = self.collapseTree;\r\n      self.intf.canvas = self.canvas;\r\n      self.intf.context = self.ctx;\r\n      self.intf.insertRow = self.insertRow;\r\n      self.intf.deleteRow = self.deleteRow;\r\n      self.intf.addRow = self.addRow;\r\n      self.intf.insertColumn = self.insertColumn;\r\n      self.intf.deleteColumn = self.deleteColumn;\r\n      self.intf.addColumn = self.addColumn;\r\n      self.intf.getClippingRect = self.getClippingRect;\r\n      self.intf.setRowHeight = self.setRowHeight;\r\n      self.intf.setColumnWidth = self.setColumnWidth;\r\n      self.intf.resetColumnWidths = self.resetColumnWidths;\r\n      self.intf.resetRowHeights = self.resetRowHeights;\r\n      self.intf.resize = self.resize;\r\n      self.intf.selectColumn = self.selectColumn;\r\n      self.intf.selectRow = self.selectRow;\r\n      self.intf.selectAll = self.selectAll;\r\n      self.intf.selectNone = self.selectNone;\r\n      self.intf.drawChildGrids = self.drawChildGrids;\r\n      self.intf.assertPxColor = self.assertPxColor;\r\n      self.intf.clearPxColorAssertions = self.clearPxColorAssertions;\r\n      self.intf.integerToAlpha = self.integerToAlpha;\r\n      self.intf.copy = self.copy;\r\n      self.intf.setStyleProperty = self.setStyleProperty;\r\n      Object.defineProperty(self.intf, 'defaults', {\r\n        get: function () {\r\n          return {\r\n            styles: self.defaults.styles.reduce(function (a, i) { a[i[0]] = i[1]; return a; }, {}),\r\n            attributes: self.defaults.attributes.reduce(function (a, i) { a[i[0]] = i[1]; return a; }, {})\r\n          };\r\n        }\r\n      });\r\n      self.styleKeys = Object.keys(self.intf.defaults.styles);\r\n      self.styleKeys.map(function (i) { return self.hyphenateProperty(i, false); }).forEach(addStyleKeyIfNoneExists);\r\n      self.styleKeys.map(function (i) { return self.hyphenateProperty(i, true); }).forEach(addStyleKeyIfNoneExists);\r\n      self.DOMStyles = window.getComputedStyle(document.body, null);\r\n      self.styleKeys.concat(Object.keys(self.DOMStyles)).forEach(function (key) {\r\n        // unless this line is here, Object.keys() will not work on <instance>.style\r\n        publicStyleKeyIntf[key] = undefined;\r\n        Object.defineProperty(publicStyleKeyIntf, key, {\r\n          get: function () {\r\n            return self.getStyleProperty(key);\r\n          },\r\n          set: function (value) {\r\n            if (self.initialized) {\r\n              self.appliedInlineStyles[key] = value;\r\n            }\r\n            self.setStyleProperty(key, value);\r\n          }\r\n        });\r\n      });\r\n      Object.defineProperty(self.intf, 'shadowRoot', {\r\n        get: function () {\r\n          return self.shadowRoot;\r\n        }\r\n      });\r\n      Object.defineProperty(self.intf, 'activeCell', {\r\n        get: function () {\r\n          return self.activeCell;\r\n        }\r\n      });\r\n      Object.defineProperty(self.intf, 'hasFocus', {\r\n        get: function () {\r\n          return self.hasFocus;\r\n        }\r\n      });\r\n      Object.defineProperty(self.intf, 'style', {\r\n        get: function () {\r\n          return publicStyleKeyIntf;\r\n        },\r\n        set: function (valueObject) {\r\n          Object.keys(valueObject).forEach(function (key) {\r\n            self.setStyleProperty(key, valueObject[key], true);\r\n          });\r\n          self.draw(true);\r\n          self.dispatchEvent('stylechanged', { name: 'style', value: valueObject });\r\n        }\r\n      });\r\n      Object.defineProperty(self.intf, 'attributes', { value: {} });\r\n      Object.keys(self.attributes).forEach(function (key) {\r\n        Object.defineProperty(self.intf.attributes, key, {\r\n          get: function () {\r\n            return self.attributes[key];\r\n          },\r\n          set: function (value) {\r\n            self.attributes[key] = value;\r\n            if (key === 'name') {\r\n              self.tryLoadStoredSettings();\r\n            }\r\n            self.draw(true);\r\n            self.dispatchEvent('attributechanged', { name: key, value: value[key] });\r\n          }\r\n        });\r\n      });\r\n      self.filters.string = function (value, filterFor) {\r\n        value = String(value);\r\n        var filterRegExp,\r\n          regEnd = /\\/(i|g|m)*$/,\r\n          pattern = regEnd.exec(filterFor),\r\n          flags = pattern ? pattern[0].substring(1) : '',\r\n          flagLength = flags.length;\r\n        self.invalidFilterRegEx = undefined;\r\n        if (filterFor.substring(0, 1) === '/' && pattern) {\r\n          try {\r\n            filterRegExp = new RegExp(filterFor.substring(1, filterFor.length - (flagLength + 1)), flags);\r\n          } catch (e) {\r\n            self.invalidFilterRegEx = e;\r\n            return;\r\n          }\r\n          return filterRegExp.test(value);\r\n        }\r\n        return value.toString ? value.toString().toLocaleUpperCase()\r\n          .indexOf(filterFor.toLocaleUpperCase()) !== -1 : false;\r\n      };\r\n      self.filters.number = function (value, filterFor) {\r\n        if (!filterFor) { return true; }\r\n        return value === filterFor;\r\n      };\r\n      ['formatters', 'filters', 'sorters'].forEach(self.initProp);\r\n      self.applyComponentStyle(false, self.intf);\r\n      self.reloadStoredValues();\r\n      if (self.args.data) {\r\n        self.intf.data = self.args.data;\r\n      }\r\n      if (self.intf.innerText || self.intf.textContent) {\r\n        if (self.intf.dataType === 'application/x-canvas-datagrid') {\r\n          self.intf.dataType = 'application/json+x-canvas-datagrid';\r\n        }\r\n        self.intf.data = self.intf.innerText || self.intf.textContent;\r\n      }\r\n      if (self.args.schema) {\r\n        self.intf.schema = self.args.schema;\r\n      }\r\n      if (self.isChildGrid || !self.isComponent) {\r\n        requestAnimationFrame(function () { self.resize(true); });\r\n      } else {\r\n        self.resize(true);\r\n      }\r\n      self.initialized = true;\r\n      return self;\r\n    };\r\n    /**\r\n     * Removes focus from the grid.\r\n     * @memberof canvasDatagrid\r\n     * @name blur\r\n     * @method\r\n     */\r\n    self.intf.blur = function (e) {\r\n      self.hasFocus = false;\r\n    };\r\n    /**\r\n     * Focuses on the grid.\r\n     * @memberof canvasDatagrid\r\n     * @name focus\r\n     * @method\r\n     */\r\n    self.intf.focus = function () {\r\n      self.hasFocus = true;\r\n      self.controlInput.focus();\r\n    };\r\n    if (self.shadowRoot || self.isChildGrid) {\r\n      Object.defineProperty(self.intf, 'height', {\r\n        get: function () {\r\n          if (self.shadowRoot) {\r\n            return self.shadowRoot.height;\r\n          }\r\n          return self.parentNode.height;\r\n        },\r\n        set: function (value) {\r\n          if (self.shadowRoot) {\r\n            self.shadowRoot.height = value;\r\n          } else {\r\n            self.parentNode.height = value;\r\n          }\r\n          self.resize(true);\r\n        }\r\n      });\r\n      Object.defineProperty(self.intf, 'width', {\r\n        get: function () {\r\n          if (self.shadowRoot) {\r\n            return self.shadowRoot.width;\r\n          }\r\n          return self.parentNode.width;\r\n        },\r\n        set: function (value) {\r\n          if (self.shadowRoot) {\r\n            self.shadowRoot.width = value;\r\n          } else {\r\n            self.parentNode.width = value;\r\n          }\r\n          self.resize(true);\r\n        }\r\n      });\r\n      Object.defineProperty(self.intf, 'parentNode', {\r\n        get: function () {\r\n          return self.parentNode;\r\n        },\r\n        set: function (value) {\r\n          if (!self.isChildGrid) {\r\n            throw new TypeError('Cannot set property parentNode which has only a getter');\r\n          }\r\n          self.parentNode = value;\r\n        }\r\n      });\r\n    }\r\n    Object.defineProperty(self.intf, 'visibleRowHeights', {\r\n      get: function () {\r\n        return self.visibleRowHeights;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'openChildren', {\r\n      get: function () {\r\n        return self.openChildren;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'childGrids', {\r\n      get: function () {\r\n        return Object.keys(self.childGrids).map(function (gridId) {\r\n          return self.childGrids[gridId];\r\n        });\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'isChildGrid', {\r\n      get: function () {\r\n        return self.isChildGrid;\r\n      }\r\n    });\r\n    Object.defineProperty(self, 'cursor', {\r\n      get: function () {\r\n        return self.parentNodeStyle.cursor;\r\n      },\r\n      set: function (value) {\r\n        if (value === 'cell') { value = 'default'; }\r\n        if (self.currentCursor !== value) {\r\n          self.parentNodeStyle.cursor = value;\r\n          self.currentCursor = value;\r\n        }\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'orderDirection', {\r\n      get: function () {\r\n        return self.orderDirection;\r\n      },\r\n      set: function (value) {\r\n        if (value !== 'desc') {\r\n          value = 'asc';\r\n        }\r\n        self.orderDirection = value;\r\n        self.order(self.orderBy, self.orderDirection);\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'orderBy', {\r\n      get: function () {\r\n        return self.orderBy;\r\n      },\r\n      set: function (value) {\r\n        if (self.getSchema().find(function (col) {\r\n          return col.name === value;\r\n        }) === undefined) {\r\n          throw new Error('Cannot sort by unknown column name.');\r\n        }\r\n        self.orderBy = value;\r\n        self.order(self.orderBy, self.orderDirection);\r\n      }\r\n    });\r\n    if (self.isComponent) {\r\n      Object.defineProperty(self.intf, 'offsetHeight', {\r\n        get: function () {\r\n          return self.canvas.offsetHeight;\r\n        }\r\n      });\r\n      Object.defineProperty(self.intf, 'offsetWidth', {\r\n        get: function () {\r\n          return self.canvas.offsetWidth;\r\n        }\r\n      });\r\n    }\r\n    Object.defineProperty(self.intf, 'scrollHeight', {\r\n      get: function () {\r\n        return self.scrollBox.scrollHeight;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'scrollWidth', {\r\n      get: function () {\r\n        return self.scrollBox.scrollWidth;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'scrollTop', {\r\n      get: function () {\r\n        return self.scrollBox.scrollTop;\r\n      },\r\n      set: function (value) {\r\n        self.scrollBox.scrollTop = value;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'scrollLeft', {\r\n      get: function () {\r\n        return self.scrollBox.scrollLeft;\r\n      },\r\n      set: function (value) {\r\n        self.scrollBox.scrollLeft = value;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'sizes', {\r\n      get: function () {\r\n        return self.sizes;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'parentDOMNode', {\r\n      get: function () {\r\n        return self.parentDOMNode;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'input', {\r\n      get: function () {\r\n        return self.input;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'controlInput', {\r\n      get: function () {\r\n        return self.controlInput;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'currentCell', {\r\n      get: function () {\r\n        return self.currentCell;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'visibleCells', {\r\n      get: function () {\r\n        return self.visibleCells;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'visibleRows', {\r\n      get: function () {\r\n        return self.visibleRows;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'selections', {\r\n      get: function () {\r\n        return self.selections;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'dragMode', {\r\n      get: function () {\r\n        return self.dragMode;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'changes', {\r\n      get: function () {\r\n        return self.changes;\r\n      }\r\n    });\r\n    self.intf.formatters = self.formatters;\r\n    Object.defineProperty(self.intf, 'dataType', {\r\n      get: function () {\r\n        return self.dataType;\r\n      },\r\n      set: function (value) {\r\n        if (!self.parsers[value]) {\r\n          throw new Error('No parser for MIME type ' + value);\r\n        }\r\n        self.dataType = value;\r\n      }\r\n    });\r\n    self.eventNames.forEach(function (eventName) {\r\n      Object.defineProperty(self.intf, 'on' + eventName, {\r\n        get: function () {\r\n          return self.componentL1Events[eventName];\r\n        },\r\n        set: function (value) {\r\n          self.events[eventName] = [];\r\n          self.componentL1Events[eventName] = value;\r\n          if (!value) { return; }\r\n          self.addEventListener(eventName, value);\r\n        }\r\n      });\r\n    });\r\n    Object.defineProperty(self.intf, 'frozenRow', {\r\n      get: function () {\r\n        return self.frozenRow;\r\n      },\r\n      set: function (val) {\r\n        if (isNaN(val)) {\r\n          throw new TypeError('Expected value for frozenRow to be a number.');\r\n        }\r\n        if (self.visibleRows.length < val) {\r\n          throw new RangeError('Cannot set a value larger than the number of visible rows.');\r\n        }\r\n        self.frozenRow = val;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'frozenColumn', {\r\n      get: function () {\r\n        return self.frozenColumn;\r\n      },\r\n      set: function (val) {\r\n        if (isNaN(val)) {\r\n          throw new TypeError('Expected value for frozenRow to be a number.');\r\n        }\r\n        if (self.getVisibleSchema().length < val) {\r\n          throw new RangeError('Cannot set a value larger than the number of visible columns.');\r\n        }\r\n        self.frozenColumn = val;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'scrollIndexRect', {\r\n      get: function () {\r\n        return {\r\n          top: self.scrollIndexTop,\r\n          right: self.scrollIndexRight,\r\n          bottom: self.scrollIndexBottom,\r\n          left: self.scrollIndexLeft\r\n        };\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'scrollPixelRect', {\r\n      get: function () {\r\n        return {\r\n          top: self.scrollPixelTop,\r\n          right: self.scrollPixelRight,\r\n          bottom: self.scrollPixelBottom,\r\n          left: self.scrollPixelLeft\r\n        };\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'rowOrder', {\r\n      get: function () {\r\n        return self.orders.rows;\r\n      },\r\n      set: function (val) {\r\n        if (!Array.isArray(val)) {\r\n          throw new TypeError('Value must be an array.');\r\n        }\r\n        if (!self.data || val.length < self.data.length) {\r\n          throw new RangeError('Array length must be equal to or greater than number of rows.');\r\n        }\r\n        self.orders.rows = val;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'columnOrder', {\r\n      get: function () {\r\n        return self.orders.columns;\r\n      },\r\n      set: function (val) {\r\n        if (!Array.isArray(val)) {\r\n          throw new TypeError('Value must be an array.');\r\n        }\r\n        if (val.length < self.getSchema().length) {\r\n          throw new RangeError('Array length must be equal to or greater than number of columns.');\r\n        }\r\n        self.orders.columns = val;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'selectionBounds', {\r\n      get: function () {\r\n        return self.getSelectionBounds();\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'selectedRows', {\r\n      get: function () {\r\n        return self.getSelectedData(true);\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'selectedCells', {\r\n      get: function () {\r\n        return self.getSelectedData();\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'visibleSchema', {\r\n      get: function () {\r\n        return self.getVisibleSchema().map(function eachDataRow(col) {\r\n          return col;\r\n        });\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'treeGridAttributes', {\r\n      get: function () {\r\n        return self.treeGridAttributes;\r\n      },\r\n      set: function setTreeGridAttributes(value) {\r\n        self.treeGridAttributes = value;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'cellGridAttributes', {\r\n      get: function () {\r\n        return self.cellGridAttributes;\r\n      },\r\n      set: function setCellGridAttributes(value) {\r\n        self.cellGridAttributes = value;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'ctx', {\r\n      get: function () {\r\n        return self.ctx;\r\n      }\r\n    });\r\n    Object.defineProperty(self.intf, 'schema', {\r\n      get: function schemaGetter() {\r\n        return self.getSchema();\r\n      },\r\n      set: function schemaSetter(value) {\r\n        if (value === undefined) {\r\n          // Issue #89 - allow schema to be set to initialized state\r\n          self.schema = undefined;\r\n          self.tempSchema = undefined;\r\n          self.dispatchEvent('schemachanged', { schema: undefined });\r\n          return;\r\n        }\r\n        if (!Array.isArray(value) || typeof value[0] !== 'object') {\r\n          throw new Error('Schema must be an array of objects.');\r\n        }\r\n        if (value[0].name === undefined) {\r\n          throw new Error('Expected schema to contain an object with at least a name property.');\r\n        }\r\n        self.schema = value.map(function eachSchemaColumn(column, index) {\r\n          column.width = column.width || self.style.cellWidth;\r\n          column.filter = column.filter || self.filter(column.type);\r\n          column.type = column.type || 'string';\r\n          column.index = index;\r\n          column.columnIndex = index;\r\n          column.rowIndex = -1;\r\n          return column;\r\n        });\r\n        self.tempSchema = undefined;\r\n        self.createNewRowData();\r\n        self.createColumnOrders();\r\n        self.tryLoadStoredSettings();\r\n        if (self.storedSettings && typeof self.storedSettings.visibility === 'object') {\r\n          self.schema.forEach(function hideEachSchemaColumn(column, index) {\r\n            if (self.storedSettings && self.storedSettings.visibility[column.name] !== undefined) {\r\n              column.hidden = !self.storedSettings.visibility[column.name];\r\n            }\r\n          });\r\n        }\r\n        self.resize(true);\r\n        self.dispatchEvent('schemachanged', { schema: self.schema });\r\n      }\r\n    });\r\n    /**\r\n     * Gets an array of currently registered MIME types.\r\n     * @memberof canvasDatagrid\r\n     * @name getDataTypes\r\n     * @method\r\n     */\r\n    self.intf.getTypes = function () {\r\n      return Object.keys(self.parsers);\r\n    };\r\n    self.parseInnerHtml = function (data) {\r\n      if (!data || /^ +$/.test(data)) {\r\n        return [];\r\n      }\r\n      try {\r\n        data = JSON.parse(data);\r\n      } catch (e) {\r\n        console.warn(Error('Cannot parse application/json+x-canvas-datagrid formated data. '\r\n          + e.message + '  \\nNote: canvas-datagrid.innerHTML is for string data only.  '\r\n          + 'Use the canvas-datagrid.data property to set object data.'));\r\n      }\r\n      return data;\r\n    };\r\n    self.parsers['application/json+x-canvas-datagrid'] = function (data, callback) {\r\n      self.parsers['application/x-canvas-datagrid'](self.parseInnerHtml(data), function (data, schema) {\r\n        return callback(data, schema);\r\n      });\r\n    };\r\n    self.parsers['application/x-canvas-datagrid'] = function (data, callback) {\r\n      return callback(data);\r\n    };\r\n    self.intf.parsers = self.parsers;\r\n    // send to dataType ETL function to extract from input data\r\n    // and transform into native [{}, {}] format\r\n    self.etl = function (data, callback) {\r\n      if (!self.intf.parsers[self.dataType]) {\r\n        throw new Error('Unsupported data type.');\r\n      }\r\n      self.intf.parsers[self.dataType](data, function (data, schema) {\r\n        if (Array.isArray(schema)) {\r\n          self.schema = schema;\r\n        }\r\n        // Issue #89 - allow schema to be auto-created every time data is set\r\n        if (self.attributes.autoGenerateSchema) {\r\n          self.schema = self.getSchemaFromData(data);\r\n        }\r\n        if (!self.schema) {\r\n          self.tempSchema = self.getSchemaFromData(data);\r\n        }\r\n        if (self.getSchema()) {\r\n          self.createColumnOrders();\r\n        }\r\n        // set the unfiltered/sorted data array\r\n        self.originalData = data;\r\n        // apply filter, sort, etc to incoming dataset\r\n        self.applyDataTransforms();\r\n        // empty data was set\r\n        if (!self.schema && (self.data || []).length === 0) {\r\n          self.tempSchema = [{ name: '' }];\r\n        }\r\n        self.fitColumnToValues('cornerCell', true);\r\n        if ((self.tempSchema && !self.schema) || self.attributes.autoGenerateSchema) {\r\n          self.createColumnOrders();\r\n          self.dispatchEvent('schemachanged', { schema: self.tempSchema });\r\n        }\r\n        callback();\r\n      });\r\n    };\r\n    Object.defineProperty(self.intf, 'data', {\r\n      get: function dataGetter() {\r\n        return self.data;\r\n      },\r\n      set: function dataSetter(value) {\r\n        self.etl(value, function () {\r\n          self.changes = [];\r\n          self.createNewRowData();\r\n          if (self.attributes.autoResizeColumns && self.data.length > 0\r\n            && self.storedSettings === undefined) {\r\n            self.autosize();\r\n          }\r\n          // set the header column to fit the numbers in it\r\n          self.fitColumnToValues('cornerCell', true);\r\n          self.createRowOrders();\r\n          self.tryLoadStoredSettings();\r\n          self.dispatchEvent('datachanged', { data: self.data });\r\n          self.resize(true);\r\n        });\r\n      }\r\n    });\r\n    self.initScrollBox = function () {\r\n      var sHeight = 0,\r\n        sWidth = 0,\r\n        scrollTop = 0,\r\n        scrollLeft = 0,\r\n        scrollHeight = 0,\r\n        scrollWidth = 0,\r\n        scrollBoxHeight = 20,\r\n        scrollBoxWidth = 20;\r\n      function setScrollTop(value, preventScrollEvent) {\r\n        if (isNaN(value)) {\r\n          throw new Error('ScrollTop value must be a number');\r\n        }\r\n        if (value < 0) {\r\n          value = 0;\r\n        }\r\n        if (value > scrollHeight) {\r\n          value = scrollHeight;\r\n        }\r\n        if (scrollHeight < 0) {\r\n          value = 0;\r\n        }\r\n        scrollTop = value;\r\n        if (!preventScrollEvent) {\r\n          self.scroll();\r\n        }\r\n      }\r\n      function setScrollLeft(value, preventScrollEvent) {\r\n        if (isNaN(value)) {\r\n          throw new Error('ScrollLeft value must be a number');\r\n        }\r\n        if (value < 0) {\r\n          value = 0;\r\n        }\r\n        if (value > scrollWidth) {\r\n          value = scrollWidth;\r\n        }\r\n        if (scrollWidth < 0) {\r\n          value = 0;\r\n        }\r\n        scrollLeft = value;\r\n        if (!preventScrollEvent) {\r\n          self.scroll();\r\n        }\r\n      }\r\n      self.scrollBox.toString = function () {\r\n        return '{\"width\": ' + scrollWidth.toFixed(2)\r\n          + ', \"height\": ' + scrollHeight.toFixed(2)\r\n          + ', \"left\": ' + scrollLeft.toFixed(2)\r\n          + ', \"top\": ' + scrollTop.toFixed(2)\r\n          + ', \"widthRatio\": ' + self.scrollBox.widthBoxRatio.toFixed(5)\r\n          + ', \"heightRatio\": ' + self.scrollBox.heightBoxRatio.toFixed(5) + '}';\r\n      };\r\n      self.scrollBox.scrollTo = function (x, y, supressDrawEvent) {\r\n        setScrollLeft(x, true);\r\n        setScrollTop(y, supressDrawEvent);\r\n      };\r\n      Object.defineProperty(self.scrollBox, 'scrollBoxHeight', {\r\n        get: function () {\r\n          return scrollBoxHeight;\r\n        },\r\n        set: function (value) {\r\n          scrollBoxHeight = value;\r\n        }\r\n      });\r\n      Object.defineProperty(self.scrollBox, 'scrollBoxWidth', {\r\n        get: function () {\r\n          return scrollBoxWidth;\r\n        },\r\n        set: function (value) {\r\n          scrollBoxWidth = value;\r\n        }\r\n      });\r\n      Object.defineProperty(self.scrollBox, 'height', {\r\n        get: function () {\r\n          return sHeight;\r\n        },\r\n        set: function (value) {\r\n          sHeight = value;\r\n        }\r\n      });\r\n      Object.defineProperty(self.scrollBox, 'width', {\r\n        get: function () {\r\n          return sWidth;\r\n        },\r\n        set: function (value) {\r\n          sWidth = value;\r\n        }\r\n      });\r\n      Object.defineProperty(self.scrollBox, 'scrollTop', {\r\n        get: function () {\r\n          return scrollTop;\r\n        },\r\n        set: setScrollTop\r\n      });\r\n      Object.defineProperty(self.scrollBox, 'scrollLeft', {\r\n        get: function () {\r\n          return scrollLeft;\r\n        },\r\n        set: setScrollLeft\r\n      });\r\n      Object.defineProperty(self.scrollBox, 'scrollHeight', {\r\n        get: function () {\r\n          return scrollHeight;\r\n        },\r\n        set: function (value) {\r\n          if (scrollTop > value) {\r\n            scrollTop = Math.max(value, 0);\r\n          }\r\n          scrollHeight = value;\r\n        }\r\n      });\r\n      Object.defineProperty(self.scrollBox, 'scrollWidth', {\r\n        get: function () {\r\n          return scrollWidth;\r\n        },\r\n        set: function (value) {\r\n          if (scrollLeft > value) {\r\n            scrollLeft = Math.max(value, 0);\r\n          }\r\n          scrollWidth = value;\r\n        }\r\n      });\r\n    };\r\n    return;\r\n  };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/intf.js\n// module id = 6\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false, Event: false*/\r\ndefine([], function () {\r\n    'use strict';\r\n    return function (self) {\r\n        var zIndexTop, hoverScrollTimeout, autoCompleteContext;\r\n        function applyContextItemStyle(contextItemContainer) {\r\n            self.createInlineStyle(contextItemContainer, 'canvas-datagrid-context-menu-item' + (self.mobile ? '-mobile' : ''));\r\n            contextItemContainer.addEventListener('mouseover', function () {\r\n                self.createInlineStyle(contextItemContainer, 'canvas-datagrid-context-menu-item:hover');\r\n            });\r\n            contextItemContainer.addEventListener('mouseout', function () {\r\n                self.createInlineStyle(contextItemContainer, 'canvas-datagrid-context-menu-item');\r\n            });\r\n        }\r\n        function createContextMenu(ev, pos, items, parentContextMenu) {\r\n            var container = document.createElement('div'),\r\n                upArrow = document.createElement('div'),\r\n                downArrow = document.createElement('div'),\r\n                children = [],\r\n                selectedIndex = -1,\r\n                intf = {},\r\n                rect;\r\n            if (!Array.isArray(items)) { throw new Error('createContextMenu expects an array.'); }\r\n            function createItems() {\r\n                items.forEach(function (item) {\r\n                    var contextItemContainer = document.createElement('div'),\r\n                        childMenuArrow;\r\n                    function removeChildContext(e) {\r\n                        if (e.relatedTarget === container\r\n                                || item.contextMenu.container === e.relatedTarget\r\n                                || childMenuArrow === e.relatedTarget\r\n                                || (contextItemContainer === e.relatedTarget)\r\n                                || item.contextMenu.container.contains(e.relatedTarget)\r\n                                ) { return; }\r\n                        item.contextMenu.dispose();\r\n                        children.splice(children.indexOf(item.contextMenu), 1);\r\n                        item.contextMenu = undefined;\r\n                        contextItemContainer.removeEventListener('mouseout', removeChildContext);\r\n                        container.removeEventListener('mouseout', removeChildContext);\r\n                        contextItemContainer.setAttribute('contextOpen', '0');\r\n                        contextItemContainer.setAttribute('opening', '0');\r\n                    }\r\n                    function contextAddCallback(items) {\r\n                        // check yet again if the user hasn't moved off\r\n                        if (contextItemContainer.getAttribute('opening') !== '1' ||\r\n                                contextItemContainer.getAttribute('contextOpen') === '1') {\r\n                            return;\r\n                        }\r\n                        var cPos = contextItemContainer.getBoundingClientRect();\r\n                        cPos = {\r\n                            left: cPos.left + self.style.childContextMenuMarginLeft + container.offsetWidth,\r\n                            top: cPos.top + self.style.childContextMenuMarginTop,\r\n                            bottom: cPos.bottom,\r\n                            right: cPos.right\r\n                        };\r\n                        item.contextMenu = createContextMenu(ev, cPos, items, intf);\r\n                        contextItemContainer.setAttribute('contextOpen', '1');\r\n                        contextItemContainer.addEventListener('mouseout', removeChildContext);\r\n                        container.addEventListener('mouseout', removeChildContext);\r\n                        children.push(item.contextMenu);\r\n                    }\r\n                    function createChildContext() {\r\n                        var i;\r\n                        if (contextItemContainer.getAttribute('contextOpen') === '1') {\r\n                            return;\r\n                        }\r\n                        contextItemContainer.setAttribute('opening', '1');\r\n                        if (typeof item.items === 'function') {\r\n                            i  = item.items.apply(intf, [function (items) {\r\n                                contextAddCallback(items);\r\n                            }]);\r\n                            if (i !== undefined && Array.isArray(i)) {\r\n                                contextAddCallback(i);\r\n                            }\r\n                            return;\r\n                        }\r\n                        contextAddCallback(item.items);\r\n                    }\r\n                    function addItem(item) {\r\n                        function addContent(content) {\r\n                            if (content === null) { return; }\r\n                            if (typeof content === 'function') {\r\n                                return addContent(content(ev));\r\n                            }\r\n                            if (typeof content === 'object') {\r\n                                contextItemContainer.appendChild(content);\r\n                                return;\r\n                            }\r\n                            applyContextItemStyle(contextItemContainer);\r\n                            contextItemContainer.innerHTML = content;\r\n                            return;\r\n                        }\r\n                        addContent(item.title);\r\n                        item.contextItemContainer = contextItemContainer;\r\n                        if ((item.items && item.items.length > 0) || typeof item.items === 'function') {\r\n                            childMenuArrow = document.createElement('div');\r\n                            self.createInlineStyle(childMenuArrow, 'canvas-datagrid-context-child-arrow');\r\n                            childMenuArrow.innerHTML = self.style.childContextMenuArrowHTML;\r\n                            contextItemContainer.appendChild(childMenuArrow);\r\n                            contextItemContainer.addEventListener('mouseover', createChildContext);\r\n                            contextItemContainer.addEventListener('mouseout', function () {\r\n                                contextItemContainer.setAttribute('opening', '0');\r\n                            });\r\n                        }\r\n                        if (item.click) {\r\n                            contextItemContainer.addEventListener('click', function (ev) {\r\n                                item.click.apply(self, [ev]);\r\n                            });\r\n                        }\r\n                    }\r\n                    addItem(item);\r\n                    container.appendChild(contextItemContainer);\r\n                });\r\n            }\r\n            function clickIndex(idx) {\r\n                items[idx].contextItemContainer.dispatchEvent(new Event('click'));\r\n            }\r\n            function checkArrowVisibility() {\r\n                if (container.scrollTop > 0) {\r\n                    self.parentDOMNode.appendChild(upArrow);\r\n                } else if (upArrow.parentNode) {\r\n                    upArrow.parentNode.removeChild(upArrow);\r\n                }\r\n                if (container.scrollTop >= container.scrollHeight - container.offsetHeight && downArrow.parentNode) {\r\n                    downArrow.parentNode.removeChild(downArrow);\r\n                } else if (container.scrollHeight - container.offsetHeight > 0\r\n                        && !(container.scrollTop >= container.scrollHeight - container.offsetHeight)) {\r\n                    self.parentDOMNode.appendChild(downArrow);\r\n                }\r\n            }\r\n            function startHoverScroll(type) {\r\n                return function t() {\r\n                    var a = self.attributes.contextHoverScrollAmount;\r\n                    if (type === 'up' && container.scrollTop === 0) { return; }\r\n                    if (type === 'down' && container.scrollTop === container.scrollHeight) { return; }\r\n                    container.scrollTop += (type === 'up' ? -a : a);\r\n                    hoverScrollTimeout = setTimeout(t, self.attributes.contextHoverScrollRateMs, type);\r\n                };\r\n            }\r\n            function endHoverScroll(type) {\r\n                return function () {\r\n                    clearTimeout(hoverScrollTimeout);\r\n                };\r\n            }\r\n            function init() {\r\n                var loc = {},\r\n                    s = self.scrollOffset(self.canvas);\r\n                if (zIndexTop === undefined) {\r\n                    zIndexTop = self.style.contextMenuZIndex;\r\n                }\r\n                createItems();\r\n                self.createInlineStyle(container, 'canvas-datagrid-context-menu' + (self.mobile ? '-mobile' : ''));\r\n                loc.x = pos.left - s.left;\r\n                loc.y = pos.top - s.top;\r\n                loc.height = 0;\r\n                zIndexTop += 1;\r\n                container.style.position = 'absolute';\r\n                upArrow.style.color = self.style.contextMenuArrowColor;\r\n                downArrow.style.color = self.style.contextMenuArrowColor;\r\n                [upArrow, downArrow].forEach(function (el) {\r\n                    el.style.textAlign = 'center';\r\n                    el.style.position = 'absolute';\r\n                    el.style.zIndex = zIndexTop + 1;\r\n                });\r\n                container.style.zIndex = zIndexTop;\r\n                if (parentContextMenu && parentContextMenu.inputDropdown) {\r\n                    container.style.maxHeight = window.innerHeight - loc.y - self.style.autocompleteBottomMargin + 'px';\r\n                    container.style.minWidth = pos.width + 'px';\r\n                    loc.y += pos.height;\r\n                }\r\n                if (self.mobile) {\r\n                    container.style.width = pos.width + 'px';\r\n                }\r\n                container.style.left = loc.x + 'px';\r\n                container.style.top = loc.y + 'px';\r\n                container.addEventListener('scroll', checkArrowVisibility);\r\n                container.addEventListener('wheel', function (e) {\r\n                    if (self.hasFocus) {\r\n                        container.scrollTop += e.deltaY;\r\n                        container.scrollLeft += e.deltaX;\r\n                    }\r\n                    checkArrowVisibility();\r\n                });\r\n                upArrow.innerHTML = self.style.contextMenuArrowUpHTML;\r\n                downArrow.innerHTML = self.style.contextMenuArrowDownHTML;\r\n                container.appendChild(upArrow);\r\n                document.body.appendChild(downArrow);\r\n                document.body.appendChild(container);\r\n                rect = container.getBoundingClientRect();\r\n                // TODO: fix !(parentContextMenu && parentContextMenu.inputDropdown) state (autocomplete)\r\n                if (rect.bottom > window.innerHeight) {\r\n                    if (!(parentContextMenu && parentContextMenu.inputDropdown)) {\r\n                        loc.y -= (rect.bottom + self.style.contextMenuWindowMargin) - window.innerHeight;\r\n                    }\r\n                    if (loc.y < 0) { loc.y = self.style.contextMenuWindowMargin; }\r\n                    if (container.offsetHeight > window.innerHeight - self.style.contextMenuWindowMargin) {\r\n                        container.style.height = window.innerHeight - (self.style.contextMenuWindowMargin * 2) + 'px';\r\n                    }\r\n                }\r\n                if (rect.right > window.innerWidth) {\r\n                    loc.x -= rect.right - window.innerWidth + self.style.contextMenuWindowMargin;\r\n                }\r\n                if (loc.x < 0) { loc.x = self.style.contextMenuWindowMargin; }\r\n                if (loc.y < 0) { loc.y = self.style.contextMenuWindowMargin; }\r\n                container.style.left = loc.x + 'px';\r\n                container.style.top = loc.y + 'px';\r\n                rect = container.getBoundingClientRect();\r\n                upArrow.style.top = rect.top + 'px';\r\n                downArrow.style.top = rect.top + rect.height - downArrow.offsetHeight + 'px';\r\n                upArrow.style.left = rect.left + 'px';\r\n                downArrow.style.left = rect.left + 'px';\r\n                downArrow.style.width = container.offsetWidth + 'px';\r\n                upArrow.style.width = container.offsetWidth + 'px';\r\n                downArrow.addEventListener('mouseover', startHoverScroll('down'));\r\n                downArrow.addEventListener('mouseout', endHoverScroll('down'));\r\n                upArrow.addEventListener('mouseover', startHoverScroll('up'));\r\n                upArrow.addEventListener('mouseout', endHoverScroll('up'));\r\n                checkArrowVisibility();\r\n            }\r\n            intf.parentGrid = self.intf;\r\n            intf.parentContextMenu = parentContextMenu;\r\n            intf.container = container;\r\n            init();\r\n            intf.clickIndex = clickIndex;\r\n            intf.rect = rect;\r\n            intf.items = items;\r\n            intf.upArrow = upArrow;\r\n            intf.downArrow = downArrow;\r\n            intf.dispose = function () {\r\n                clearTimeout(hoverScrollTimeout);\r\n                children.forEach(function (c) {\r\n                    c.dispose();\r\n                });\r\n                [downArrow, upArrow, container].forEach(function (el) {\r\n                    if (el.parentNode) { el.parentNode.removeChild(el); }\r\n                });\r\n            };\r\n            Object.defineProperty(intf, 'selectedIndex', {\r\n                get: function () {\r\n                    return selectedIndex;\r\n                },\r\n                set: function (value) {\r\n                    if (typeof value !== 'number' || isNaN(value || !isFinite(value))) {\r\n                        throw new Error('Context menu selected index must be a sane number.');\r\n                    }\r\n                    selectedIndex = value;\r\n                    if (selectedIndex > items.length - 1) {\r\n                        selectedIndex = items.length - 1;\r\n                    }\r\n                    if (selectedIndex < 0) {\r\n                        selectedIndex = 0;\r\n                    }\r\n                    items.forEach(function (item, index) {\r\n                        if (index === selectedIndex) {\r\n                            return self.createInlineStyle(item.contextItemContainer, 'canvas-datagrid-context-menu-item:hover');\r\n                        }\r\n                        self.createInlineStyle(item.contextItemContainer, 'canvas-datagrid-context-menu-item');\r\n                    });\r\n                }\r\n            });\r\n            return intf;\r\n        }\r\n        function createFilterContextMenuItems(e) {\r\n            var filterContainer = document.createElement('div'),\r\n                filterLabel = document.createElement('div'),\r\n                filterAutoCompleteButton = document.createElement('button'),\r\n                filterInput = document.createElement('input'),\r\n                n = e.cell && e.cell.header ? e.cell.header.title || e.cell.header.name : '',\r\n                autoCompleteItems,\r\n                iRect;\r\n            function checkRegExpErrorState() {\r\n                filterInput.style.background = self.style.contextFilterInputBackground;\r\n                filterInput.style.color = self.style.contextFilterInputColor;\r\n                if (self.invalidFilterRegEx) {\r\n                    filterInput.style.background = self.style.contextFilterInvalidRegExpBackground;\r\n                    filterInput.style.color = self.style.contextFilterInvalidRegExpColor;\r\n                }\r\n            }\r\n            function fillAutoComplete() {\r\n                var count = 0;\r\n                autoCompleteItems = {};\r\n                self.data.forEach(function (row) {\r\n                    var value = row[e.cell.header.name];\r\n                    if (autoCompleteItems[value] || count > self.attributes.maxAutoCompleteItems) { return; }\r\n                    count += 1;\r\n                    autoCompleteItems[value] = {\r\n                        title: self.formatters[e.cell.header.type || 'string']({ cell: { value: value }}),\r\n                        click: function (e) {\r\n                            filterInput.value = value;\r\n                            e.stopPropagation();\r\n                            filterInput.dispatchEvent(new Event('keyup'));\r\n                            self.disposeAutocomplete();\r\n                            return;\r\n                        }\r\n                    };\r\n                });\r\n                autoCompleteItems = Object.keys(autoCompleteItems).map(function (key) {\r\n                    return autoCompleteItems[key];\r\n                });\r\n            }\r\n            function createAutoCompleteContext(ev) {\r\n                if (ev && [40, 38, 13, 9].indexOf(ev.keyCode) !== -1) { return; }\r\n                fillAutoComplete();\r\n                iRect = filterInput.getBoundingClientRect();\r\n                if (autoCompleteContext) {\r\n                    autoCompleteContext.dispose();\r\n                    autoCompleteContext = undefined;\r\n                }\r\n                autoCompleteContext = createContextMenu(e, {\r\n                    left: iRect.left,\r\n                    top: iRect.top,\r\n                    right: iRect.right,\r\n                    bottom: iRect.bottom,\r\n                    height: iRect.height,\r\n                    width: iRect.width\r\n                }, autoCompleteItems, {inputDropdown: true});\r\n                autoCompleteContext.selectedIndex = 0;\r\n            }\r\n            self.createInlineStyle(filterLabel, 'canvas-datagrid-context-menu-label');\r\n            self.createInlineStyle(filterAutoCompleteButton, 'canvas-datagrid-context-menu-filter-button');\r\n            self.createInlineStyle(filterInput, 'canvas-datagrid-context-menu-filter-input');\r\n            checkRegExpErrorState();\r\n            filterInput.onclick = self.disposeAutocomplete;\r\n            filterInput.addEventListener('keydown', function (e) {\r\n                //down\r\n                if (e.keyCode === 40) {\r\n                    autoCompleteContext.selectedIndex += 1;\r\n                }\r\n                //up\r\n                if (e.keyCode === 38) {\r\n                    autoCompleteContext.selectedIndex -= 1;\r\n                }\r\n                //enter\r\n                if (e.keyCode === 13) {\r\n                    autoCompleteContext.clickIndex(autoCompleteContext.selectedIndex);\r\n                    self.disposeContextMenu();\r\n                }\r\n                //tab\r\n                if (e.keyCode === 9) {\r\n                    autoCompleteContext.clickIndex(autoCompleteContext.selectedIndex);\r\n                    e.preventDefault();\r\n                }\r\n                //esc\r\n                if (e.keyCode === 27) {\r\n                    self.disposeContextMenu();\r\n                }\r\n            });\r\n            filterInput.addEventListener('keyup', function () {\r\n                self.setFilter(e.cell.header.name, filterInput.value);\r\n            });\r\n            filterInput.addEventListener('keyup', createAutoCompleteContext);\r\n            ['focus', 'blur', 'keydown', 'keyup', 'change'].forEach(function (en) {\r\n                filterInput.addEventListener(en, checkRegExpErrorState);\r\n            });\r\n            filterInput.value = e.cell.header ? self.columnFilters[e.cell.header.name] || '' : '';\r\n            filterLabel.innerHTML = self.attributes.filterOptionText.replace(/%s/g, n);\r\n            filterAutoCompleteButton.onclick = function () {\r\n                if (autoCompleteContext) {\r\n                    return self.disposeAutocomplete();\r\n                }\r\n                createAutoCompleteContext();\r\n            };\r\n            filterAutoCompleteButton.innerHTML = self.style.contextFilterButtonHTML;\r\n            filterContainer.addEventListener('click', function (e) {\r\n                return e.stopPropagation();\r\n            });\r\n            filterContainer.appendChild(filterLabel);\r\n            filterContainer.appendChild(filterInput);\r\n            filterContainer.appendChild(filterAutoCompleteButton);\r\n            e.items.push({\r\n                title: filterContainer\r\n            });\r\n            if (Object.keys(self.columnFilters).length) {\r\n                Object.keys(self.columnFilters).forEach(function (cf) {\r\n                    var h = self.getHeaderByName(cf);\r\n                    e.items.push({\r\n                        title: self.attributes.removeFilterOptionText.replace(/%s/g, h.title || h.name),\r\n                        click: function removeFilterClick(e) {\r\n                            e.preventDefault();\r\n                            self.setFilter(cf, '');\r\n                            self.controlInput.focus();\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n        }\r\n        function addDefaultContextMenuItem(e) {\r\n            var isNormalCell = !(e.cell.isBackground || e.cell.isColumnHeaderCellCap\r\n                    || e.cell.isScrollBar || e.cell.isCorner || e.cell.isRowHeader)\r\n                    && e.cell.header;\r\n            if (self.attributes.showFilter && isNormalCell) {\r\n                createFilterContextMenuItems(e);\r\n            }\r\n            if (self.attributes.showCopy\r\n                    && self.selections.reduce(function (p, r) {\r\n                        return p + r.length;\r\n                    }, 0) > 0) {\r\n                e.items.push({\r\n                    title: self.attributes.copyText,\r\n                    click: function () {\r\n                        document.execCommand('copy');\r\n                        self.disposeContextMenu();\r\n                        self.controlInput.focus();\r\n                    }\r\n                });\r\n            }\r\n            if (self.attributes.showPaste && self.clipBoardData) {\r\n                e.items.push({\r\n                    title: self.attributes.pasteText,\r\n                    click: function () {\r\n                        self.paste(self.clipBoardData, e.cell.columnIndex, e.cell.rowIndex);\r\n                        self.draw();\r\n                    }\r\n                });\r\n            }\r\n            if (self.attributes.showColumnSelector) {\r\n                e.items.push({\r\n                    title: self.attributes.columnSelectorText,\r\n                    items: function () {\r\n                        var d = [];\r\n                        self.getSchema().forEach(function (column) {\r\n                            function toggleColumnVisibility(e) {\r\n                                column.hidden = !column.hidden;\r\n                                self.dispatchEvent('togglecolumn', {column: column, hidden: column.hidden});\r\n                                e.preventDefault();\r\n                                self.stopPropagation(e);\r\n                                self.disposeContextMenu();\r\n                                self.resize(true);\r\n                                self.setStorageData();\r\n                            }\r\n                            var el = document.createElement('div');\r\n                            applyContextItemStyle(el);\r\n                            el.addEventListener('touchstart', toggleColumnVisibility);\r\n                            el.addEventListener('click', toggleColumnVisibility);\r\n                            el.innerHTML = (column.hidden ? self.attributes.columnSelectorHiddenText\r\n                                    : self.attributes.columnSelectorVisibleText)\r\n                                    + (column.title || column.name);\r\n                            d.push({\r\n                                title: el\r\n                            });\r\n                        });\r\n                        return d;\r\n                    }\r\n                });\r\n                if (e.cell && e.cell.header && e.cell.columnIndex > -1) {\r\n                    e.items.push({\r\n                        title: self.attributes.hideColumnText\r\n                            .replace(/%s/ig, e.cell.header.title || e.cell.header.name),\r\n                        click: function (ev) {\r\n                            self.getSchema()[e.cell.columnIndex].hidden = true;\r\n                            ev.preventDefault();\r\n                            self.stopPropagation(ev);\r\n                            self.disposeContextMenu();\r\n                            self.setStorageData();\r\n                            setTimeout(function () { self.resize(true); }, 10);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            if (self.attributes.saveAppearance && self.attributes.showClearSettingsOption\r\n                    && (Object.keys(self.sizes.rows).length > 0\r\n                        || Object.keys(self.sizes.columns).length > 0)) {\r\n                e.items.push({\r\n                    title: self.attributes.clearSettingsOptionText,\r\n                    click: function (e) {\r\n                        e.preventDefault();\r\n                        self.sizes.rows = {};\r\n                        self.sizes.columns = {};\r\n                        self.createRowOrders();\r\n                        self.createColumnOrders();\r\n                        self.storedSettings = undefined;\r\n                        self.dispatchEvent('resizecolumn', {columnWidth: self.style.cellWidth});\r\n                        self.dispatchEvent('resizerow', {cellHeight: self.style.cellHeight});\r\n                        self.setStorageData();\r\n                        self.resize(true);\r\n                        self.disposeContextMenu();\r\n                        self.controlInput.focus();\r\n                    }\r\n                });\r\n            }\r\n            if (self.attributes.allowSorting && self.attributes.showOrderByOption && isNormalCell) {\r\n                e.items.push({\r\n                    title: self.attributes.showOrderByOptionTextAsc.replace('%s', e.cell.header.title || e.cell.header.name),\r\n                    click: function (ev) {\r\n                        ev.preventDefault();\r\n                        self.order(e.cell.header.name, 'asc');\r\n                        self.controlInput.focus();\r\n                    }\r\n                });\r\n                e.items.push({\r\n                    title: self.attributes.showOrderByOptionTextDesc.replace('%s', e.cell.header.title || e.cell.header.name),\r\n                    click: function (ev) {\r\n                        ev.preventDefault();\r\n                        self.order(e.cell.header.name, 'desc');\r\n                        self.disposeContextMenu();\r\n                        self.controlInput.focus();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        self.disposeAutocomplete = function () {\r\n            if (autoCompleteContext) {\r\n                autoCompleteContext.dispose();\r\n                autoCompleteContext = undefined;\r\n            }\r\n        };\r\n        self.disposeContextMenu = function () {\r\n            document.removeEventListener('click', self.disposeContextMenu);\r\n            zIndexTop = self.style.contextMenuZIndex;\r\n            self.disposeAutocomplete();\r\n            if (self.contextMenu) {\r\n                self.contextMenu.dispose();\r\n            }\r\n            self.contextMenu = undefined;\r\n        };\r\n        self.contextmenuEvent = function (e, overridePos) {\r\n            if (!self.hasFocus && e.target !== self.canvas) {\r\n                return;\r\n            }\r\n            function createDiposeEvent() {\r\n                requestAnimationFrame(function () {\r\n                    document.addEventListener('click', self.disposeContextMenu);\r\n                    document.removeEventListener('mouseup', createDiposeEvent);\r\n                });\r\n            }\r\n            var contextPosition,\r\n                items = [],\r\n                pos = overridePos || self.getLayerPos(e),\r\n                ev = {\r\n                    NativeEvent: e,\r\n                    cell: self.getCellAt(pos.x, pos.y),\r\n                    items: items\r\n                };\r\n            if (!ev.cell.isGrid) {\r\n                addDefaultContextMenuItem(ev);\r\n            }\r\n            if (self.dispatchEvent('contextmenu', ev)) {\r\n                return;\r\n            }\r\n            if (!ev.cell.isGrid) {\r\n                if (self.contextMenu) {\r\n                    self.disposeContextMenu();\r\n                }\r\n                contextPosition = {\r\n                    left: pos.x + pos.rect.left\r\n                        + self.style.contextMenuMarginLeft + self.canvasOffsetLeft,\r\n                    top: pos.y + pos.rect.top\r\n                        + self.style.contextMenuMarginTop + self.canvasOffsetTop,\r\n                    right: ev.cell.width + ev.cell.x + pos.rect.left,\r\n                    bottom: ev.cell.height + ev.cell.y + pos.rect.top,\r\n                    height: ev.cell.height,\r\n                    width: ev.cell.width\r\n                };\r\n                if (self.mobile) {\r\n                    contextPosition.left = self.style.mobileContextMenuMargin + 'px';\r\n                    contextPosition.width = self.width - (self.style.mobileContextMenuMargin * 2) + 'px';\r\n                }\r\n                self.contextMenu = createContextMenu(ev, contextPosition, items);\r\n                document.addEventListener('mouseup', createDiposeEvent);\r\n                e.preventDefault();\r\n            }\r\n        };\r\n        return;\r\n    };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/contextMenu.js\n// module id = 7\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine([], function () {\r\n    'use strict';\r\n    return function (self) {\r\n        self.getClippingRect = function (ele) {\r\n            var boundingRect = self.position(self.parentNode),\r\n                eleRect = self.position(ele),\r\n                s = self.scrollOffset(self.canvas),\r\n                clipRect = {\r\n                    x: 0,\r\n                    y: 0,\r\n                    h: 0,\r\n                    w: 0\r\n                },\r\n                parentRect = {\r\n                    x: -Infinity,\r\n                    y: -Infinity,\r\n                    h: Infinity,\r\n                    w: Infinity\r\n                },\r\n                columnHeaderCellHeight = self.getColumnHeaderCellHeight(),\r\n                rowHeaderCellWidth = self.getRowHeaderCellWidth();\r\n            boundingRect.top -= s.top;\r\n            boundingRect.left -= s.left;\r\n            eleRect.top -= s.top;\r\n            eleRect.left -= s.left;\r\n            clipRect.h = boundingRect.top + boundingRect.height - ele.offsetTop - self.style.scrollBarWidth;\r\n            clipRect.w = boundingRect.left + boundingRect.width - ele.offsetLeft - self.style.scrollBarWidth;\r\n            clipRect.x = boundingRect.left + (eleRect.left * -1) + rowHeaderCellWidth;\r\n            clipRect.y = boundingRect.top + (eleRect.top * -1) + columnHeaderCellHeight;\r\n            return {\r\n                x: clipRect.x > parentRect.x ? clipRect.x : parentRect.x,\r\n                y: clipRect.y > parentRect.y ? clipRect.y : parentRect.y,\r\n                h: clipRect.h < parentRect.h ? clipRect.h : parentRect.h,\r\n                w: clipRect.w < parentRect.w ? clipRect.w : parentRect.w\r\n            };\r\n        };\r\n        self.clipElement = function (ele) {\r\n            var clipRect = self.getClippingRect(ele);\r\n            if (clipRect.w < 0) { clipRect.w = 0; }\r\n            if (clipRect.h < 0) { clipRect.h = 0; }\r\n            ele.style.clip = 'rect('\r\n                + clipRect.y + 'px,'\r\n                + clipRect.w + 'px,'\r\n                + clipRect.h + 'px,'\r\n                + clipRect.x + 'px'\r\n                + ')';\r\n            // INFO https://developer.mozilla.org/en-US/docs/Web/CSS/clip\r\n            // clip has been \"deprecated\" for clipPath.  Of course nothing but chrome\r\n            // supports clip path, so we'll keep using clip until someday clipPath becomes\r\n            // more widely support.  The code below works correctly, but setting clipPath and clip\r\n            // at the same time has undesirable results.\r\n            // ele.style.clipPath = 'polygon('\r\n            //     + clipRect.x + 'px ' + clipRect.y + 'px,'\r\n            //     + clipRect.x + 'px ' + clipRect.h + 'px,'\r\n            //     + clipRect.w + 'px ' + clipRect.h + 'px,'\r\n            //     + clipRect.w + 'px ' + clipRect.y + 'px'\r\n            //     + ')';\r\n        };\r\n        self.scrollOffset = function (e) {\r\n            var x = 0, y = 0, scrollingElement = document.scrollingElement || { scrollLeft: 0, scrollTop: 0 };\r\n            while (e.parentNode && e.nodeName !== 'CANVAS-DATAGRID' && e !== self.intf) {\r\n                if (e.nodeType !== 'canvas-datagrid-tree'\r\n                        && e.nodeType !== 'canvas-datagrid-cell') {\r\n                    x -= e.scrollLeft;\r\n                    y -= e.scrollTop;\r\n                }\r\n                e = e.parentNode;\r\n            }\r\n            return {\r\n                left: x - scrollingElement.scrollLeft,\r\n                top: y - scrollingElement.scrollTop\r\n            };\r\n        };\r\n        self.resizeEditInput = function () {\r\n            if (self.input && self.input.editCell) {\r\n                var pos = self.canvas.getBoundingClientRect(),\r\n                    s = self.scrollOffset(self.intf),\r\n                    bm = self.style.gridBorderCollapse === 'collapse' ? 1 : 2,\r\n                    borderWidth = (self.style.cellBorderWidth * bm),\r\n                    cell = self.getVisibleCellByIndex(self.input.editCell.columnIndex, self.input.editCell.rowIndex)\r\n                        || {x: -100, y: -100, height: 0, width: 0};\r\n                if (self.mobile) {\r\n                    self.input.style.left = '0';\r\n                    self.input.style.top = (self.height - self.style.mobileEditInputHeight) - borderWidth - 1 + 'px';\r\n                    self.input.style.height = self.style.mobileEditInputHeight + 'px';\r\n                    self.input.style.width = self.width - borderWidth - 1 + 'px';\r\n                    return;\r\n                }\r\n                self.input.style.left = pos.left + cell.x + self.canvasOffsetLeft - s.left + 'px';\r\n                self.input.style.top = pos.top + cell.y - self.style.cellBorderWidth + self.canvasOffsetTop - s.top + 'px';\r\n                self.input.style.height = cell.height - borderWidth + 'px';\r\n                self.input.style.width = cell.width - self.style.cellPaddingLeft + 'px';\r\n                self.clipElement(self.input);\r\n            }\r\n        };\r\n        self.position = function (e, ignoreScrollOffset) {\r\n            var x = 0, y = 0, s = e, h, w;\r\n            while (e.offsetParent && e.nodeName !== 'CANVAS-DATAGRID') {\r\n                x += e.offsetLeft;\r\n                y += e.offsetTop;\r\n                h = e.offsetHeight;\r\n                w = e.offsetWidth;\r\n                e = e.offsetParent;\r\n            }\r\n            if (ignoreScrollOffset) {\r\n                return {left: x, top: y, height: h, width: w};\r\n            }\r\n            e = s;\r\n            s = self.scrollOffset(e);\r\n            return { left: x + s.left, top: y + s.top, height: h, width: w };\r\n        };\r\n        self.getLayerPos = function (e) {\r\n            var rect = self.canvas.getBoundingClientRect(),\r\n                pos = {\r\n                    x: e.clientX - rect.left,\r\n                    y: e.clientY - rect.top\r\n                };\r\n            if (self.isChildGrid) {\r\n                pos.x -= self.canvasOffsetLeft;\r\n                pos.y -= self.canvasOffsetTop;\r\n            }\r\n            return {\r\n                x: pos.x,\r\n                y: pos.y,\r\n                rect: rect\r\n            };\r\n        };\r\n        /**\r\n         * Ends editing, optionally aborting the edit.\r\n         * @memberof canvasDatagrid\r\n         * @name endEdit\r\n         * @method\r\n         * @param {boolean} abort When true, abort the edit.\r\n         */\r\n        self.endEdit = function (abort) {\r\n            var cell = self.input.editCell,\r\n                y = cell.rowIndex;\r\n            function abortEdit() {\r\n                abort = true;\r\n            }\r\n            if (self.dispatchEvent('beforeendedit', {\r\n                    cell: cell,\r\n                    newValue: self.input.value,\r\n                    oldValue: cell.value,\r\n                    abort: abortEdit,\r\n                    input: self.input\r\n                })) { return false; }\r\n            if (self.input.value !== cell.value && !abort) {\r\n                self.changes[y] = self.changes[y] || {};\r\n                self.changes[y][cell.header.name] = self.input.value;\r\n                if (!cell.data) {\r\n                    self.data[cell.rowIndex] = {};\r\n                    cell.data = self.data[cell.rowIndex];\r\n                }\r\n                cell.data[cell.header.name] = self.input.value;\r\n                if (y === self.data.length) {\r\n                    if (self.dispatchEvent('newrow', {\r\n                            value: self.input.value,\r\n                            defaultValue: cell.value,\r\n                            aborted: abort,\r\n                            cell: cell,\r\n                            input: self.input\r\n                        })) { return false; }\r\n                    self.addRow(cell.data);\r\n                    self.createNewRowData();\r\n                }\r\n                self.draw(true);\r\n            }\r\n            if (self.input.parentNode) {\r\n                self.input.parentNode.removeChild(self.input);\r\n            }\r\n            self.intf.focus();\r\n            self.dispatchEvent('endedit', {\r\n                cell: cell,\r\n                value: self.input.value,\r\n                aborted: abort,\r\n                input: self.input\r\n            });\r\n            self.input = undefined;\r\n            return true;\r\n        };\r\n        /**\r\n         * Begins editing at cell x, row y.\r\n         * @memberof canvasDatagrid\r\n         * @name beginEditAt\r\n         * @method\r\n         * @param {number} x The column index of the cell to edit.\r\n         * @param {number} y The row index of the cell to edit.\r\n         */\r\n        self.beginEditAt = function (x, y, NativeEvent) {\r\n            if (!self.attributes.editable) { return; }\r\n            if (self.input) {\r\n                self.endEdit();\r\n            }\r\n            var cell = self.getVisibleCellByIndex(x, y),\r\n                s = self.getSchema(),\r\n                adjacentCells,\r\n                enumItems,\r\n                enu,\r\n                option,\r\n                valueInEnum;\r\n            if (!(cell && cell.header)) { return; }\r\n            //HACK for IE10, does not like literal enum\r\n            enu = cell.header['enum'];\r\n            if (self.dispatchEvent('beforebeginedit', {cell: cell, NativeEvent: NativeEvent})) { return false; }\r\n            self.scrollIntoView(x, y);\r\n            self.setActiveCell(x, y);\r\n            adjacentCells = self.getAdjacentCells();\r\n            if (enu) {\r\n                self.input = document.createElement('select');\r\n            } else {\r\n                self.input = document.createElement(self.attributes.multiLine\r\n                    ? 'textarea' : 'input');\r\n            }\r\n            cell = self.getVisibleCellByIndex(x, y);\r\n            //HACK on mobile devices sometimes edit can begin without the cell being in view, I don't know how.\r\n            if (!cell) { return; }\r\n            if (enu) {\r\n                // add enums\r\n                if (typeof enu === 'function') {\r\n                    enumItems = enu.apply(self.intf, [{cell: cell}]);\r\n                } else if (Array.isArray(enu)) {\r\n                    enumItems = enu;\r\n                }\r\n                enumItems.forEach(function (e) {\r\n                    var i = document.createElement('option'),\r\n                        val,\r\n                        title;\r\n                    if (Array.isArray(e)) {\r\n                        val = e[0];\r\n                        title = e[1];\r\n                    } else {\r\n                        val = e;\r\n                        title = e;\r\n                    }\r\n                    if (val === cell.value) { valueInEnum = true; }\r\n                    i.value = val;\r\n                    i.innerHTML = title;\r\n                    self.input.appendChild(i);\r\n                });\r\n                if (!valueInEnum) {\r\n                    option = document.createElement('option');\r\n                    option.value = cell.value;\r\n                    option.innerHTML = cell.value;\r\n                    self.input.appendChild(option);\r\n                }\r\n                self.input.addEventListener('change', function () {\r\n                    self.endEdit();\r\n                    self.draw(true);\r\n                });\r\n            }\r\n            // if the user has not prevented the default action, append to the body\r\n            if (!self.dispatchEvent('appendeditinput', {cell: cell, input:self.input})) { \r\n                document.body.appendChild(self.input);\r\n            }\r\n            self.createInlineStyle(self.input, self.mobile ? 'canvas-datagrid-edit-mobile-input' : 'canvas-datagrid-edit-input');\r\n            self.input.style.position = 'absolute';\r\n            self.input.editCell = cell;\r\n            self.resizeEditInput();\r\n            self.input.style.zIndex = self.style.editCellZIndex;\r\n            self.input.style.fontSize = (parseInt(self.style.editCellFontSize, 10) * self.scale) + 'px';\r\n            self.input.value = [null, undefined].indexOf(cell.value) !== -1 ? '' : cell.value;\r\n            self.input.focus();\r\n            self.input.addEventListener('click', self.stopPropagation);\r\n            self.input.addEventListener('dblclick', self.stopPropagation);\r\n            self.input.addEventListener('mouseup', self.stopPropagation);\r\n            self.input.addEventListener('mousedown', self.stopPropagation);\r\n            self.input.addEventListener('keydown', function (e) {\r\n                var nx = cell.columnIndex,\r\n                    ny = cell.rowIndex;\r\n                // esc\r\n                if (e.keyCode === 27) {\r\n                    self.endEdit(true);\r\n                    self.draw(true);\r\n                // enter\r\n                } else if (e.keyCode === 13\r\n                        && (!self.attributes.multiLine\r\n                            || (self.attributes.multiLine && e.shiftKey))) {\r\n                    self.endEdit();\r\n                    self.draw(true);\r\n                } else if (e.keyCode === 9) {\r\n                    e.preventDefault();\r\n                    if (!self.endEdit()) {\r\n                        return;\r\n                    }\r\n                    if (e.shiftKey) {\r\n                        nx = adjacentCells.left;\r\n                    } else {\r\n                        nx = adjacentCells.right;\r\n                    }\r\n                    if (adjacentCells.left === x && e.shiftKey) {\r\n                        nx = adjacentCells.last;\r\n                        ny -= 1;\r\n                    }\r\n                    if (adjacentCells.right === x && !e.shiftKey) {\r\n                        nx = adjacentCells.first;\r\n                        ny += 1;\r\n                    }\r\n                    if (ny < 0) {\r\n                        ny = self.data.length - 1;\r\n                    }\r\n                    if (ny > self.data.length - 1) {\r\n                        ny = 0;\r\n                    }\r\n                    self.scrollIntoView(nx, ny);\r\n                    self.beginEditAt(nx, ny, e);\r\n                }\r\n            });\r\n            self.dispatchEvent('beginedit', {cell: cell, input: self.input});\r\n        };\r\n        self.createInlineStyle = function (el, className) {\r\n            var css = {\r\n                'canvas-datagrid-context-menu-filter-input': {\r\n                    height: '19px',\r\n                    verticalAlign: 'bottom',\r\n                    marginLeft: '2px',\r\n                    padding: '0',\r\n                    background: self.style.contextFilterInputBackground,\r\n                    color: self.style.contextFilterInputColor,\r\n                    border: self.style.contextFilterInputBorder,\r\n                    borderRadius: self.style.contextFilterInputBorderRadius,\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextFilterInputFontFamily,\r\n                    fontSize: self.style.contextFilterInputFontSize\r\n                },\r\n                'canvas-datagrid-context-menu-filter-button': {\r\n                    height: '19px',\r\n                    verticalAlign: 'bottom',\r\n                    marginLeft: '2px',\r\n                    padding: '0',\r\n                    background: self.style.contextMenuBackground,\r\n                    color: self.style.contextMenuColor,\r\n                    border: self.style.contextFilterButtonBorder,\r\n                    borderRadius: self.style.contextFilterButtonBorderRadius,\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFilterButtonFontFamily,\r\n                    fontSize: self.style.contextMenuFilterButtonFontSize\r\n                },\r\n                'canvas-datagrid-context-child-arrow': {\r\n                    cssFloat: 'right',\r\n                    color: self.style.childContextMenuArrowColor,\r\n                    fontSize: self.style.contextMenuChildArrowFontSize,\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    verticalAlign: 'middle'\r\n                },\r\n                'canvas-datagrid-autocomplete': {\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize,\r\n                    background: self.style.contextMenuBackground,\r\n                    color: self.style.contextMenuColor,\r\n                    border: self.style.contextMenuBorder,\r\n                    padding: self.style.contextMenuPadding,\r\n                    borderRadius: self.style.contextMenuBorderRadius,\r\n                    opacity: self.style.contextMenuOpacity,\r\n                    position: 'absolute',\r\n                    zIndex: 9999,\r\n                    overflow: 'hidden'\r\n                },\r\n                'canvas-datagrid-autocomplete-item': {\r\n                    background: self.style.contextMenuBackground,\r\n                    color: self.style.contextMenuColor\r\n                },\r\n                'canvas-datagrid-autocomplete-item:hover': {\r\n                    background: self.style.contextMenuHoverBackground,\r\n                    color: self.style.contextMenuHoverColor\r\n                },\r\n                'canvas-datagrid-canvas': {\r\n                    position: 'absolute',\r\n                    zIndex: '-1'\r\n                },\r\n                'canvas-datagrid': {\r\n                    display: 'block'\r\n                },\r\n                'canvas-datagrid-control-input': {\r\n                    position: 'fixed',\r\n                    top: '-5px',\r\n                    left: '-5px',\r\n                    border: 'none',\r\n                    opacity: '0',\r\n                    cursor: 'pointer',\r\n                    width: '1px',\r\n                    height: '1px',\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize\r\n                },\r\n                'canvas-datagrid-edit-mobile-input': {\r\n                    boxSizing: 'content-box',\r\n                    outline: 'none',\r\n                    margin: '0',\r\n                    padding: '0 0 0 0',\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.mobileEditFontFamily,\r\n                    fontSize: self.style.mobileEditFontSize,\r\n                    border: self.style.editCellBorder,\r\n                    color: self.style.editCellColor,\r\n                    background: self.style.editCellBackgroundColor,\r\n                    appearance: 'none',\r\n                    webkitAppearance: 'none',\r\n                    mozAppearance: 'none',\r\n                    borderRadius: '0'\r\n                },\r\n                'canvas-datagrid-edit-input': {\r\n                    boxSizing: 'content-box',\r\n                    outline: 'none',\r\n                    margin: '0',\r\n                    padding: '0 0 0 ' + self.style.editCellPaddingLeft + 'px',\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.editCellFontFamily,\r\n                    fontSize: self.style.editCellFontSize,\r\n                    boxShadow: self.style.editCellBoxShadow,\r\n                    border: self.style.editCellBorder,\r\n                    color: self.style.editCellColor,\r\n                    background: self.style.editCellBackgroundColor,\r\n                    appearance: 'none',\r\n                    webkitAppearance: 'none',\r\n                    mozAppearance: 'none',\r\n                    borderRadius: '0'\r\n                },\r\n                'canvas-datagrid-context-menu-item-mobile': {\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize,\r\n                    color: 'inherit',\r\n                    background: 'inherit',\r\n                    margin: self.style.contextMenuItemMargin,\r\n                    borderRadius: self.style.contextMenuItemBorderRadius,\r\n                    verticalAlign: 'middle'\r\n                },\r\n                'canvas-datagrid-context-menu-item': {\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize,\r\n                    color: 'inherit',\r\n                    background: 'inherit',\r\n                    margin: self.style.contextMenuItemMargin,\r\n                    borderRadius: self.style.contextMenuItemBorderRadius,\r\n                    verticalAlign: 'middle'\r\n                },\r\n                'canvas-datagrid-context-menu-item:hover': {\r\n                    background: self.style.contextMenuHoverBackground,\r\n                    color: self.style.contextMenuHoverColor\r\n                },\r\n                'canvas-datagrid-context-menu-label': {\r\n                    margin: self.style.contextMenuLabelMargin,\r\n                    display: self.style.contextMenuLabelDisplay,\r\n                    minWidth: self.style.contextMenuLabelMinWidth,\r\n                    maxWidth: self.style.contextMenuLabelMaxWidth\r\n                },\r\n                'canvas-datagrid-context-menu-mobile': {\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize,\r\n                    background: self.style.contextMenuBackground,\r\n                    color: self.style.contextMenuColor,\r\n                    border: self.style.contextMenuBorder,\r\n                    padding: self.style.contextMenuPadding,\r\n                    borderRadius: self.style.contextMenuBorderRadius,\r\n                    opacity: self.style.contextMenuOpacity,\r\n                    overflow: 'hidden',\r\n                    whiteSpace: 'nowrap'\r\n                },\r\n                'canvas-datagrid-context-menu': {\r\n                    lineHeight: 'normal',\r\n                    fontWeight: 'normal',\r\n                    fontFamily: self.style.contextMenuFontFamily,\r\n                    fontSize: self.style.contextMenuFontSize,\r\n                    background: self.style.contextMenuBackground,\r\n                    color: self.style.contextMenuColor,\r\n                    border: self.style.contextMenuBorder,\r\n                    padding: self.style.contextMenuPadding,\r\n                    borderRadius: self.style.contextMenuBorderRadius,\r\n                    opacity: self.style.contextMenuOpacity,\r\n                    overflow: 'hidden',\r\n                    whiteSpace: 'nowrap',\r\n                    cursor: self.style.contextMenuCursor\r\n                },\r\n                'canvas-datagrid-invalid-search-regExp': {\r\n                    background: self.style.contextMenuFilterInvalidExpresion\r\n                }\r\n            };\r\n            if (css[className]) {\r\n                Object.keys(css[className]).map(function (prop) {\r\n                    el.style[prop] = css[className][prop];\r\n                });\r\n            }\r\n            return;\r\n        };\r\n        self.appendTo = function (e) {\r\n            self.parentNode = e;\r\n            self.setDom();\r\n        };\r\n        self.setDom = function () {\r\n            if (self.isChildGrid) {\r\n                self.parentGrid = self.parentNode.parentGrid;\r\n                self.ctx = self.parentGrid.context;\r\n                self.canvas = self.parentGrid.canvas;\r\n                self.controlInput = self.parentGrid.controlInput;\r\n                self.eventParent = self.canvas;\r\n            } else {\r\n                self.controlInput = self.controlInput || document.createElement('input');\r\n                self.controlInput.onblur = self.intf.blur;\r\n                self.createInlineStyle(self.controlInput, 'canvas-datagrid-control-input');\r\n                self.isChildGrid = false;\r\n                self.parentDOMNode = self.parentNode;\r\n                self.parentIsCanvas = /^canvas$/i.test(self.parentDOMNode.tagName);\r\n                if (self.parentIsCanvas) {\r\n                    self.canvas = self.parentDOMNode;\r\n                } else {\r\n                    self.canvas = document.createElement('canvas');\r\n                    self.parentDOMNode.appendChild(self.canvas);\r\n                }\r\n                document.body.appendChild(self.controlInput);\r\n                self.createInlineStyle(self.canvas, 'canvas-datagrid');\r\n                self.ctx = self.canvas.getContext('2d');\r\n                self.ctx.textBaseline = 'alphabetic';\r\n                self.eventParent = self.canvas;\r\n            }\r\n            self.parentNodeStyle = self.canvas.style;\r\n            self.controlInput.setAttribute('readonly', true);\r\n            self.controlInput.addEventListener('blur', function (e) {\r\n                if (e.target !== self.canvas) {\r\n                    self.hasFocus = false;\r\n                }\r\n            });\r\n            self.eventParent.addEventListener('scroll', self.resize, false);\r\n            self.eventParent.addEventListener('touchstart', self.touchstart, false);\r\n            self.eventParent.addEventListener('mouseup', self.mouseup, false);\r\n            self.eventParent.addEventListener('mousedown', self.mousedown, false);\r\n            self.eventParent.addEventListener('dblclick', self.dblclick, false);\r\n            self.eventParent.addEventListener('click', self.click, false);\r\n            self.eventParent.addEventListener('mousemove', self.mousemove);\r\n            self[self.isChildGrid ? 'parentGrid' : 'eventParent'].addEventListener('wheel', self.scrollWheel, false);\r\n            self.canvas.addEventListener('contextmenu', self.contextmenuEvent, false);\r\n            self.controlInput.addEventListener('copy', self.copy);\r\n            self.controlInput.addEventListener('cut', self.cut);\r\n            self.controlInput.addEventListener('paste', self.paste);\r\n            self.controlInput.addEventListener('keypress', self.keypress, false);\r\n            self.controlInput.addEventListener('keyup', self.keyup, false);\r\n            self.controlInput.addEventListener('keydown', self.keydown, false);\r\n            window.addEventListener('resize', self.resize);\r\n        };\r\n    };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/dom.js\n// module id = 8\n// module chunks = 0","/*jslint browser: true, unparam: true, todo: true*/\r\n/*globals define: true, MutationObserver: false, requestAnimationFrame: false, performance: false, btoa: false*/\r\ndefine([], function () {\r\n  'use strict';\r\n  return function (self) {\r\n    /**\r\n     * Converts a integer into a letter A - ZZZZZ...\r\n     * @memberof canvasDatagrid\r\n     * @name integerToAlpha\r\n     * @method\r\n     * @param {column} n The number to convert.\r\n     */\r\n    self.integerToAlpha = function (n) {\r\n      var ordA = 'a'.charCodeAt(0),\r\n        ordZ = 'z'.charCodeAt(0),\r\n        len = ordZ - ordA + 1,\r\n        s = '';\r\n      while (n >= 0) {\r\n        s = String.fromCharCode(n % len + ordA) + s;\r\n        n = Math.floor(n / len) - 1;\r\n      }\r\n      return s;\r\n    };\r\n    /**\r\n     * Inserts a new column before the specified index into the schema.\r\n     * @tutorial schema\r\n     * @memberof canvasDatagrid\r\n     * @name insertColumn\r\n     * @method\r\n     * @param {column} c The column to insert into the schema.\r\n     * @param {number} index The index of the column to insert before.\r\n     */\r\n    self.insertColumn = function (c, index) {\r\n      var s = self.getSchema();\r\n      if (s.length < index) {\r\n        throw new Error('Index is beyond the length of the schema.');\r\n      }\r\n      self.validateColumn(c, s);\r\n      s.splice(index, 0, c);\r\n      self.data.forEach(function (row) {\r\n        self.applyDefaultValue(row, c);\r\n      });\r\n      self.intf.schema = s;\r\n    };\r\n    /**\r\n     * Deletes a column from the schema at the specified index.\r\n     * @memberof canvasDatagrid\r\n     * @name deleteColumn\r\n     * @tutorial schema\r\n     * @method\r\n     * @param {number} index The index of the column to delete.\r\n     */\r\n    self.deleteColumn = function (index) {\r\n      var s = self.getSchema();\r\n      // remove data matching this column name from data\r\n      self.data.forEach(function (row) {\r\n        delete row[s[index].name];\r\n      });\r\n      s.splice(index, 1);\r\n      self.intf.schema = s;\r\n    };\r\n    /**\r\n     * Adds a new column into the schema.\r\n     * @tutorial schema\r\n     * @memberof canvasDatagrid\r\n     * @name addColumn\r\n     * @method\r\n     * @param {column} c The column to add to the schema.\r\n     */\r\n    self.addColumn = function (c) {\r\n      var s = self.getSchema();\r\n      self.validateColumn(c, s);\r\n      s.push(c);\r\n      self.data.forEach(function (row) {\r\n        self.applyDefaultValue(row, c);\r\n      });\r\n      self.intf.schema = s;\r\n    };\r\n    /**\r\n     * Deletes a row from the dataset at the specified index.\r\n     * @memberof canvasDatagrid\r\n     * @name deleteRow\r\n     * @method\r\n     * @param {number} index The index of the row to delete.\r\n     */\r\n    self.deleteRow = function (index) {\r\n      self.originalData.splice(index, 1);\r\n      self.setFilter();\r\n      self.resize(true);\r\n    };\r\n    /**\r\n     * Inserts a new row into the dataset before the specified index.\r\n     * @memberof canvasDatagrid\r\n     * @name insertRow\r\n     * @method\r\n     * @param {object} d data.\r\n     * @param {number} index The index of the row to insert before.\r\n     */\r\n    self.insertRow = function (d, index) {\r\n      if (self.originalData.length < index) {\r\n        throw new Error('Index is beyond the length of the dataset.');\r\n      }\r\n      self.originalData.splice(index, 0, d);\r\n      self.getSchema().forEach(function (c) {\r\n        if (d[c.name] === undefined) {\r\n          self.applyDefaultValue(self.originalData[index], c);\r\n        }\r\n      });\r\n      self.setFilter();\r\n      self.resize(true);\r\n    };\r\n    /**\r\n     * Adds a new row into the dataset.\r\n     * @memberof canvasDatagrid\r\n     * @name addRow\r\n     * @method\r\n     * @param {object} d data.\r\n     */\r\n    self.addRow = function (d) {\r\n      self.originalData.push(d);\r\n      self.getSchema().forEach(function (c) {\r\n        if (d[c.name] === undefined) {\r\n          self.applyDefaultValue(self.originalData[self.originalData.length - 1], c);\r\n        }\r\n      });\r\n      self.setFilter();\r\n      self.resize(true);\r\n    };\r\n    /**\r\n     * Sets the height of a given row by index number.\r\n     * @memberof canvasDatagrid\r\n     * @name setRowHeight\r\n     * @method\r\n     * @param {number} rowIndex The index of the row to set.\r\n     * @param {number} height Height to set the row to.\r\n     */\r\n    self.setRowHeight = function (rowIndex, height) {\r\n      self.sizes.rows[rowIndex] = height;\r\n      self.draw(true);\r\n    };\r\n    /**\r\n     * Sets the width of a given column by index number.\r\n     * @memberof canvasDatagrid\r\n     * @name setColumnWidth\r\n     * @method\r\n     * @param {number} colIndex The index of the column to set.\r\n     * @param {number} width Width to set the column to.\r\n     */\r\n    self.setColumnWidth = function (colIndex, width) {\r\n      self.sizes.columns[colIndex] = width;\r\n      self.draw(true);\r\n    };\r\n    /**\r\n     * Removes any changes to the width of the columns due to user or api interaction, setting them back to the schema or style default.\r\n     * @memberof canvasDatagrid\r\n     * @name resetColumnWidths\r\n     * @tutorial schema\r\n     * @method\r\n     */\r\n    self.resetColumnWidths = function () {\r\n      self.sizes.columns = {};\r\n      self.draw(true);\r\n    };\r\n    /**\r\n     * Removes any changes to the height of the rows due to user or api interaction, setting them back to the schema or style default.\r\n     * @memberof canvasDatagrid\r\n     * @name resetRowHeights\r\n     * @tutorial schema\r\n     * @method\r\n     */\r\n    self.resetRowHeights = function () {\r\n      self.sizes.rows = {};\r\n      self.draw(true);\r\n    };\r\n    /**\r\n     * Sets the value of the filter.\r\n     * @memberof canvasDatagrid\r\n     * @name setFilter\r\n     * @method\r\n     * @param {string} column Name of the column to filter.\r\n     * @param {string} value The value to filter for.\r\n     */\r\n    self.setFilter = function (column, value) {\r\n      if (column === undefined && value === undefined) {\r\n        self.columnFilters = {};\r\n      } else if (column && (value === '' || value === undefined)) {\r\n        delete self.columnFilters[column];\r\n      } else {\r\n        self.columnFilters[column] = value;\r\n      }\r\n      self.applyDataTransforms();\r\n    };\r\n    /**\r\n     * Returns the number of pixels to scroll down to line up with row rowIndex.\r\n     * @memberof canvasDatagrid\r\n     * @name findRowScrollTop\r\n     * @method\r\n     * @param {number} rowIndex The row index of the row to scroll find.\r\n     */\r\n    self.findRowScrollTop = function (rowIndex) {\r\n      if (self.scrollCache.y[rowIndex] === undefined) { throw new RangeError('Row index out of range.'); }\r\n      return self.scrollCache.y[rowIndex];\r\n    };\r\n    /**\r\n     * Returns the number of pixels to scroll to the left to line up with column columnIndex.\r\n     * @memberof canvasDatagrid\r\n     * @name findColumnScrollLeft\r\n     * @method\r\n     * @param {number} columnIndex The column index of the column to find.\r\n     */\r\n    self.findColumnScrollLeft = function (columnIndex) {\r\n      var i = Math.max(columnIndex - 1, 0);\r\n      if (self.scrollCache.x[i] === undefined) { throw new Error('Column index out of range.'); }\r\n      return self.scrollCache.x[i] - self.getColummnWidth(self.orders.columns[columnIndex]);\r\n    };\r\n    /**\r\n     * Scrolls to the cell at columnIndex x, and rowIndex y.  If you define both rowIndex and columnIndex additional calculations can be made to center the cell using the target cell's height and width.  Defining only one rowIndex or only columnIndex will result in simpler calculations.\r\n     * @memberof canvasDatagrid\r\n     * @name gotoCell\r\n     * @method\r\n     * @param {number} x The column index of the cell to scroll to.\r\n     * @param {number} y The row index of the cell to scroll to.\r\n     * @param {number} [offsetX=0] Percentage offset the cell should be from the left edge (not including headers).  The default is 0, meaning the cell will appear at the left edge. Valid values are 0 through 1. 1 = Left, 0 = Right, 0.5 = Center.\r\n     * @param {number} [offsetY=0] Percentage offset the cell should be from the top edge (not including headers).  The default is 0, meaning the cell will appear at the top edge. Valid values are 0 through 1. 1 = Bottom, 0 = Top, 0.5 = Center.\r\n     */\r\n    self.gotoCell = function (x, y, offsetX, offsetY) {\r\n      var targetX = x === undefined ? undefined : self.findColumnScrollLeft(x),\r\n        targetY = y === undefined ? undefined : self.findRowScrollTop(y),\r\n        cell,\r\n        sbw = self.scrollBox.width - (self.scrollBox.verticalBarVisible ? self.style.scrollBarWidth : 0),\r\n        sbh = self.scrollBox.height - (self.scrollBox.horizontalBarVisible ? self.style.scrollBarWidth : 0);\r\n      offsetX = offsetX === undefined ? 0 : offsetX;\r\n      offsetY = offsetY === undefined ? 0 : offsetY;\r\n      targetX -= sbw * offsetX;\r\n      targetY -= sbh * offsetY;\r\n      if (x !== undefined && y !== undefined) {\r\n        self.scrollBox.scrollTo(targetX, targetY);\r\n        requestAnimationFrame(function () {\r\n          cell = self.getVisibleCellByIndex(x, y);\r\n          // HACK: just don't offset if the target cell cannot be seen\r\n          // TODO: offset does not work on very small grids, not sure why\r\n          if (!cell) { return; }\r\n          targetX += cell.width * offsetX;\r\n          targetY += cell.height * offsetY;\r\n          self.scrollBox.scrollTo(targetX, targetY);\r\n        });\r\n      } else if (x !== undefined) {\r\n        self.scrollBox.scrollLeft = targetX;\r\n      } else if (y !== undefined) {\r\n        self.scrollBox.scrollTop = targetY;\r\n      }\r\n    };\r\n    /**\r\n     * Scrolls the row y.\r\n     * @memberof canvasDatagrid\r\n     * @name gotoRow\r\n     * @method\r\n     * @param {number} y The row index of the cell to scroll to.\r\n     */\r\n    self.gotoRow = function (y) {\r\n      self.gotoCell(0, y);\r\n    };\r\n    /**\r\n     * Scrolls the cell at cell x, row y into view if it is not already.\r\n     * @memberof canvasDatagrid\r\n     * @name scrollIntoView\r\n     * @method\r\n     * @param {number} x The column index of the cell to scroll into view.\r\n     * @param {number} y The row index of the cell to scroll into view.\r\n     * @param {number} [offsetX=0] Percentage offset the cell should be from the left edge (not including headers).  The default is 0, meaning the cell will appear at the left edge. Valid values are 0 through 1. 1 = Left, 0 = Right, 0.5 = Center.\r\n     * @param {number} [offsetY=0] Percentage offset the cell should be from the top edge (not including headers).  The default is 0, meaning the cell will appear at the top edge. Valid values are 0 through 1. 1 = Bottom, 0 = Top, 0.5 = Center.\r\n     */\r\n    self.scrollIntoView = function (x, y, offsetX, offsetY) {\r\n      if (self.visibleCells.filter(function (cell) {\r\n        return (cell.rowIndex === y || y === undefined)\r\n          && (cell.columnIndex === x || x === undefined)\r\n          && cell.x > 0\r\n          && cell.y > 0\r\n          && cell.x + cell.width < self.width\r\n          && cell.y + cell.height < self.height;\r\n      }).length === 0) {\r\n        self.gotoCell(x, y, offsetX, offsetY);\r\n      }\r\n    };\r\n    /**\r\n     * Sets the active cell. Requires redrawing.\r\n     * @memberof canvasDatagrid\r\n     * @name setActiveCell\r\n     * @method\r\n     * @param {number} x The column index of the cell to set active.\r\n     * @param {number} y The row index of the cell to set active.\r\n     */\r\n    self.setActiveCell = function (x, y) {\r\n      if (x < 0) { x = 0; }\r\n      if (y < 0) { y = 0; }\r\n      self.activeCell = {\r\n        rowIndex: y,\r\n        columnIndex: x\r\n      };\r\n    };\r\n    /**\r\n     * Removes the selection.\r\n     * @memberof canvasDatagrid\r\n     * @name selectNone\r\n     * @param {boolean} dontDraw Suppress the draw method after the selection change.\r\n     * @method\r\n     */\r\n    self.selectNone = function (dontDraw) {\r\n      self.selections = [];\r\n      self.dispatchEvent('selectionchanged', {\r\n        selectedData: self.getSelectedData(),\r\n        selections: self.selections,\r\n        selectionBounds: self.selectionBounds\r\n      });\r\n      if (dontDraw) { return; }\r\n      self.draw();\r\n    };\r\n    /**\r\n     * Selects every visible cell.\r\n     * @memberof canvasDatagrid\r\n     * @name selectAll\r\n     * @param {boolean} dontDraw Suppress the draw method after the selection change.\r\n     * @method\r\n     */\r\n    self.selectAll = function (dontDraw) {\r\n      self.selectArea({\r\n        top: 0,\r\n        left: -1,\r\n        right: self.getSchema().length - 1,\r\n        bottom: self.data.length - 1\r\n      });\r\n      if (dontDraw) { return; }\r\n      self.draw();\r\n    };\r\n    /**\r\n     * Returns true if the selected columnIndex is selected on every row.\r\n     * @memberof canvasDatagrid\r\n     * @name isColumnSelected\r\n     * @method\r\n     * @param {number} columnIndex The column index to check.\r\n     */\r\n    self.isColumnSelected = function (columnIndex) {\r\n      var colIsSelected = true;\r\n      self.data.forEach(function (row, rowIndex) {\r\n        if (!self.selections[rowIndex] || self.selections[rowIndex].indexOf(self.orders.columns[columnIndex]) === -1) {\r\n          colIsSelected = false;\r\n        }\r\n      });\r\n      return colIsSelected;\r\n    };\r\n    /**\r\n     * Runs the defined method on each selected cell.\r\n     * @memberof canvasDatagrid\r\n     * @name forEachSelectedCell\r\n     * @method\r\n     * @param {number} fn The function to execute.  The signature of the function is: (data, rowIndex, columnName).\r\n     * @param {number} expandToRow When true the data in the array is expanded to the entire row.\r\n     */\r\n    self.forEachSelectedCell = function (fn, expandToRow) {\r\n      var d = [], s = expandToRow ? self.getSchema() : self.getVisibleSchema(), l = self.data.length;\r\n      self.selections.forEach(function (row, index) {\r\n        if (index === l) { return; }\r\n        if (row.length === 0) {\r\n          d[index] = null;\r\n          return;\r\n        }\r\n        d[index] = {};\r\n        row.forEach(function (col) {\r\n          if (col === -1 || !s[col]) { return; }\r\n          fn(self.data, index, s[col].name);\r\n        });\r\n      });\r\n    };\r\n    /**\r\n     * Selects a column.\r\n     * @memberof canvasDatagrid\r\n     * @name selectColumn\r\n     * @method\r\n     * @param {number} columnIndex The column index to select.\r\n     * @param {boolean} toggleSelectMode When true, behaves as if you were holding control/command when you clicked the column.\r\n     * @param {boolean} shift When true, behaves as if you were holding shift when you clicked the column.\r\n     * @param {boolean} supressSelectionchangedEvent When true, prevents the selectionchanged event from firing.\r\n     */\r\n    self.selectColumn = function (columnIndex, ctrl, shift, supressEvent) {\r\n      var s, e, x;\r\n      function addCol(i) {\r\n        self.data.forEach(function (row, rowIndex) {\r\n          self.selections[rowIndex] = self.selections[rowIndex] || [];\r\n          if (self.selections[rowIndex].indexOf(i) === -1) {\r\n            self.selections[rowIndex].push(i);\r\n          }\r\n        });\r\n      }\r\n      function removeCol(i) {\r\n        self.data.forEach(function (row, rowIndex) {\r\n          self.selections[rowIndex] = self.selections[rowIndex] || [];\r\n          if (self.selections[rowIndex].indexOf(i) !== -1) {\r\n            self.selections[rowIndex].splice(self.selections[rowIndex].indexOf(i), 1);\r\n          }\r\n        });\r\n      }\r\n      if (shift) {\r\n        if (!self.activeCell) { return; }\r\n        s = Math.min(self.activeCell.columnIndex, columnIndex);\r\n        e = Math.max(self.activeCell.columnIndex, columnIndex);\r\n        for (x = s; e > x; x += 1) {\r\n          addCol(x);\r\n        }\r\n      }\r\n      if (!ctrl && !shift) {\r\n        self.selections = [];\r\n        self.activeCell.columnIndex = columnIndex;\r\n        self.activeCell.rowIndex = self.scrollIndexTop;\r\n      }\r\n      if (ctrl && self.isColumnSelected(columnIndex)) {\r\n        removeCol(columnIndex);\r\n      } else {\r\n        addCol(columnIndex);\r\n      }\r\n      if (supressEvent) { return; }\r\n      self.dispatchEvent('selectionchanged', {\r\n        selectedData: self.getSelectedData(),\r\n        selections: self.selections,\r\n        selectionBounds: self.getSelectionBounds()\r\n      });\r\n    };\r\n    /**\r\n     * Selects a row.\r\n     * @memberof canvasDatagrid\r\n     * @name selectRow\r\n     * @method\r\n     * @param {number} rowIndex The row index to select.\r\n     * @param {boolean} ctrl When true, behaves as if you were holding control/command when you clicked the row.\r\n     * @param {boolean} shift When true, behaves as if you were holding shift when you clicked the row.\r\n     * @param {boolean} supressSelectionchangedEvent When true, prevents the selectionchanged event from firing.\r\n     */\r\n    self.selectRow = function (rowIndex, ctrl, shift, supressEvent) {\r\n      var x, st, en, s = self.getVisibleSchema();\r\n      function de() {\r\n        if (supressEvent) { return; }\r\n        self.dispatchEvent('selectionchanged', {\r\n          selectedData: self.getSelectedData(),\r\n          selections: self.selections,\r\n          selectionBounds: self.selectionBounds\r\n        });\r\n      }\r\n      function addRow(ri) {\r\n        self.selections[ri] = [];\r\n        self.selections[ri].push(-1);\r\n        s.forEach(function (col, index) {\r\n          self.selections[ri].push(self.orders.columns.indexOf(col.index));\r\n        });\r\n      }\r\n      if (self.dragAddToSelection === false || self.dragObject === undefined) {\r\n        if (self.selections[rowIndex] && self.selections[rowIndex].length - 1 === s.length) {\r\n          if (ctrl) {\r\n            self.selections[rowIndex] = [];\r\n            de();\r\n            return;\r\n          }\r\n        }\r\n      }\r\n      if (self.dragAddToSelection === true || self.dragObject === undefined) {\r\n        if (shift && self.dragObject === undefined) {\r\n          if (!self.activeCell) { return; }\r\n          st = Math.min(self.activeCell.rowIndex, rowIndex);\r\n          en = Math.max(self.activeCell.rowIndex, rowIndex);\r\n          for (x = st; en >= x; x += 1) {\r\n            addRow(x);\r\n          }\r\n        } else {\r\n          addRow(rowIndex);\r\n        }\r\n      }\r\n      de();\r\n    };\r\n    /**\r\n     * Collapse a tree grid by row index.\r\n     * @memberof canvasDatagrid\r\n     * @name collapseTree\r\n     * @method\r\n     * @param {number} index The index of the row to collapse.\r\n     */\r\n    self.collapseTree = function (rowIndex) {\r\n      self.dispatchEvent('collapsetree', {\r\n        childGrid: self.childGrids[rowIndex],\r\n        data: self.data[rowIndex],\r\n        rowIndex: rowIndex\r\n      });\r\n      self.openChildren[rowIndex].blur();\r\n      self.openChildren[rowIndex].dispose();\r\n      delete self.openChildren[rowIndex];\r\n      delete self.sizes.trees[rowIndex];\r\n      delete self.childGrids[rowIndex];\r\n      self.dispatchEvent('resizerow', {\r\n        cellHeight: self.style.cellHeight\r\n      });\r\n      self.resize(true);\r\n      self.draw(true);\r\n    };\r\n    /**\r\n     * Expands a tree grid by row index.\r\n     * @memberof canvasDatagrid\r\n     * @name expandTree\r\n     * @method\r\n     * @param {number} index The index of the row to expand.\r\n     */\r\n    self.expandTree = function (rowIndex) {\r\n      var trArgs = self.args.treeGridAttributes || {},\r\n        columnHeaderCellHeight = self.getColumnHeaderCellHeight(),\r\n        rowHeaderCellWidth = self.sizes.columns.cornerCell || self.style.rowHeaderCellWidth,\r\n        h = self.sizes.trees[rowIndex] || self.style.treeGridHeight,\r\n        treeGrid;\r\n      if (!self.childGrids[rowIndex]) {\r\n        trArgs.debug = self.attributes.debug;\r\n        trArgs.name = self.attributes.saveAppearance ? self.attributes.name + 'tree' + rowIndex : undefined;\r\n        trArgs.style = trArgs.style || self.style;\r\n        trArgs.parentNode = {\r\n          parentGrid: self.intf,\r\n          nodeType: 'canvas-datagrid-tree',\r\n          offsetHeight: h,\r\n          offsetWidth: self.width - rowHeaderCellWidth,\r\n          header: { width: self.width - rowHeaderCellWidth },\r\n          offsetLeft: rowHeaderCellWidth,\r\n          offsetTop: columnHeaderCellHeight,\r\n          offsetParent: self.intf.parentNode,\r\n          parentNode: self.intf.parentNode,\r\n          style: 'tree',\r\n          data: self.data[rowIndex]\r\n        };\r\n        treeGrid = self.createGrid(trArgs);\r\n        self.childGrids[rowIndex] = treeGrid;\r\n      }\r\n      treeGrid = self.childGrids[rowIndex];\r\n      treeGrid.visible = true;\r\n      self.dispatchEvent('expandtree', {\r\n        treeGrid: treeGrid,\r\n        data: self.data[rowIndex],\r\n        rowIndex: rowIndex\r\n      });\r\n      self.openChildren[rowIndex] = treeGrid;\r\n      self.sizes.trees[rowIndex] = h;\r\n      self.dispatchEvent('resizerow', { height: self.style.cellHeight });\r\n      self.resize(true);\r\n    };\r\n    /**\r\n     * Toggles tree grid open and close by row index.\r\n     * @memberof canvasDatagrid\r\n     * @name toggleTree\r\n     * @method\r\n     * @param {number} index The index of the row to toggle.\r\n     */\r\n    self.toggleTree = function (rowIndex) {\r\n      var i = self.openChildren[rowIndex];\r\n      if (i) {\r\n        return self.collapseTree(rowIndex);\r\n      }\r\n      self.expandTree(rowIndex);\r\n    };\r\n    /**\r\n     * Returns a header from the schema by name.\r\n     * @memberof canvasDatagrid\r\n     * @name getHeaderByName\r\n     * @tutorial schema\r\n     * @method\r\n     * @returns {header} header with the selected name, or undefined.\r\n     * @param {string} name The name of the column to resize.\r\n     */\r\n    self.getHeaderByName = function (name) {\r\n      var x, i = self.getSchema();\r\n      for (x = 0; x < i.length; x += 1) {\r\n        if (i[x].name === name) {\r\n          return i[x];\r\n        }\r\n      }\r\n    };\r\n    /**\r\n     * Resizes a column to fit the longest value in the column. Call without a value to resize all columns.\r\n     * Warning, can be slow on very large record sets (1m records ~3-5 seconds on an i7).\r\n     * @memberof canvasDatagrid\r\n     * @name fitColumnToValues\r\n     * @method\r\n     * @param {string} name The name of the column to resize.\r\n     */\r\n    self.fitColumnToValues = function (name, internal) {\r\n      if (!self.canvas) { return; }\r\n      self.sizes.columns[name === 'cornerCell' ? -1 : self.getHeaderByName(name).index]\r\n        = Math.max(self.findColumnMaxTextLength(name), self.style.minColumnWidth);\r\n      if (!internal) {\r\n        self.resize();\r\n        self.draw(true);\r\n      }\r\n    };\r\n    /**\r\n     * Checks if a cell is currently visible.\r\n     * @memberof canvasDatagrid\r\n     * @name isCellVisible\r\n     * @overload\r\n     * @method\r\n     * @returns {boolean} when true, the cell is visible, when false the cell is not currently drawn.\r\n     * @param {number} columnIndex The column index of the cell to check.\r\n     * @param {number} rowIndex The row index of the cell to check.\r\n     */\r\n    self.isCellVisible = function (cell, rowIndex) {\r\n      // overload\r\n      if (rowIndex !== undefined) {\r\n        return self.visibleCells.filter(function (c) {\r\n          return c.columnIndex === cell && c.rowIndex === rowIndex;\r\n        }).length > 0;\r\n      }\r\n      var x, l = self.visibleCells.length;\r\n      for (x = 0; x < l; x += 1) {\r\n        if (cell.x === self.visibleCells[x].x && cell.y === self.visibleCells[x].y) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    /**\r\n     * Sets the order of the data.\r\n     * @memberof canvasDatagrid\r\n     * @name order\r\n     * @method\r\n     * @param {number} columnName Name of the column to be sorted.\r\n     * @param {string} direction `asc` for ascending or `desc` for descending.\r\n     * @param {function} [sortFunction] When defined, override the default sorting method defined in the column's schema and use this one.\r\n     * @param {bool} [dontSetStorageData] Don't store this setting for future use.\r\n     */\r\n    self.order = function (columnName, direction, sortFunction, dontSetStorageData) {\r\n      var f,\r\n        c = self.getSchema().filter(function (col) {\r\n          return col.name === columnName;\r\n        });\r\n      if (self.dispatchEvent('beforesortcolumn', { name: columnName, direction: direction })) { return; }\r\n      self.orderBy = columnName;\r\n      self.orderDirection = direction;\r\n      if (!self.data || self.data.length === 0) { return; }\r\n      if (c.length === 0) {\r\n        throw new Error('Cannot sort.  No such column name');\r\n      }\r\n      f = sortFunction || c[0].sorter || self.sorters[c[0].type];\r\n      if (!f && c[0].type !== undefined) {\r\n        console.warn('Cannot sort type \"%s\" falling back to string sort.', c[0].type);\r\n      }\r\n      self.orderings.add(columnName, direction, (typeof f === 'function' ? f : self.sorters.string));\r\n      self.orderings.sort();\r\n      self.dispatchEvent('sortcolumn', { name: columnName, direction: direction });\r\n      self.draw(true);\r\n      if (dontSetStorageData) { return; }\r\n      self.setStorageData();\r\n    };\r\n    self.isInGrid = function (e) {\r\n      if (e.x < 0\r\n        || e.x > self.width\r\n        || e.y < 0\r\n        || e.y > self.height) {\r\n        return false;\r\n      }\r\n      return true;\r\n    };\r\n    /**\r\n     * Moves the current selection relative to the its current position.  Note: this method does not move the selected data, just the selection itself.\r\n     * @memberof canvasDatagrid\r\n     * @name moveSelection\r\n     * @method\r\n     * @param {number} offsetX The number of columns to offset the selection.\r\n     * @param {number} offsetY The number of rows to offset the selection.\r\n     */\r\n    self.moveSelection = function (offsetX, offsetY) {\r\n      var sel = [];\r\n      self.selections.forEach(function (row, rowIndex) {\r\n        sel[rowIndex + offsetY] = [];\r\n        row.forEach(function (colIndex) {\r\n          sel[rowIndex + offsetY].push(colIndex + offsetX);\r\n        });\r\n      });\r\n      self.selections = sel;\r\n    };\r\n    /**\r\n     * Moves data in the provided selection to another position in the grid.  Moving data off the edge of the schema (columns/x) will truncate data.\r\n     * @memberof canvasDatagrid\r\n     * @name moveTo\r\n     * @method\r\n     * @param {array} sel 2D array representing selected rows and columns.  `canvasDatagrid.selections` is in this format and can be used here.\r\n     * @param {number} x The column index to start inserting the selection at.\r\n     * @param {number} y The row index to start inserting the selection at.\r\n     */\r\n    self.moveTo = function (sel, x, y) {\r\n      var d = self.getSelectedData(),\r\n        s = self.getVisibleSchema(),\r\n        l = sel.length,\r\n        xi,\r\n        maxRowLength = -Infinity,\r\n        minXi = Infinity,\r\n        yi = y - 1;\r\n      sel.forEach(function (row, index) {\r\n        if (index === l) { return; }\r\n        if (row.length === 0) { return; }\r\n        minXi = Math.min(self.getVisibleColumnIndexOf(x), minXi);\r\n        maxRowLength = Math.max(maxRowLength, row.length);\r\n        row.forEach(function (colIndex) {\r\n          // intentional redef of colIndex\r\n          colIndex = self.getVisibleColumnIndexOf(colIndex);\r\n          if (!s[colIndex]) { return; }\r\n          if (!self.data[index]) { self.data[index] = {}; }\r\n          self.data[index][s[colIndex].name] = null;\r\n        });\r\n      });\r\n      sel.forEach(function (row, index) {\r\n        var lastSourceIndex;\r\n        yi += 1;\r\n        xi = self.getVisibleColumnIndexOf(x);\r\n        row.forEach(function (colIndex, cidx) {\r\n          colIndex = self.getVisibleColumnIndexOf(colIndex);\r\n          if (cidx > 0) {\r\n            // this confusing bit of nonsense figures out\r\n            // if the selection has skipped cells\r\n            xi += colIndex - lastSourceIndex;\r\n          }\r\n          lastSourceIndex = colIndex;\r\n          if (colIndex === -1\r\n            || !s[xi]\r\n            || !s[colIndex]\r\n            || self.data.length - 1 < yi\r\n            || yi < 0) { return; }\r\n          if (!self.data[yi]) { self.data[yi] = {}; }\r\n          self.data[yi][s[xi].name] = d[index][s[colIndex].name];\r\n        });\r\n      });\r\n    };\r\n    /**\r\n     * Checks if a given column is visible.\r\n     * @memberof canvasDatagrid\r\n     * @name isColumnVisible\r\n     * @method\r\n     * @returns {boolean} When true, the column is visible.\r\n     * @param {number} columnIndex Column index.\r\n     */\r\n    self.isColumnVisible = function (columnIndex) {\r\n      return self.visibleCells.filter(function (c) {\r\n        return c.columnIndex === columnIndex;\r\n      }).length > 0;\r\n    };\r\n    /**\r\n     * Checks if a given row is visible.\r\n     * @memberof canvasDatagrid\r\n     * @name isRowVisible\r\n     * @method\r\n     * @returns {boolean} When true, the row is visible.\r\n     * @param {number} rowIndex Row index.\r\n     */\r\n    self.isRowVisible = function (rowIndex) {\r\n      return self.visibleCells.filter(function (c) {\r\n        return c.rowIndex === rowIndex;\r\n      }).length > 0;\r\n    };\r\n    /**\r\n     * Gets the cell at columnIndex and rowIndex.\r\n     * @memberof canvasDatagrid\r\n     * @name getVisibleCellByIndex\r\n     * @method\r\n     * @returns {cell} cell at the selected location.\r\n     * @param {number} x Column index.\r\n     * @param {number} y Row index.\r\n     */\r\n    self.getVisibleCellByIndex = function (x, y) {\r\n      return self.visibleCells.filter(function (c) {\r\n        return c.columnIndex === x && c.rowIndex === y;\r\n      })[0];\r\n    };\r\n    /**\r\n     * Gets the cell at grid pixel coordinate x and y.  Author's note.  This function ties drawing and events together.  This is a very complex function and is core to the component.\r\n     * @memberof canvasDatagrid\r\n     * @name getCellAt\r\n     * @method\r\n     * @returns {cell} cell at the selected location.\r\n     * @param {number} x Number of pixels from the left.\r\n     * @param {number} y Number of pixels from the top.\r\n     */\r\n    self.getCellAt = function (x, y, useTouchScrollZones, checkFrozenRow, mustFrozenRow) {\r\n      function getBorder(entitiy) {\r\n        if (entitiy.x + entitiy.width - (self.attributes.borderResizeZone * 0.4) < x && entitiy.x + entitiy.width + (self.attributes.borderResizeZone * 0.6) > x) {\r\n          return 'r';\r\n        }\r\n        if (entitiy.x - (self.attributes.borderResizeZone * 0.4) < x && entitiy.x + (self.attributes.borderResizeZone * 0.6) > x) {\r\n          return 'l';\r\n        }\r\n        if (entitiy.y + entitiy.height - (self.attributes.borderResizeZone * 0.4) < y && entitiy.y + entitiy.height + (self.attributes.borderResizeZone * 0.6) > y) {\r\n          return 'b';\r\n        }\r\n        if (entitiy.y - (self.attributes.borderResizeZone * 0.4) < y && entitiy.y + (self.attributes.borderResizeZone * 0.6) > y) {\r\n          return 't';\r\n        }\r\n      }\r\n      if (!self.visibleCells) { return; }\r\n      var border,\r\n        tsz = useTouchScrollZones ? self.attributes.touchScrollZone : 0,\r\n        moveMode = self.attributes.borderDragBehavior === 'move',\r\n        i,\r\n        l = self.visibleCells.length,\r\n        moveBorder,\r\n        xBorderBehavior = moveMode ? self.cursorGrab : 'ew-resize',\r\n        yBorderBehavior = moveMode ? self.cursorGrab : 'ns-resize',\r\n        cell,\r\n        entitiy;\r\n      if (!self.visibleCells || !self.visibleCells.length) { return; }\r\n      self.hasFocus = true;\r\n      if (!(y < self.height\r\n        && y > 0\r\n        && x < self.width\r\n        && x > 0)) {\r\n        self.hasFocus = false;\r\n        return {\r\n          dragContext: 'inherit',\r\n          context: 'inherit'\r\n        };\r\n      }\r\n      for (i = 0; i < l; i += 1) {\r\n        cell = self.visibleCells[i];\r\n\r\n        // interactive dimensions of the cell.  used for touch \"over size\" zones\r\n        entitiy = {\r\n          x: cell.x,\r\n          y: cell.y,\r\n          height: cell.height,\r\n          width: cell.width\r\n        };\r\n        if (useTouchScrollZones && /(vertical|horizontal)-scroll-/.test(cell.style)) {\r\n          entitiy.x -= tsz;\r\n          entitiy.y -= tsz;\r\n          entitiy.height += tsz;\r\n          entitiy.width += tsz;\r\n        }\r\n        if (entitiy.x - self.style.cellBorderWidth < x\r\n          && entitiy.x + entitiy.width + self.style.cellBorderWidth > x\r\n          && entitiy.y - self.style.cellBorderWidth < y\r\n          && entitiy.y + entitiy.height + self.style.cellBorderWidth > y) {\r\n\r\n          if (mustFrozenRow) {\r\n            if (cell == null || cell.data == null || cell.data.pinnedIndex == null) {\r\n              cell = null;\r\n              continue;\r\n            }\r\n          }\r\n\r\n          if (/frozen-row-marker/.test(cell.style)) {\r\n            cell.dragContext = cell.style;\r\n            cell.context = 'row-resize';\r\n            return cell;\r\n          }\r\n          if (/frozen-column-marker/.test(cell.style)) {\r\n            cell.dragContext = cell.style;\r\n            cell.context = 'col-resize';\r\n            return cell;\r\n          }\r\n          if (/selection-handle-/.test(cell.style)) {\r\n            cell.dragContext = cell.style;\r\n            cell.context = 'crosshair';\r\n            return cell;\r\n          }\r\n          if (/vertical-scroll-(bar|box)/.test(cell.style)) {\r\n            cell.dragContext = 'vertical-scroll-box';\r\n            cell.context = 'vertical-scroll-box';\r\n            cell.isScrollBar = true;\r\n            cell.isVerticalScrollBar = true;\r\n            if (y > self.scrollBox.box.v.y + self.scrollBox.scrollBoxHeight) {\r\n              cell.dragContext = 'vertical-scroll-bottom';\r\n              cell.context = 'vertical-scroll-bottom';\r\n            } else if (y < self.scrollBox.box.v.y) {\r\n              cell.dragContext = 'vertical-scroll-top';\r\n              cell.context = 'vertical-scroll-top';\r\n            }\r\n            self.cursor = 'default';\r\n            return cell;\r\n          }\r\n          if (/horizontal-scroll-(bar|box)/.test(cell.style)) {\r\n            cell.dragContext = 'horizontal-scroll-box';\r\n            cell.context = 'horizontal-scroll-box';\r\n            cell.isScrollBar = true;\r\n            cell.isHorizontalScrollBar = true;\r\n            if (x > self.scrollBox.box.h.x + self.scrollBox.scrollBoxWidth) {\r\n              cell.dragContext = 'horizontal-scroll-right';\r\n              cell.context = 'horizontal-scroll-right';\r\n            } else if (x < self.scrollBox.box.h.x) {\r\n              cell.dragContext = 'horizontal-scroll-left';\r\n              cell.context = 'horizontal-scroll-left';\r\n            }\r\n            self.cursor = 'default';\r\n            return cell;\r\n          }\r\n          border = getBorder(entitiy);\r\n          // check if the border of this cell is the border of the selection and if so show move cursor in move mode\r\n          moveBorder = moveMode && cell.selectionBorder && cell.selectionBorder.indexOf(border) !== -1;\r\n          if (['l', 'r'].indexOf(border) !== -1\r\n            && (self.attributes.allowColumnResize || moveBorder)\r\n            && ((self.attributes.allowColumnResizeFromCell && cell.isNormal) || !cell.isNormal || moveBorder)\r\n            && ((self.attributes.allowRowHeaderResize && (cell.isRowHeader || cell.isCorner)) || !(cell.isRowHeader && cell.isCorner))) {\r\n            if (((cell.isColumnHeader || cell.isCorner) || (self.attributes.allowColumnResizeFromCell && cell.isNormal)) && border === 'r') {\r\n              cell.context = 'ew-resize';\r\n              cell.dragContext = 'ew-resize';\r\n              return cell;\r\n            }\r\n            if (!(cell.isColumnHeader || cell.isCorner) && moveBorder) {\r\n              cell.context = xBorderBehavior;\r\n              cell.dragContext = border + '-move';\r\n              return cell;\r\n            }\r\n          }\r\n          if (['t', 'b'].indexOf(border) !== -1\r\n            && cell.rowIndex > -1\r\n            && (self.attributes.allowRowResize || moveBorder)\r\n            && ((self.attributes.allowRowResizeFromCell && cell.isNormal) || !cell.isNormal || moveBorder)\r\n            && !cell.isColumnHeader) {\r\n            if (((cell.isRowHeader || cell.isCorner) || (self.attributes.allowRowResizeFromCell && cell.isNormal)) && border === 'b') {\r\n              cell.context = 'ns-resize';\r\n              cell.dragContext = 'ns-resize';\r\n              return cell;\r\n            }\r\n            if (!(cell.isRowHeader || cell.isCorner) && moveBorder) {\r\n              cell.context = yBorderBehavior;\r\n              cell.dragContext = border + '-move';\r\n              return cell;\r\n            }\r\n          }\r\n          if (cell.style === 'columnHeaderCell') {\r\n            if (cell.header && (cell.header.name === 's' || cell.header.name === 'pinned')) {\r\n              cell.context = 'cell';\r\n            } else {\r\n              cell.context = self.cursorGrab;\r\n            }\r\n\r\n            cell.dragContext = 'column-reorder';\r\n            return cell;\r\n          }\r\n          if (cell.style === 'rowHeaderCell') {\r\n            if ((self.attributes.rowGrabZoneSize + (cell.height / 2 + cell.y - self.style.cellBorderWidth) < y)\r\n              || !self.attributes.allowRowReordering) {\r\n              cell.dragContext = 'cell';\r\n              cell.context = 'cell';\r\n            } else {\r\n              cell.context = self.cursorGrab;\r\n              cell.dragContext = 'row-reorder';\r\n            }\r\n            return cell;\r\n          }\r\n          if (cell.isGrid) {\r\n            self.hasFocus = false;\r\n            cell.dragContext = 'cell-grid';\r\n            cell.context = 'cell-grid';\r\n            return cell;\r\n          }\r\n          if (cell.style === 'tree-grid') {\r\n            self.hasFocus = false;\r\n            cell.dragContext = 'tree';\r\n            cell.context = 'tree';\r\n            return cell;\r\n          }\r\n\r\n          if (checkFrozenRow && cell) {\r\n            if (cell.data && cell.data.pinnedIndex == null) {\r\n              const frozenCell = self.getCellAt(x, y, false, false, true);\r\n              if (frozenCell && frozenCell.data && frozenCell.data.pinnedIndex != null) {\r\n                cell = frozenCell;\r\n              }\r\n            }\r\n          }\r\n\r\n          cell.dragContext = 'cell';\r\n          cell.context = 'cell';\r\n          return cell;\r\n        }\r\n      }\r\n      self.hasFocus = true;\r\n      self.cursor = 'default';\r\n      return {\r\n        dragContext: 'background',\r\n        context: 'background',\r\n        style: 'background',\r\n        isBackground: true\r\n      };\r\n    };\r\n    /**\r\n     * Gets the bounds of current selection. \r\n     * @returns {rect} selection.\r\n     * @memberof canvasDatagrid\r\n     * @name getSelectionBounds\r\n     * @method\r\n     */\r\n    self.getSelectionBounds = function () {\r\n      var low = { x: Infinity, y: Infinity },\r\n        high = { x: -Infinity, y: -Infinity };\r\n      self.selections.forEach(function (row, rowIndex) {\r\n        var maxCol, minCol;\r\n        low.y = rowIndex < low.y ? rowIndex : low.y;\r\n        high.y = rowIndex > high.y ? rowIndex : high.y;\r\n        maxCol = Math.max.apply(null, row);\r\n        minCol = Math.min.apply(null, row);\r\n        low.x = minCol < low.x ? minCol : low.x;\r\n        high.x = maxCol > high.x ? maxCol : high.x;\r\n      });\r\n      return {\r\n        top: low.y,\r\n        left: low.x,\r\n        bottom: high.y,\r\n        right: high.x\r\n      };\r\n    };\r\n    /**\r\n     * Returns an auto generated schema based on data structure.\r\n     * @memberof canvasDatagrid\r\n     * @name getSchemaFromData\r\n     * @method\r\n     * @tutorial schema\r\n     * @returns {schema} schema A schema based on the first item in the data array.\r\n     */\r\n    self.getSchemaFromData = function (d) {\r\n      d = d || self.data;\r\n      return Object.keys(d[0] || { ' ': '' }).map(function mapEachSchemaColumn(key, index) {\r\n        var type = self.getBestGuessDataType(key, d),\r\n          i = {\r\n            name: key,\r\n            title: isNaN(parseInt(key, 10)) ? key : self.integerToAlpha(key).toUpperCase(),\r\n            index: index,\r\n            columnIndex: index,\r\n            type: type,\r\n            filter: self.filter(type)\r\n          };\r\n        if (self.storedSettings\r\n          && self.storedSettings.visibility\r\n          && self.storedSettings.visibility[i.name] !== undefined) {\r\n          i.hidden = !self.storedSettings.visibility[i.name];\r\n        }\r\n        return i;\r\n      });\r\n    };\r\n    /**\r\n     * Clears the change log grid.changes that keeps track of changes to the data set.\r\n     * This does not undo changes or alter data it is simply a convince array to keep\r\n     * track of changes made to the data since last this method was called.\r\n     * @memberof canvasDatagrid\r\n     * @name clearChangeLog\r\n     * @method\r\n     */\r\n    self.clearChangeLog = function () {\r\n      self.changes = [];\r\n    };\r\n    /**\r\n     * Selects an area of the grid.\r\n     * @memberof canvasDatagrid\r\n     * @name selectArea\r\n     * @method\r\n     * @param {rect} bounds A rect object representing the selected values.\r\n     */\r\n    self.selectArea = function (bounds, ctrl) {\r\n      self.selectionBounds = bounds || self.selectionBounds;\r\n      var ev, x, y, s = self.getSchema();\r\n      if (!ctrl) {\r\n        self.selections = [];\r\n      }\r\n      if (self.selectionBounds.top < -1\r\n        || self.selectionBounds.bottom > self.data.length\r\n        || self.selectionBounds.left < -1\r\n        || self.selectionBounds.right > s.length) {\r\n        throw new Error('Impossible selection area');\r\n      }\r\n      for (x = self.selectionBounds.top; x <= self.selectionBounds.bottom; x += 1) {\r\n        self.selections[x] = [];\r\n        for (y = self.selectionBounds.left; y <= self.selectionBounds.right; y += 1) {\r\n          if (self.selections[x].indexOf(y) === -1) {\r\n            self.selections[x].push(y);\r\n          }\r\n        }\r\n      }\r\n      ev = {\r\n        selections: self.selections,\r\n        selectionBounds: self.selectionBounds\r\n      };\r\n      Object.defineProperty(ev, 'selectedData', {\r\n        get: function () {\r\n          return self.getSelectedData();\r\n        }\r\n      });\r\n      self.dispatchEvent('selectionchanged', ev);\r\n    };\r\n    /**\r\n     * Returns the maximum text width for a given column by column name.\r\n     * @memberof canvasDatagrid\r\n     * @name findColumnMaxTextLength\r\n     * @method\r\n     * @returns {number} The number of pixels wide the maximum width value in the selected column.\r\n     * @param {string} name The name of the column to calculate the value's width of.\r\n     */\r\n    self.findColumnMaxTextLength = function (name) {\r\n      var m = -Infinity;\r\n      if (name === 'cornerCell') {\r\n        self.ctx.font = self.style.rowHeaderCellFont;\r\n        return self.ctx.measureText((self.data.length + (self.attributes.showNewRow ? 1 : 0)).toString()).width\r\n          + self.style.autosizePadding + self.style.autosizeHeaderCellPadding\r\n          + self.style.rowHeaderCellPaddingRight\r\n          + self.style.rowHeaderCellPaddingLeft\r\n          + (self.attributes.tree ? self.style.treeArrowWidth\r\n            + self.style.treeArrowMarginLeft + self.style.treeArrowMarginRight : 0);\r\n      }\r\n      self.getSchema().forEach(function (col) {\r\n        if (col.name !== name) { return; }\r\n        self.ctx.font = self.style.columnHeaderCellFont;\r\n        var t = self.ctx.measureText(col.title || col.name).width\r\n          + self.style.headerCellPaddingRight\r\n          + self.style.headerCellPaddingLeft;\r\n        m = t > m ? t : m;\r\n      });\r\n      self.data.forEach(function (row) {\r\n        self.ctx.font = self.style.cellFont;\r\n        var t = self.ctx.measureText(row[name]).width\r\n          + self.style.cellPaddingRight\r\n          + self.style.cellPaddingLeft + self.style.cellAutoResizePadding;\r\n        m = t > m ? t : m;\r\n      });\r\n      return m;\r\n    };\r\n    /**\r\n     * Gets the total width of all header columns.\r\n     * @memberof canvasDatagrid\r\n     * @name getHeaderWidth\r\n     * @method\r\n     */\r\n    self.getHeaderWidth = function () {\r\n      return self.getVisibleSchema().reduce(function (total, header) {\r\n        return total + (header.width || self.style.cellWidth);\r\n      }, 0);\r\n    };\r\n    /**\r\n     * Gets the height of a row by index.\r\n     * @memberof canvasDatagrid\r\n     * @name getRowHeight\r\n     * @method\r\n     * @param {number} rowIndex The row index to lookup.\r\n     */\r\n    self.getRowHeight = function (rowIndex) {\r\n      return ((self.sizes.rows[rowIndex]\r\n        || self.style.cellHeight) * self.scale);\r\n    };\r\n    /**\r\n     * Gets the width of a column by index.\r\n     * @memberof canvasDatagrid\r\n     * @name getColummnWidth\r\n     * @method\r\n     * @param {number} columnIndex The column index to lookup.\r\n     */\r\n    self.getColummnWidth = function (columnIndex) {\r\n      return ((self.sizes.columns[columnIndex]\r\n        || self.getSchema()[columnIndex].width\r\n        || self.style.cellWidth) * self.scale);\r\n    };\r\n    self.formatters.string = function cellFormatterString(e) {\r\n      return e.cell.value !== undefined ? e.cell.value : '';\r\n    };\r\n    self.formatters.rowHeaderCell = self.formatters.string;\r\n    self.formatters.headerCell = self.formatters.string;\r\n    self.formatters.number = self.formatters.string;\r\n    self.formatters.int = self.formatters.string;\r\n    self.formatters.html = self.formatters.string;\r\n    self.sorters.string = function (columnName, direction) {\r\n      var asc = direction === 'asc';\r\n      return function (a, b) {\r\n        if (a[columnName] === undefined || a[columnName] === null) {\r\n          return 1;\r\n        }\r\n        if (b[columnName] === undefined || b[columnName] === null) {\r\n          return 0;\r\n        }\r\n        if (asc) {\r\n          if (!a[columnName].localeCompare) { return 1; }\r\n          return a[columnName].localeCompare(b[columnName]);\r\n        }\r\n        if (!b[columnName].localeCompare) { return 1; }\r\n        return b[columnName].localeCompare(a[columnName]);\r\n      };\r\n    };\r\n    self.sorters.number = function (columnName, direction) {\r\n      var asc = direction === 'asc';\r\n      return function (a, b) {\r\n        if (asc) {\r\n          return a[columnName] - b[columnName];\r\n        }\r\n        return b[columnName] - a[columnName];\r\n      };\r\n    };\r\n    self.sorters.date = function (columnName, direction) {\r\n      var asc = direction === 'asc';\r\n      return function (a, b) {\r\n        if (asc) {\r\n          return new Date(a[columnName]).getTime()\r\n            - new Date(b[columnName]).getTime();\r\n        }\r\n        return new Date(b[columnName]).getTime()\r\n          - new Date(a[columnName]).getTime();\r\n      };\r\n    };\r\n  };\r\n});\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/publicMethods.js\n// module id = 9\n// module chunks = 0"],"sourceRoot":""}